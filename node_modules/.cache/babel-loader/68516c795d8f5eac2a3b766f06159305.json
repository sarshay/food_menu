{"ast":null,"code":"import _ol_math_ from '../../math.js';\nvar _ol_geom_flat_closest_ = {};\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n */\n\n_ol_geom_flat_closest_.point = function (flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var i, offset;\n\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = _ol_math_.lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n      }\n\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n\n  for (i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n\n  closestPoint.length = stride;\n};\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n\n\n_ol_geom_flat_closest_.getMaxSquaredDelta = function (flatCoordinates, offset, end, stride, maxSquaredDelta) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n\n    var squaredDelta = _ol_math_.squaredDistance(x1, y1, x2, y2);\n\n    if (squaredDelta > maxSquaredDelta) {\n      maxSquaredDelta = squaredDelta;\n    }\n\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return maxSquaredDelta;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n\n\n_ol_geom_flat_closest_.getsMaxSquaredDelta = function (flatCoordinates, offset, ends, stride, maxSquaredDelta) {\n  var i, ii;\n\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getMaxSquaredDelta(flatCoordinates, offset, end, stride, maxSquaredDelta);\n    offset = end;\n  }\n\n  return maxSquaredDelta;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n\n\n_ol_geom_flat_closest_.getssMaxSquaredDelta = function (flatCoordinates, offset, endss, stride, maxSquaredDelta) {\n  var i, ii;\n\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getsMaxSquaredDelta(flatCoordinates, offset, ends, stride, maxSquaredDelta);\n    offset = ends[ends.length - 1];\n  }\n\n  return maxSquaredDelta;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\n\n_ol_geom_flat_closest_.getClosestPoint = function (flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n\n  var i, squaredDistance;\n\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = _ol_math_.squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n\n  while (index < end) {\n    _ol_geom_flat_closest_.point(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);\n    }\n  }\n\n  if (isRing) {\n    // Check the closing segment.\n    _ol_geom_flat_closest_.point(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n    }\n  }\n\n  return minSquaredDistance;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\n\n_ol_geom_flat_closest_.getsClosestPoint = function (flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n\n  return minSquaredDistance;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\n\n_ol_geom_flat_closest_.getssClosestPoint = function (flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getsClosestPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n\n  return minSquaredDistance;\n};\n\nexport default _ol_geom_flat_closest_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/geom/flat/closest.js"],"names":["_ol_math_","_ol_geom_flat_closest_","point","flatCoordinates","offset1","offset2","stride","x","y","closestPoint","x1","y1","dx","dy","i","offset","t","lerp","length","getMaxSquaredDelta","end","maxSquaredDelta","x2","y2","squaredDelta","squaredDistance","getsMaxSquaredDelta","ends","ii","getssMaxSquaredDelta","endss","getClosestPoint","maxDelta","isRing","minSquaredDistance","opt_tmpPoint","tmpPoint","NaN","index","Math","max","sqrt","getsClosestPoint","getssClosestPoint"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,eAAtB;AACA,IAAIC,sBAAsB,GAAG,EAA7B;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,sBAAsB,CAACC,KAAvB,GAA+B,UAASC,eAAT,EAA0BC,OAA1B,EAAmCC,OAAnC,EAA4CC,MAA5C,EAAoDC,CAApD,EAAuDC,CAAvD,EAA0DC,YAA1D,EAAwE;AACrG,MAAIC,EAAE,GAAGP,eAAe,CAACC,OAAD,CAAxB;AACA,MAAIO,EAAE,GAAGR,eAAe,CAACC,OAAO,GAAG,CAAX,CAAxB;AACA,MAAIQ,EAAE,GAAGT,eAAe,CAACE,OAAD,CAAf,GAA2BK,EAApC;AACA,MAAIG,EAAE,GAAGV,eAAe,CAACE,OAAO,GAAG,CAAX,CAAf,GAA+BM,EAAxC;AACA,MAAIG,CAAJ,EAAOC,MAAP;;AACA,MAAIH,EAAE,KAAK,CAAP,IAAYC,EAAE,KAAK,CAAvB,EAA0B;AACxBE,IAAAA,MAAM,GAAGX,OAAT;AACD,GAFD,MAEO;AACL,QAAIY,CAAC,GAAG,CAAC,CAACT,CAAC,GAAGG,EAAL,IAAWE,EAAX,GAAgB,CAACJ,CAAC,GAAGG,EAAL,IAAWE,EAA5B,KAAmCD,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAlD,CAAR;;AACA,QAAIG,CAAC,GAAG,CAAR,EAAW;AACTD,MAAAA,MAAM,GAAGV,OAAT;AACD,KAFD,MAEO,IAAIW,CAAC,GAAG,CAAR,EAAW;AAChB,WAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGR,MAAhB,EAAwB,EAAEQ,CAA1B,EAA6B;AAC3BL,QAAAA,YAAY,CAACK,CAAD,CAAZ,GAAkBd,SAAS,CAACiB,IAAV,CAAed,eAAe,CAACC,OAAO,GAAGU,CAAX,CAA9B,EACdX,eAAe,CAACE,OAAO,GAAGS,CAAX,CADD,EACgBE,CADhB,CAAlB;AAED;;AACDP,MAAAA,YAAY,CAACS,MAAb,GAAsBZ,MAAtB;AACA;AACD,KAPM,MAOA;AACLS,MAAAA,MAAM,GAAGX,OAAT;AACD;AACF;;AACD,OAAKU,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGR,MAAhB,EAAwB,EAAEQ,CAA1B,EAA6B;AAC3BL,IAAAA,YAAY,CAACK,CAAD,CAAZ,GAAkBX,eAAe,CAACY,MAAM,GAAGD,CAAV,CAAjC;AACD;;AACDL,EAAAA,YAAY,CAACS,MAAb,GAAsBZ,MAAtB;AACD,CA3BD;AA8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAL,sBAAsB,CAACkB,kBAAvB,GAA4C,UAAShB,eAAT,EAA0BY,MAA1B,EAAkCK,GAAlC,EAAuCd,MAAvC,EAA+Ce,eAA/C,EAAgE;AAC1G,MAAIX,EAAE,GAAGP,eAAe,CAACY,MAAD,CAAxB;AACA,MAAIJ,EAAE,GAAGR,eAAe,CAACY,MAAM,GAAG,CAAV,CAAxB;;AACA,OAAKA,MAAM,IAAIT,MAAf,EAAuBS,MAAM,GAAGK,GAAhC,EAAqCL,MAAM,IAAIT,MAA/C,EAAuD;AACrD,QAAIgB,EAAE,GAAGnB,eAAe,CAACY,MAAD,CAAxB;AACA,QAAIQ,EAAE,GAAGpB,eAAe,CAACY,MAAM,GAAG,CAAV,CAAxB;;AACA,QAAIS,YAAY,GAAGxB,SAAS,CAACyB,eAAV,CAA0Bf,EAA1B,EAA8BC,EAA9B,EAAkCW,EAAlC,EAAsCC,EAAtC,CAAnB;;AACA,QAAIC,YAAY,GAAGH,eAAnB,EAAoC;AAClCA,MAAAA,eAAe,GAAGG,YAAlB;AACD;;AACDd,IAAAA,EAAE,GAAGY,EAAL;AACAX,IAAAA,EAAE,GAAGY,EAAL;AACD;;AACD,SAAOF,eAAP;AACD,CAdD;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApB,sBAAsB,CAACyB,mBAAvB,GAA6C,UAASvB,eAAT,EAA0BY,MAA1B,EAAkCY,IAAlC,EAAwCrB,MAAxC,EAAgDe,eAAhD,EAAiE;AAC5G,MAAIP,CAAJ,EAAOc,EAAP;;AACA,OAAKd,CAAC,GAAG,CAAJ,EAAOc,EAAE,GAAGD,IAAI,CAACT,MAAtB,EAA8BJ,CAAC,GAAGc,EAAlC,EAAsC,EAAEd,CAAxC,EAA2C;AACzC,QAAIM,GAAG,GAAGO,IAAI,CAACb,CAAD,CAAd;AACAO,IAAAA,eAAe,GAAGpB,sBAAsB,CAACkB,kBAAvB,CACdhB,eADc,EACGY,MADH,EACWK,GADX,EACgBd,MADhB,EACwBe,eADxB,CAAlB;AAEAN,IAAAA,MAAM,GAAGK,GAAT;AACD;;AACD,SAAOC,eAAP;AACD,CATD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApB,sBAAsB,CAAC4B,oBAAvB,GAA8C,UAAS1B,eAAT,EAA0BY,MAA1B,EAAkCe,KAAlC,EAAyCxB,MAAzC,EAAiDe,eAAjD,EAAkE;AAC9G,MAAIP,CAAJ,EAAOc,EAAP;;AACA,OAAKd,CAAC,GAAG,CAAJ,EAAOc,EAAE,GAAGE,KAAK,CAACZ,MAAvB,EAA+BJ,CAAC,GAAGc,EAAnC,EAAuC,EAAEd,CAAzC,EAA4C;AAC1C,QAAIa,IAAI,GAAGG,KAAK,CAAChB,CAAD,CAAhB;AACAO,IAAAA,eAAe,GAAGpB,sBAAsB,CAACyB,mBAAvB,CACdvB,eADc,EACGY,MADH,EACWY,IADX,EACiBrB,MADjB,EACyBe,eADzB,CAAlB;AAEAN,IAAAA,MAAM,GAAGY,IAAI,CAACA,IAAI,CAACT,MAAL,GAAc,CAAf,CAAb;AACD;;AACD,SAAOG,eAAP;AACD,CATD;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApB,sBAAsB,CAAC8B,eAAvB,GAAyC,UAAS5B,eAAT,EAA0BY,MAA1B,EAAkCK,GAAlC,EACrCd,MADqC,EAC7B0B,QAD6B,EACnBC,MADmB,EACX1B,CADW,EACRC,CADQ,EACLC,YADK,EACSyB,kBADT,EAErCC,YAFqC,EAEvB;AAChB,MAAIpB,MAAM,IAAIK,GAAd,EAAmB;AACjB,WAAOc,kBAAP;AACD;;AACD,MAAIpB,CAAJ,EAAOW,eAAP;;AACA,MAAIO,QAAQ,KAAK,CAAjB,EAAoB;AAClB;AACAP,IAAAA,eAAe,GAAGzB,SAAS,CAACyB,eAAV,CACdlB,CADc,EACXC,CADW,EACRL,eAAe,CAACY,MAAD,CADP,EACiBZ,eAAe,CAACY,MAAM,GAAG,CAAV,CADhC,CAAlB;;AAEA,QAAIU,eAAe,GAAGS,kBAAtB,EAA0C;AACxC,WAAKpB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGR,MAAhB,EAAwB,EAAEQ,CAA1B,EAA6B;AAC3BL,QAAAA,YAAY,CAACK,CAAD,CAAZ,GAAkBX,eAAe,CAACY,MAAM,GAAGD,CAAV,CAAjC;AACD;;AACDL,MAAAA,YAAY,CAACS,MAAb,GAAsBZ,MAAtB;AACA,aAAOmB,eAAP;AACD,KAND,MAMO;AACL,aAAOS,kBAAP;AACD;AACF;;AACD,MAAIE,QAAQ,GAAGD,YAAY,GAAGA,YAAH,GAAkB,CAACE,GAAD,EAAMA,GAAN,CAA7C;AACA,MAAIC,KAAK,GAAGvB,MAAM,GAAGT,MAArB;;AACA,SAAOgC,KAAK,GAAGlB,GAAf,EAAoB;AAClBnB,IAAAA,sBAAsB,CAACC,KAAvB,CACIC,eADJ,EACqBmC,KAAK,GAAGhC,MAD7B,EACqCgC,KADrC,EAC4ChC,MAD5C,EACoDC,CADpD,EACuDC,CADvD,EAC0D4B,QAD1D;;AAEAX,IAAAA,eAAe,GAAGzB,SAAS,CAACyB,eAAV,CAA0BlB,CAA1B,EAA6BC,CAA7B,EAAgC4B,QAAQ,CAAC,CAAD,CAAxC,EAA6CA,QAAQ,CAAC,CAAD,CAArD,CAAlB;;AACA,QAAIX,eAAe,GAAGS,kBAAtB,EAA0C;AACxCA,MAAAA,kBAAkB,GAAGT,eAArB;;AACA,WAAKX,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGR,MAAhB,EAAwB,EAAEQ,CAA1B,EAA6B;AAC3BL,QAAAA,YAAY,CAACK,CAAD,CAAZ,GAAkBsB,QAAQ,CAACtB,CAAD,CAA1B;AACD;;AACDL,MAAAA,YAAY,CAACS,MAAb,GAAsBZ,MAAtB;AACAgC,MAAAA,KAAK,IAAIhC,MAAT;AACD,KAPD,MAOO;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAgC,MAAAA,KAAK,IAAIhC,MAAM,GAAGiC,IAAI,CAACC,GAAL,CACb,CAACD,IAAI,CAACE,IAAL,CAAUhB,eAAV,IACAc,IAAI,CAACE,IAAL,CAAUP,kBAAV,CADD,IACkCF,QADnC,GAC+C,CAFjC,EAEoC,CAFpC,CAAlB;AAGD;AACF;;AACD,MAAIC,MAAJ,EAAY;AACV;AACAhC,IAAAA,sBAAsB,CAACC,KAAvB,CACIC,eADJ,EACqBiB,GAAG,GAAGd,MAD3B,EACmCS,MADnC,EAC2CT,MAD3C,EACmDC,CADnD,EACsDC,CADtD,EACyD4B,QADzD;;AAEAX,IAAAA,eAAe,GAAGzB,SAAS,CAACyB,eAAV,CAA0BlB,CAA1B,EAA6BC,CAA7B,EAAgC4B,QAAQ,CAAC,CAAD,CAAxC,EAA6CA,QAAQ,CAAC,CAAD,CAArD,CAAlB;;AACA,QAAIX,eAAe,GAAGS,kBAAtB,EAA0C;AACxCA,MAAAA,kBAAkB,GAAGT,eAArB;;AACA,WAAKX,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGR,MAAhB,EAAwB,EAAEQ,CAA1B,EAA6B;AAC3BL,QAAAA,YAAY,CAACK,CAAD,CAAZ,GAAkBsB,QAAQ,CAACtB,CAAD,CAA1B;AACD;;AACDL,MAAAA,YAAY,CAACS,MAAb,GAAsBZ,MAAtB;AACD;AACF;;AACD,SAAO4B,kBAAP;AACD,CAhED;AAmEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAjC,sBAAsB,CAACyC,gBAAvB,GAA0C,UAASvC,eAAT,EAA0BY,MAA1B,EAAkCY,IAAlC,EACtCrB,MADsC,EAC9B0B,QAD8B,EACpBC,MADoB,EACZ1B,CADY,EACTC,CADS,EACNC,YADM,EACQyB,kBADR,EAEtCC,YAFsC,EAExB;AAChB,MAAIC,QAAQ,GAAGD,YAAY,GAAGA,YAAH,GAAkB,CAACE,GAAD,EAAMA,GAAN,CAA7C;AACA,MAAIvB,CAAJ,EAAOc,EAAP;;AACA,OAAKd,CAAC,GAAG,CAAJ,EAAOc,EAAE,GAAGD,IAAI,CAACT,MAAtB,EAA8BJ,CAAC,GAAGc,EAAlC,EAAsC,EAAEd,CAAxC,EAA2C;AACzC,QAAIM,GAAG,GAAGO,IAAI,CAACb,CAAD,CAAd;AACAoB,IAAAA,kBAAkB,GAAGjC,sBAAsB,CAAC8B,eAAvB,CACjB5B,eADiB,EACAY,MADA,EACQK,GADR,EACad,MADb,EAEjB0B,QAFiB,EAEPC,MAFO,EAEC1B,CAFD,EAEIC,CAFJ,EAEOC,YAFP,EAEqByB,kBAFrB,EAEyCE,QAFzC,CAArB;AAGArB,IAAAA,MAAM,GAAGK,GAAT;AACD;;AACD,SAAOc,kBAAP;AACD,CAbD;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAjC,sBAAsB,CAAC0C,iBAAvB,GAA2C,UAASxC,eAAT,EAA0BY,MAA1B,EACvCe,KADuC,EAChCxB,MADgC,EACxB0B,QADwB,EACdC,MADc,EACN1B,CADM,EACHC,CADG,EACAC,YADA,EACcyB,kBADd,EAEvCC,YAFuC,EAEzB;AAChB,MAAIC,QAAQ,GAAGD,YAAY,GAAGA,YAAH,GAAkB,CAACE,GAAD,EAAMA,GAAN,CAA7C;AACA,MAAIvB,CAAJ,EAAOc,EAAP;;AACA,OAAKd,CAAC,GAAG,CAAJ,EAAOc,EAAE,GAAGE,KAAK,CAACZ,MAAvB,EAA+BJ,CAAC,GAAGc,EAAnC,EAAuC,EAAEd,CAAzC,EAA4C;AAC1C,QAAIa,IAAI,GAAGG,KAAK,CAAChB,CAAD,CAAhB;AACAoB,IAAAA,kBAAkB,GAAGjC,sBAAsB,CAACyC,gBAAvB,CACjBvC,eADiB,EACAY,MADA,EACQY,IADR,EACcrB,MADd,EAEjB0B,QAFiB,EAEPC,MAFO,EAEC1B,CAFD,EAEIC,CAFJ,EAEOC,YAFP,EAEqByB,kBAFrB,EAEyCE,QAFzC,CAArB;AAGArB,IAAAA,MAAM,GAAGY,IAAI,CAACA,IAAI,CAACT,MAAL,GAAc,CAAf,CAAb;AACD;;AACD,SAAOgB,kBAAP;AACD,CAbD;;AAcA,eAAejC,sBAAf","sourcesContent":["import _ol_math_ from '../../math.js';\nvar _ol_geom_flat_closest_ = {};\n\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n */\n_ol_geom_flat_closest_.point = function(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var i, offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = _ol_math_.lerp(flatCoordinates[offset1 + i],\n            flatCoordinates[offset2 + i], t);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n};\n\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getMaxSquaredDelta = function(flatCoordinates, offset, end, stride, maxSquaredDelta) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = _ol_math_.squaredDistance(x1, y1, x2, y2);\n    if (squaredDelta > maxSquaredDelta) {\n      maxSquaredDelta = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return maxSquaredDelta;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getsMaxSquaredDelta = function(flatCoordinates, offset, ends, stride, maxSquaredDelta) {\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getMaxSquaredDelta(\n        flatCoordinates, offset, end, stride, maxSquaredDelta);\n    offset = end;\n  }\n  return maxSquaredDelta;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxSquaredDelta Max squared delta.\n * @return {number} Max squared delta.\n */\n_ol_geom_flat_closest_.getssMaxSquaredDelta = function(flatCoordinates, offset, endss, stride, maxSquaredDelta) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    maxSquaredDelta = _ol_geom_flat_closest_.getsMaxSquaredDelta(\n        flatCoordinates, offset, ends, stride, maxSquaredDelta);\n    offset = ends[ends.length - 1];\n  }\n  return maxSquaredDelta;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getClosestPoint = function(flatCoordinates, offset, end,\n    stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n    opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  var i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = _ol_math_.squaredDistance(\n        x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n  while (index < end) {\n    _ol_geom_flat_closest_.point(\n        flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max(\n          ((Math.sqrt(squaredDistance) -\n            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    _ol_geom_flat_closest_.point(\n        flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = _ol_math_.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getsClosestPoint = function(flatCoordinates, offset, ends,\n    stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n    opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getClosestPoint(\n        flatCoordinates, offset, end, stride,\n        maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n  return minSquaredDistance;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array.<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array.<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_flat_closest_.getssClosestPoint = function(flatCoordinates, offset,\n    endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n    opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = _ol_geom_flat_closest_.getsClosestPoint(\n        flatCoordinates, offset, ends, stride,\n        maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n};\nexport default _ol_geom_flat_closest_;\n"]},"metadata":{},"sourceType":"module"}
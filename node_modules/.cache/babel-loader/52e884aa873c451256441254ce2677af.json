{"ast":null,"code":"import _ol_ from '../index.js';\nimport _ol_style_Atlas_ from '../style/atlas.js';\n/**\n * Manages the creation of image atlases.\n *\n * Images added to this manager will be inserted into an atlas, which\n * will be used for rendering.\n * The `size` given in the constructor is the size for the first\n * atlas. After that, when new atlases are created, they will have\n * twice the size as the latest atlas (until `maxSize` is reached).\n *\n * If an application uses many images or very large images, it is recommended\n * to set a higher `size` value to avoid the creation of too many atlases.\n *\n * @constructor\n * @struct\n * @api\n * @param {olx.style.AtlasManagerOptions=} opt_options Options.\n */\n\nvar _ol_style_AtlasManager_ = function (opt_options) {\n  var options = opt_options || {};\n  /**\n   * The size in pixels of the latest atlas image.\n   * @private\n   * @type {number}\n   */\n\n  this.currentSize_ = options.initialSize !== undefined ? options.initialSize : _ol_.INITIAL_ATLAS_SIZE;\n  /**\n   * The maximum size in pixels of atlas images.\n   * @private\n   * @type {number}\n   */\n\n  this.maxSize_ = options.maxSize !== undefined ? options.maxSize : _ol_.MAX_ATLAS_SIZE != -1 ? _ol_.MAX_ATLAS_SIZE : _ol_.WEBGL_MAX_TEXTURE_SIZE !== undefined ? _ol_.WEBGL_MAX_TEXTURE_SIZE : 2048;\n  /**\n   * The size in pixels between images.\n   * @private\n   * @type {number}\n   */\n\n  this.space_ = options.space !== undefined ? options.space : 1;\n  /**\n   * @private\n   * @type {Array.<ol.style.Atlas>}\n   */\n\n  this.atlases_ = [new _ol_style_Atlas_(this.currentSize_, this.space_)];\n  /**\n   * The size in pixels of the latest atlas image for hit-detection images.\n   * @private\n   * @type {number}\n   */\n\n  this.currentHitSize_ = this.currentSize_;\n  /**\n   * @private\n   * @type {Array.<ol.style.Atlas>}\n   */\n\n  this.hitAtlases_ = [new _ol_style_Atlas_(this.currentHitSize_, this.space_)];\n};\n/**\n * @param {string} id The identifier of the entry to check.\n * @return {?ol.AtlasManagerInfo} The position and atlas image for the\n *    entry, or `null` if the entry is not part of the atlas manager.\n */\n\n\n_ol_style_AtlasManager_.prototype.getInfo = function (id) {\n  /** @type {?ol.AtlasInfo} */\n  var info = this.getInfo_(this.atlases_, id);\n\n  if (!info) {\n    return null;\n  }\n\n  var hitInfo =\n  /** @type {ol.AtlasInfo} */\n  this.getInfo_(this.hitAtlases_, id);\n  return this.mergeInfos_(info, hitInfo);\n};\n/**\n * @private\n * @param {Array.<ol.style.Atlas>} atlases The atlases to search.\n * @param {string} id The identifier of the entry to check.\n * @return {?ol.AtlasInfo} The position and atlas image for the entry,\n *    or `null` if the entry is not part of the atlases.\n */\n\n\n_ol_style_AtlasManager_.prototype.getInfo_ = function (atlases, id) {\n  var atlas, info, i, ii;\n\n  for (i = 0, ii = atlases.length; i < ii; ++i) {\n    atlas = atlases[i];\n    info = atlas.get(id);\n\n    if (info) {\n      return info;\n    }\n  }\n\n  return null;\n};\n/**\n * @private\n * @param {ol.AtlasInfo} info The info for the real image.\n * @param {ol.AtlasInfo} hitInfo The info for the hit-detection\n *    image.\n * @return {?ol.AtlasManagerInfo} The position and atlas image for the\n *    entry, or `null` if the entry is not part of the atlases.\n */\n\n\n_ol_style_AtlasManager_.prototype.mergeInfos_ = function (info, hitInfo) {\n  return (\n    /** @type {ol.AtlasManagerInfo} */\n    {\n      offsetX: info.offsetX,\n      offsetY: info.offsetY,\n      image: info.image,\n      hitImage: hitInfo.image\n    }\n  );\n};\n/**\n * Add an image to the atlas manager.\n *\n * If an entry for the given id already exists, the entry will\n * be overridden (but the space on the atlas graphic will not be freed).\n *\n * If `renderHitCallback` is provided, the image (or the hit-detection version\n * of the image) will be rendered into a separate hit-detection atlas image.\n *\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *    Called to render the new image onto an atlas image.\n * @param {function(CanvasRenderingContext2D, number, number)=}\n *    opt_renderHitCallback Called to render a hit-detection image onto a hit\n *    detection atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *    `renderCallback` and `renderHitCallback`.\n * @return {?ol.AtlasManagerInfo}  The position and atlas image for the\n *    entry, or `null` if the image is too big.\n */\n\n\n_ol_style_AtlasManager_.prototype.add = function (id, width, height, renderCallback, opt_renderHitCallback, opt_this) {\n  if (width + this.space_ > this.maxSize_ || height + this.space_ > this.maxSize_) {\n    return null;\n  }\n  /** @type {?ol.AtlasInfo} */\n\n\n  var info = this.add_(false, id, width, height, renderCallback, opt_this);\n\n  if (!info) {\n    return null;\n  } // even if no hit-detection entry is requested, we insert a fake entry into\n  // the hit-detection atlas, to make sure that the offset is the same for\n  // the original image and the hit-detection image.\n\n\n  var renderHitCallback = opt_renderHitCallback !== undefined ? opt_renderHitCallback : _ol_.nullFunction;\n  var hitInfo =\n  /** @type {ol.AtlasInfo} */\n  this.add_(true, id, width, height, renderHitCallback, opt_this);\n  return this.mergeInfos_(info, hitInfo);\n};\n/**\n * @private\n * @param {boolean} isHitAtlas If the hit-detection atlases are used.\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *    Called to render the new image onto an atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *    `renderCallback` and `renderHitCallback`.\n * @return {?ol.AtlasInfo}  The position and atlas image for the entry,\n *    or `null` if the image is too big.\n */\n\n\n_ol_style_AtlasManager_.prototype.add_ = function (isHitAtlas, id, width, height, renderCallback, opt_this) {\n  var atlases = isHitAtlas ? this.hitAtlases_ : this.atlases_;\n  var atlas, info, i, ii;\n\n  for (i = 0, ii = atlases.length; i < ii; ++i) {\n    atlas = atlases[i];\n    info = atlas.add(id, width, height, renderCallback, opt_this);\n\n    if (info) {\n      return info;\n    } else if (!info && i === ii - 1) {\n      // the entry could not be added to one of the existing atlases,\n      // create a new atlas that is twice as big and try to add to this one.\n      var size;\n\n      if (isHitAtlas) {\n        size = Math.min(this.currentHitSize_ * 2, this.maxSize_);\n        this.currentHitSize_ = size;\n      } else {\n        size = Math.min(this.currentSize_ * 2, this.maxSize_);\n        this.currentSize_ = size;\n      }\n\n      atlas = new _ol_style_Atlas_(size, this.space_);\n      atlases.push(atlas); // run the loop another time\n\n      ++ii;\n    }\n  }\n\n  return null;\n};\n\nexport default _ol_style_AtlasManager_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/style/atlasmanager.js"],"names":["_ol_","_ol_style_Atlas_","_ol_style_AtlasManager_","opt_options","options","currentSize_","initialSize","undefined","INITIAL_ATLAS_SIZE","maxSize_","maxSize","MAX_ATLAS_SIZE","WEBGL_MAX_TEXTURE_SIZE","space_","space","atlases_","currentHitSize_","hitAtlases_","prototype","getInfo","id","info","getInfo_","hitInfo","mergeInfos_","atlases","atlas","i","ii","length","get","offsetX","offsetY","image","hitImage","add","width","height","renderCallback","opt_renderHitCallback","opt_this","add_","renderHitCallback","nullFunction","isHitAtlas","size","Math","min","push"],"mappings":"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","sourcesContent":["import _ol_ from '../index.js';\nimport _ol_style_Atlas_ from '../style/atlas.js';\n\n/**\n * Manages the creation of image atlases.\n *\n * Images added to this manager will be inserted into an atlas, which\n * will be used for rendering.\n * The `size` given in the constructor is the size for the first\n * atlas. After that, when new atlases are created, they will have\n * twice the size as the latest atlas (until `maxSize` is reached).\n *\n * If an application uses many images or very large images, it is recommended\n * to set a higher `size` value to avoid the creation of too many atlases.\n *\n * @constructor\n * @struct\n * @api\n * @param {olx.style.AtlasManagerOptions=} opt_options Options.\n */\nvar _ol_style_AtlasManager_ = function(opt_options) {\n\n  var options = opt_options || {};\n\n  /**\n   * The size in pixels of the latest atlas image.\n   * @private\n   * @type {number}\n   */\n  this.currentSize_ = options.initialSize !== undefined ?\n    options.initialSize : _ol_.INITIAL_ATLAS_SIZE;\n\n  /**\n   * The maximum size in pixels of atlas images.\n   * @private\n   * @type {number}\n   */\n  this.maxSize_ = options.maxSize !== undefined ?\n    options.maxSize : _ol_.MAX_ATLAS_SIZE != -1 ?\n      _ol_.MAX_ATLAS_SIZE : _ol_.WEBGL_MAX_TEXTURE_SIZE !== undefined ?\n        _ol_.WEBGL_MAX_TEXTURE_SIZE : 2048;\n\n  /**\n   * The size in pixels between images.\n   * @private\n   * @type {number}\n   */\n  this.space_ = options.space !== undefined ? options.space : 1;\n\n  /**\n   * @private\n   * @type {Array.<ol.style.Atlas>}\n   */\n  this.atlases_ = [new _ol_style_Atlas_(this.currentSize_, this.space_)];\n\n  /**\n   * The size in pixels of the latest atlas image for hit-detection images.\n   * @private\n   * @type {number}\n   */\n  this.currentHitSize_ = this.currentSize_;\n\n  /**\n   * @private\n   * @type {Array.<ol.style.Atlas>}\n   */\n  this.hitAtlases_ = [new _ol_style_Atlas_(this.currentHitSize_, this.space_)];\n};\n\n\n/**\n * @param {string} id The identifier of the entry to check.\n * @return {?ol.AtlasManagerInfo} The position and atlas image for the\n *    entry, or `null` if the entry is not part of the atlas manager.\n */\n_ol_style_AtlasManager_.prototype.getInfo = function(id) {\n  /** @type {?ol.AtlasInfo} */\n  var info = this.getInfo_(this.atlases_, id);\n\n  if (!info) {\n    return null;\n  }\n  var hitInfo = /** @type {ol.AtlasInfo} */ (this.getInfo_(this.hitAtlases_, id));\n\n  return this.mergeInfos_(info, hitInfo);\n};\n\n\n/**\n * @private\n * @param {Array.<ol.style.Atlas>} atlases The atlases to search.\n * @param {string} id The identifier of the entry to check.\n * @return {?ol.AtlasInfo} The position and atlas image for the entry,\n *    or `null` if the entry is not part of the atlases.\n */\n_ol_style_AtlasManager_.prototype.getInfo_ = function(atlases, id) {\n  var atlas, info, i, ii;\n  for (i = 0, ii = atlases.length; i < ii; ++i) {\n    atlas = atlases[i];\n    info = atlas.get(id);\n    if (info) {\n      return info;\n    }\n  }\n  return null;\n};\n\n\n/**\n * @private\n * @param {ol.AtlasInfo} info The info for the real image.\n * @param {ol.AtlasInfo} hitInfo The info for the hit-detection\n *    image.\n * @return {?ol.AtlasManagerInfo} The position and atlas image for the\n *    entry, or `null` if the entry is not part of the atlases.\n */\n_ol_style_AtlasManager_.prototype.mergeInfos_ = function(info, hitInfo) {\n  return /** @type {ol.AtlasManagerInfo} */ ({\n    offsetX: info.offsetX,\n    offsetY: info.offsetY,\n    image: info.image,\n    hitImage: hitInfo.image\n  });\n};\n\n\n/**\n * Add an image to the atlas manager.\n *\n * If an entry for the given id already exists, the entry will\n * be overridden (but the space on the atlas graphic will not be freed).\n *\n * If `renderHitCallback` is provided, the image (or the hit-detection version\n * of the image) will be rendered into a separate hit-detection atlas image.\n *\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *    Called to render the new image onto an atlas image.\n * @param {function(CanvasRenderingContext2D, number, number)=}\n *    opt_renderHitCallback Called to render a hit-detection image onto a hit\n *    detection atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *    `renderCallback` and `renderHitCallback`.\n * @return {?ol.AtlasManagerInfo}  The position and atlas image for the\n *    entry, or `null` if the image is too big.\n */\n_ol_style_AtlasManager_.prototype.add = function(id, width, height,\n    renderCallback, opt_renderHitCallback, opt_this) {\n  if (width + this.space_ > this.maxSize_ ||\n      height + this.space_ > this.maxSize_) {\n    return null;\n  }\n\n  /** @type {?ol.AtlasInfo} */\n  var info = this.add_(false,\n      id, width, height, renderCallback, opt_this);\n  if (!info) {\n    return null;\n  }\n\n  // even if no hit-detection entry is requested, we insert a fake entry into\n  // the hit-detection atlas, to make sure that the offset is the same for\n  // the original image and the hit-detection image.\n  var renderHitCallback = opt_renderHitCallback !== undefined ?\n    opt_renderHitCallback : _ol_.nullFunction;\n\n  var hitInfo = /** @type {ol.AtlasInfo} */ (this.add_(true,\n      id, width, height, renderHitCallback, opt_this));\n\n  return this.mergeInfos_(info, hitInfo);\n};\n\n\n/**\n * @private\n * @param {boolean} isHitAtlas If the hit-detection atlases are used.\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *    Called to render the new image onto an atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *    `renderCallback` and `renderHitCallback`.\n * @return {?ol.AtlasInfo}  The position and atlas image for the entry,\n *    or `null` if the image is too big.\n */\n_ol_style_AtlasManager_.prototype.add_ = function(isHitAtlas, id, width, height,\n    renderCallback, opt_this) {\n  var atlases = (isHitAtlas) ? this.hitAtlases_ : this.atlases_;\n  var atlas, info, i, ii;\n  for (i = 0, ii = atlases.length; i < ii; ++i) {\n    atlas = atlases[i];\n    info = atlas.add(id, width, height, renderCallback, opt_this);\n    if (info) {\n      return info;\n    } else if (!info && i === ii - 1) {\n      // the entry could not be added to one of the existing atlases,\n      // create a new atlas that is twice as big and try to add to this one.\n      var size;\n      if (isHitAtlas) {\n        size = Math.min(this.currentHitSize_ * 2, this.maxSize_);\n        this.currentHitSize_ = size;\n      } else {\n        size = Math.min(this.currentSize_ * 2, this.maxSize_);\n        this.currentSize_ = size;\n      }\n      atlas = new _ol_style_Atlas_(size, this.space_);\n      atlases.push(atlas);\n      // run the loop another time\n      ++ii;\n    }\n  }\n  return null;\n};\nexport default _ol_style_AtlasManager_;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\n\n\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport ReplayType from '../../render/canvas/BuilderType.js';\nimport TileState from '../../TileState.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport ViewHint from '../../ViewHint.js';\nimport { HIT_DETECT_RESOLUTION, createHitDetectionImageData, hitDetect } from '../../render/canvas/hitdetect.js';\nimport { apply as applyTransform, create as createTransform, multiply, reset as resetTransform, scale, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { boundingExtent, buffer, containsExtent, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\nimport { wrapX } from '../../coordinate.js';\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\n\nvar IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING],\n  'vector': []\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\n\nvar VECTOR_REPLAYS = {\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT]\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\n\nvar CanvasVectorTileLayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(CanvasVectorTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n\n\n  function CanvasVectorTileLayerRenderer(layer) {\n    var _this = _super.call(this, layer) || this;\n    /** @private */\n\n\n    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.renderedLayerRevision_;\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n\n    _this.renderedPixelToCoordinateTransform_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.renderedRotation_;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n\n    _this.tmpTransform_ = createTransform();\n    return _this;\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection) {\n    var render;\n    var state = tile.getState();\n\n    if (state === TileState.LOADED || state === TileState.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n\n      if (this.tileImageNeedsRender_(tile)) {\n        render = true;\n      }\n    }\n\n    return render;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var resolution = viewState.resolution;\n    var projection = viewState.projection;\n    var layer = this.getLayer();\n    var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n\n    var render = this.prepareTile(tile, pixelRatio, projection);\n\n    if (render && (hifi || Date.now() - frameState.time < 8) && layer.getRenderMode() !== VectorTileRenderType.VECTOR) {\n      this.renderTileImage_(tile, frameState);\n    }\n\n    return _super.prototype.getTile.call(this, z, x, y, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var layer = this.getLayer();\n    return _super.prototype.isDrawableTile.call(this, tile) && (layer.getRenderMode() === VectorTileRenderType.VECTOR ? getUid(layer) in tile.executorGroups : tile.hasContext(layer));\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage(this.getLayer());\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layerRevision = this.getLayer().getRevision();\n\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n\n    this.renderedLayerRevision_ = layerRevision;\n    return _super.prototype.prepareFrame.call(this, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {\n    var layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder = layer.getRenderOrder() || null;\n    var resolution = tile.wantedResolution;\n    var builderState = tile.getReplayState(layer);\n\n    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n\n    var source = layer.getSource();\n    var declutter = layer.getDeclutter();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    var layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n\n    if (declutter) {\n      tile.declutterExecutorGroups[layerUid] = [];\n    }\n\n    var _loop_1 = function (t, tt) {\n      var sourceTile = sourceTiles[t];\n\n      if (sourceTile.getState() != TileState.LOADED) {\n        return \"continue\";\n      }\n\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      var builderExtent = buffer(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);\n      var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : builderExtent;\n      builderState.dirty = false;\n      var builderGroup = new CanvasBuilderGroup(0, builderExtent, resolution, pixelRatio);\n      var declutterBuilderGroup = declutter ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio) : undefined;\n      var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n\n      var render = function (feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      var features = sourceTile.getFeatures();\n\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this_1, feature);\n        }\n      }\n\n      var executorGroupInstructions = builderGroup.finish(); // no need to clip when the render tile is covered by a single source tile\n\n      var replayExtent = layer.getRenderMode() !== VectorTileRenderType.VECTOR && declutter && sourceTiles.length === 1 ? null : sharedExtent;\n      var renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n\n      if (declutterBuilderGroup) {\n        var declutterExecutorGroup = new CanvasExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());\n        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      _loop_1(t, tt);\n    }\n\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    var source = layer.getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n\n    var features = {};\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n\n    var featureCallback = function (feature, geometry, distanceSq) {\n      var key = feature.getId();\n\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n\n      var match = features[key];\n\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n\n        matches.push(features[key] = {\n          feature: feature,\n          layer: layer,\n          geometry: geometry,\n          distanceSq: distanceSq,\n          callback: callback\n        });\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n\n      return undefined;\n    };\n\n    var renderedTiles =\n    /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n    this.renderedTiles;\n    var found;\n\n    var _loop_2 = function (i, ii) {\n      var tile = renderedTiles[i];\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n      if (!intersects(tileExtent, hitExtent)) {\n        return \"continue\";\n      }\n\n      var layerUid = getUid(layer);\n      var executorGroups = [tile.executorGroups[layerUid]];\n      var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n\n      if (declutterExecutorGroups) {\n        executorGroups.push(declutterExecutorGroups);\n      }\n\n      executorGroups.some(function (executorGroups) {\n        var declutteredFeatures = executorGroups === declutterExecutorGroups ? frameState.declutterTree.all().map(function (item) {\n          return item.value;\n        }) : null;\n\n        for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n          var executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);\n\n          if (found) {\n            return true;\n          }\n        }\n      });\n    };\n\n    for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      _loop_2(i, ii);\n    }\n\n    return found;\n  };\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {\n    return new Promise(function (resolve, reject) {\n      var layer =\n      /** @type {import(\"../../layer/VectorTile.js\").default} */\n      this.getLayer();\n      var layerUid = getUid(layer);\n      var source = layer.getSource();\n      var projection = this.renderedProjection;\n      var projectionExtent = projection.getExtent();\n      var resolution = this.renderedResolution;\n      var tileGrid = source.getTileGridForProjection(projection);\n      var coordinate = applyTransform(this.renderedPixelToCoordinateTransform_, pixel.slice());\n      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n      var tile;\n\n      for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {\n          tile = this.renderedTiles[i];\n\n          if (tile.getState() === TileState.LOADED) {\n            var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);\n\n            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent_1)) {\n              wrapX(coordinate, projection);\n            }\n\n            break;\n          }\n\n          tile = undefined;\n        }\n      }\n\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n\n      var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var corner = getTopLeft(extent);\n      var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];\n      var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      var hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n\n      if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n        var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));\n        var rotation = this.renderedRotation_;\n        var transforms = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)];\n        hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    }.bind(this));\n  };\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderDeclutter = function (frameState) {\n    var context = this.context;\n    var alpha = context.globalAlpha;\n    context.globalAlpha = this.getLayer().getOpacity();\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    var tiles =\n    /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n    this.renderedTiles;\n\n    for (var i = 0, ii = tiles.length; i < ii; ++i) {\n      var tile = tiles[i];\n      var declutterExecutorGroups = tile.declutterExecutorGroups[getUid(this.getLayer())];\n\n      if (declutterExecutorGroups) {\n        for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n          declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);\n        }\n      }\n    }\n\n    context.globalAlpha = alpha;\n  };\n\n  CanvasVectorTileLayerRenderer.prototype.getTileRenderTransform = function (tile, frameState) {\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var center = viewState.center;\n    var resolution = viewState.resolution;\n    var rotation = viewState.rotation;\n    var size = frameState.size;\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n    var source = this.getLayer().getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var tileCoord = tile.tileCoord;\n    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n    var transform = multiply(scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n    return transform;\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n\n    _super.prototype.renderFrame.call(this, frameState, target);\n\n    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    var layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    var renderMode = layer.getRenderMode();\n    var context = this.context;\n    var alpha = context.globalAlpha;\n    context.globalAlpha = layer.getOpacity();\n    var replayTypes = VECTOR_REPLAYS[renderMode];\n    var viewState = frameState.viewState;\n    var rotation = viewState.rotation;\n    var tiles = this.renderedTiles;\n    var clips = [];\n    var clipZs = [];\n\n    for (var i = tiles.length - 1; i >= 0; --i) {\n      var tile =\n      /** @type {import(\"../../VectorRenderTile.js\").default} */\n      tiles[i];\n      var transform = this.getTileRenderTransform(tile, frameState);\n      var executorGroups = tile.executorGroups[getUid(layer)];\n      var clipped = false;\n\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n\n        if (!executorGroup.hasExecutors(replayTypes)) {\n          // sourceTile has no instructions of the types we want to render\n          continue;\n        }\n\n        var currentZ = tile.tileCoord[0];\n        var currentClip = void 0;\n\n        if (!clipped) {\n          currentClip = executorGroup.getClipCoords(transform);\n\n          if (currentClip) {\n            context.save(); // Create a clip mask for regions in this low resolution tile that are\n            // already filled by a higher resolution tile\n\n            for (var j = 0, jj = clips.length; j < jj; ++j) {\n              var clip = clips[j];\n\n              if (currentZ < clipZs[j]) {\n                context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n                context.moveTo(currentClip[0], currentClip[1]);\n                context.lineTo(currentClip[2], currentClip[3]);\n                context.lineTo(currentClip[4], currentClip[5]);\n                context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile\n\n                context.moveTo(clip[6], clip[7]);\n                context.lineTo(clip[4], clip[5]);\n                context.lineTo(clip[2], clip[3]);\n                context.lineTo(clip[0], clip[1]);\n                context.clip();\n              }\n            }\n          }\n        }\n\n        executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);\n\n        if (!clipped && currentClip) {\n          context.restore();\n          clips.push(currentClip);\n          clipZs.push(currentZ);\n          clipped = true;\n        }\n      }\n    }\n\n    context.globalAlpha = alpha;\n    return this.container;\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder group for decluttering.\n   * @return {boolean} `true` if an image is loading.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {\n    if (!styles) {\n      return false;\n    }\n\n    var loading = false;\n\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup) || loading;\n      }\n    } else {\n      loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup);\n    }\n\n    return loading;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile) {\n    var layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n\n    if (layer.getRenderMode() === VectorTileRenderType.VECTOR) {\n      return false;\n    }\n\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var resolution = tile.wantedResolution;\n    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {\n    var layer =\n    /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n    var tileCoord = tile.wrappedTileCoord;\n    var z = tileCoord[0];\n    var source = layer.getSource();\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;\n    var resolution = tileGrid.getResolution(z);\n    var context = tile.getContext(layer); // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n\n    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));\n    var size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    var renderScale = pixelRatio / renderPixelRatio;\n\n    if (renderScale !== 1) {\n      var canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var pixelScale = renderPixelRatio / resolution;\n    var transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n\n    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n      var executorGroup = executorGroups[i];\n      executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n    }\n\n    replayState.renderedTileResolution = tile.wantedResolution;\n  };\n\n  return CanvasVectorTileLayerRenderer;\n}(CanvasTileLayerRenderer);\n\nexport default CanvasVectorTileLayerRenderer;","map":{"version":3,"sources":["../../src/renderer/canvas/VectorTileLayer.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport ReplayType from '../../render/canvas/BuilderType.js';\nimport TileState from '../../TileState.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport ViewHint from '../../ViewHint.js';\nimport { HIT_DETECT_RESOLUTION, createHitDetectionImageData, hitDetect, } from '../../render/canvas/hitdetect.js';\nimport { apply as applyTransform, create as createTransform, multiply, reset as resetTransform, scale, scale as scaleTransform, translate as translateTransform, } from '../../transform.js';\nimport { boundingExtent, buffer, containsExtent, equals, getIntersection, getTopLeft, intersects, } from '../../extent.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature, } from '../vector.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\nimport { wrapX } from '../../coordinate.js';\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar IMAGE_REPLAYS = {\n    'image': [\n        ReplayType.POLYGON,\n        ReplayType.CIRCLE,\n        ReplayType.LINE_STRING,\n        ReplayType.IMAGE,\n        ReplayType.TEXT,\n    ],\n    'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING],\n    'vector': [],\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar VECTOR_REPLAYS = {\n    'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n    'vector': [\n        ReplayType.POLYGON,\n        ReplayType.CIRCLE,\n        ReplayType.LINE_STRING,\n        ReplayType.IMAGE,\n        ReplayType.TEXT,\n        ReplayType.DEFAULT,\n    ],\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nvar CanvasVectorTileLayerRenderer = /** @class */ (function (_super) {\n    __extends(CanvasVectorTileLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n     */\n    function CanvasVectorTileLayerRenderer(layer) {\n        var _this = _super.call(this, layer) || this;\n        /** @private */\n        _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.dirty_ = false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.renderedLayerRevision_;\n        /**\n         * @private\n         * @type {import(\"../../transform\").Transform}\n         */\n        _this.renderedPixelToCoordinateTransform_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.renderedRotation_;\n        /**\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        _this.tmpTransform_ = createTransform();\n        return _this;\n    }\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection\").default} projection Projection.\n     * @return {boolean|undefined} Tile needs to be rendered.\n     */\n    CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection) {\n        var render;\n        var state = tile.getState();\n        if (state === TileState.LOADED || state === TileState.ERROR) {\n            this.updateExecutorGroup_(tile, pixelRatio, projection);\n            if (this.tileImageNeedsRender_(tile)) {\n                render = true;\n            }\n        }\n        return render;\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {!import(\"../../Tile.js\").default} Tile.\n     */\n    CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n        var pixelRatio = frameState.pixelRatio;\n        var viewState = frameState.viewState;\n        var resolution = viewState.resolution;\n        var projection = viewState.projection;\n        var layer = this.getLayer();\n        var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);\n        var viewHints = frameState.viewHints;\n        var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n        if (hifi || !tile.wantedResolution) {\n            tile.wantedResolution = resolution;\n        }\n        var render = this.prepareTile(tile, pixelRatio, projection);\n        if (render &&\n            (hifi || Date.now() - frameState.time < 8) &&\n            layer.getRenderMode() !== VectorTileRenderType.VECTOR) {\n            this.renderTileImage_(tile, frameState);\n        }\n        return _super.prototype.getTile.call(this, z, x, y, frameState);\n    };\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @return {boolean} Tile is drawable.\n     */\n    CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n        var layer = this.getLayer();\n        return (_super.prototype.isDrawableTile.call(this, tile) &&\n            (layer.getRenderMode() === VectorTileRenderType.VECTOR\n                ? getUid(layer) in tile.executorGroups\n                : tile.hasContext(layer)));\n    };\n    /**\n     * @inheritDoc\n     */\n    CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {\n        return tile.getImage(this.getLayer());\n    };\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n        var layerRevision = this.getLayer().getRevision();\n        if (this.renderedLayerRevision_ != layerRevision) {\n            this.renderedTiles.length = 0;\n        }\n        this.renderedLayerRevision_ = layerRevision;\n        return _super.prototype.prepareFrame.call(this, frameState);\n    };\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n     * @private\n     */\n    CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {\n        var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n        var revision = layer.getRevision();\n        var renderOrder = layer.getRenderOrder() || null;\n        var resolution = tile.wantedResolution;\n        var builderState = tile.getReplayState(layer);\n        if (!builderState.dirty &&\n            builderState.renderedResolution === resolution &&\n            builderState.renderedRevision == revision &&\n            builderState.renderedRenderOrder == renderOrder) {\n            return;\n        }\n        var source = layer.getSource();\n        var declutter = layer.getDeclutter();\n        var sourceTileGrid = source.getTileGrid();\n        var tileGrid = source.getTileGridForProjection(projection);\n        var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n        var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n        var layerUid = getUid(layer);\n        delete tile.hitDetectionImageData[layerUid];\n        tile.executorGroups[layerUid] = [];\n        if (declutter) {\n            tile.declutterExecutorGroups[layerUid] = [];\n        }\n        var _loop_1 = function (t, tt) {\n            var sourceTile = sourceTiles[t];\n            if (sourceTile.getState() != TileState.LOADED) {\n                return \"continue\";\n            }\n            var sourceTileCoord = sourceTile.tileCoord;\n            var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n            var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n            var builderExtent = buffer(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);\n            var bufferedExtent = equals(sourceTileExtent, sharedExtent)\n                ? null\n                : builderExtent;\n            builderState.dirty = false;\n            var builderGroup = new CanvasBuilderGroup(0, builderExtent, resolution, pixelRatio);\n            var declutterBuilderGroup = declutter\n                ? new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio)\n                : undefined;\n            var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n            /**\n             * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n             * @this {CanvasVectorTileLayerRenderer}\n             */\n            var render = function (feature) {\n                var styles;\n                var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n                if (styleFunction) {\n                    styles = styleFunction(feature, resolution);\n                }\n                if (styles) {\n                    var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);\n                    this.dirty_ = this.dirty_ || dirty;\n                    builderState.dirty = builderState.dirty || dirty;\n                }\n            };\n            var features = sourceTile.getFeatures();\n            if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n                features.sort(renderOrder);\n            }\n            for (var i = 0, ii = features.length; i < ii; ++i) {\n                var feature = features[i];\n                if (!bufferedExtent ||\n                    intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n                    render.call(this_1, feature);\n                }\n            }\n            var executorGroupInstructions = builderGroup.finish();\n            // no need to clip when the render tile is covered by a single source tile\n            var replayExtent = layer.getRenderMode() !== VectorTileRenderType.VECTOR &&\n                declutter &&\n                sourceTiles.length === 1\n                ? null\n                : sharedExtent;\n            var renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n            tile.executorGroups[layerUid].push(renderingReplayGroup);\n            if (declutterBuilderGroup) {\n                var declutterExecutorGroup = new CanvasExecutorGroup(null, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());\n                tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);\n            }\n        };\n        var this_1 = this;\n        for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {\n            _loop_1(t, tt);\n        }\n        builderState.renderedRevision = revision;\n        builderState.renderedRenderOrder = renderOrder;\n        builderState.renderedResolution = resolution;\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        var resolution = frameState.viewState.resolution;\n        var rotation = frameState.viewState.rotation;\n        hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n        var layer = this.getLayer();\n        var source = layer.getSource();\n        var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n        var hitExtent = boundingExtent([coordinate]);\n        buffer(hitExtent, resolution * hitTolerance, hitExtent);\n        /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n        var features = {};\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n         * @param {number} distanceSq The squared distance to the click position.\n         * @return {T|undefined} Callback result.\n         */\n        var featureCallback = function (feature, geometry, distanceSq) {\n            var key = feature.getId();\n            if (key === undefined) {\n                key = getUid(feature);\n            }\n            var match = features[key];\n            if (!match) {\n                if (distanceSq === 0) {\n                    features[key] = true;\n                    return callback(feature, layer, geometry);\n                }\n                matches.push((features[key] = {\n                    feature: feature,\n                    layer: layer,\n                    geometry: geometry,\n                    distanceSq: distanceSq,\n                    callback: callback,\n                }));\n            }\n            else if (match !== true && distanceSq < match.distanceSq) {\n                if (distanceSq === 0) {\n                    features[key] = true;\n                    matches.splice(matches.lastIndexOf(match), 1);\n                    return callback(feature, layer, geometry);\n                }\n                match.geometry = geometry;\n                match.distanceSq = distanceSq;\n            }\n            return undefined;\n        };\n        var renderedTiles = \n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (this.renderedTiles);\n        var found;\n        var _loop_2 = function (i, ii) {\n            var tile = renderedTiles[i];\n            var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n            if (!intersects(tileExtent, hitExtent)) {\n                return \"continue\";\n            }\n            var layerUid = getUid(layer);\n            var executorGroups = [tile.executorGroups[layerUid]];\n            var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];\n            if (declutterExecutorGroups) {\n                executorGroups.push(declutterExecutorGroups);\n            }\n            executorGroups.some(function (executorGroups) {\n                var declutteredFeatures = executorGroups === declutterExecutorGroups\n                    ? frameState.declutterTree.all().map(function (item) { return item.value; })\n                    : null;\n                for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n                    var executorGroup = executorGroups[t];\n                    found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);\n                    if (found) {\n                        return true;\n                    }\n                }\n            });\n        };\n        for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n            _loop_2(i, ii);\n        }\n        return found;\n    };\n    /**\n     * Asynchronous layer level hit detection.\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @return {Promise<Array<import(\"../../Feature\").default>>} Promise that resolves with an array of features.\n     */\n    CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {\n        return new Promise(function (resolve, reject) {\n            var layer = \n            /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n            var layerUid = getUid(layer);\n            var source = layer.getSource();\n            var projection = this.renderedProjection;\n            var projectionExtent = projection.getExtent();\n            var resolution = this.renderedResolution;\n            var tileGrid = source.getTileGridForProjection(projection);\n            var coordinate = applyTransform(this.renderedPixelToCoordinateTransform_, pixel.slice());\n            var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n            var tile;\n            for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n                if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {\n                    tile = this.renderedTiles[i];\n                    if (tile.getState() === TileState.LOADED) {\n                        var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);\n                        if (source.getWrapX() &&\n                            projection.canWrapX() &&\n                            !containsExtent(projectionExtent, extent_1)) {\n                            wrapX(coordinate, projection);\n                        }\n                        break;\n                    }\n                    tile = undefined;\n                }\n            }\n            if (!tile || tile.loadingSourceTiles > 0) {\n                resolve([]);\n                return;\n            }\n            var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n            var corner = getTopLeft(extent);\n            var tilePixel = [\n                (coordinate[0] - corner[0]) / resolution,\n                (corner[1] - coordinate[1]) / resolution,\n            ];\n            var features = tile\n                .getSourceTiles()\n                .reduce(function (accumulator, sourceTile) {\n                return accumulator.concat(sourceTile.getFeatures());\n            }, []);\n            var hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n            if (!hitDetectionImageData && !this.animatingOrInteracting_) {\n                var tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));\n                var rotation = this.renderedRotation_;\n                var transforms = [\n                    this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0),\n                ];\n                hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);\n                tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n            }\n            resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n        }.bind(this));\n    };\n    /**\n     * Perform action necessary to get the layer rendered after new fonts have loaded\n     */\n    CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {\n        var layer = this.getLayer();\n        if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n            layer.changed();\n        }\n    };\n    /**\n     * Handle changes in image style state.\n     * @param {import(\"../../events/Event.js\").default} event Image style change event.\n     * @private\n     */\n    CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {\n        this.renderIfReadyAndVisible();\n    };\n    /**\n     * Render declutter items for this layer\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     */\n    CanvasVectorTileLayerRenderer.prototype.renderDeclutter = function (frameState) {\n        var context = this.context;\n        var alpha = context.globalAlpha;\n        context.globalAlpha = this.getLayer().getOpacity();\n        var viewHints = frameState.viewHints;\n        var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n        var tiles = \n        /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (this.renderedTiles);\n        for (var i = 0, ii = tiles.length; i < ii; ++i) {\n            var tile = tiles[i];\n            var declutterExecutorGroups = tile.declutterExecutorGroups[getUid(this.getLayer())];\n            if (declutterExecutorGroups) {\n                for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {\n                    declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);\n                }\n            }\n        }\n        context.globalAlpha = alpha;\n    };\n    CanvasVectorTileLayerRenderer.prototype.getTileRenderTransform = function (tile, frameState) {\n        var pixelRatio = frameState.pixelRatio;\n        var viewState = frameState.viewState;\n        var center = viewState.center;\n        var resolution = viewState.resolution;\n        var rotation = viewState.rotation;\n        var size = frameState.size;\n        var width = Math.round(size[0] * pixelRatio);\n        var height = Math.round(size[1] * pixelRatio);\n        var source = this.getLayer().getSource();\n        var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n        var tileCoord = tile.tileCoord;\n        var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n        var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n        var transform = multiply(scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n        return transform;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {HTMLElement} target Target that may be used to render content to.\n     * @return {HTMLElement} The rendered element.\n     */\n    CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n        var viewHints = frameState.viewHints;\n        var hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n        _super.prototype.renderFrame.call(this, frameState, target);\n        this.renderedPixelToCoordinateTransform_ =\n            frameState.pixelToCoordinateTransform.slice();\n        this.renderedRotation_ = frameState.viewState.rotation;\n        var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n        var renderMode = layer.getRenderMode();\n        var context = this.context;\n        var alpha = context.globalAlpha;\n        context.globalAlpha = layer.getOpacity();\n        var replayTypes = VECTOR_REPLAYS[renderMode];\n        var viewState = frameState.viewState;\n        var rotation = viewState.rotation;\n        var tiles = this.renderedTiles;\n        var clips = [];\n        var clipZs = [];\n        for (var i = tiles.length - 1; i >= 0; --i) {\n            var tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (tiles[i]);\n            var transform = this.getTileRenderTransform(tile, frameState);\n            var executorGroups = tile.executorGroups[getUid(layer)];\n            var clipped = false;\n            for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n                var executorGroup = executorGroups[t];\n                if (!executorGroup.hasExecutors(replayTypes)) {\n                    // sourceTile has no instructions of the types we want to render\n                    continue;\n                }\n                var currentZ = tile.tileCoord[0];\n                var currentClip = void 0;\n                if (!clipped) {\n                    currentClip = executorGroup.getClipCoords(transform);\n                    if (currentClip) {\n                        context.save();\n                        // Create a clip mask for regions in this low resolution tile that are\n                        // already filled by a higher resolution tile\n                        for (var j = 0, jj = clips.length; j < jj; ++j) {\n                            var clip = clips[j];\n                            if (currentZ < clipZs[j]) {\n                                context.beginPath();\n                                // counter-clockwise (outer ring) for current tile\n                                context.moveTo(currentClip[0], currentClip[1]);\n                                context.lineTo(currentClip[2], currentClip[3]);\n                                context.lineTo(currentClip[4], currentClip[5]);\n                                context.lineTo(currentClip[6], currentClip[7]);\n                                // clockwise (inner ring) for higher resolution tile\n                                context.moveTo(clip[6], clip[7]);\n                                context.lineTo(clip[4], clip[5]);\n                                context.lineTo(clip[2], clip[3]);\n                                context.lineTo(clip[0], clip[1]);\n                                context.clip();\n                            }\n                        }\n                    }\n                }\n                executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);\n                if (!clipped && currentClip) {\n                    context.restore();\n                    clips.push(currentClip);\n                    clipZs.push(currentZ);\n                    clipped = true;\n                }\n            }\n        }\n        context.globalAlpha = alpha;\n        return this.container;\n    };\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n     * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n     * @param {import(\"../../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder group for decluttering.\n     * @return {boolean} `true` if an image is loading.\n     */\n    CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {\n        if (!styles) {\n            return false;\n        }\n        var loading = false;\n        if (Array.isArray(styles)) {\n            for (var i = 0, ii = styles.length; i < ii; ++i) {\n                loading =\n                    renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup) || loading;\n            }\n        }\n        else {\n            loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup);\n        }\n        return loading;\n    };\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @return {boolean} A new tile image was rendered.\n     * @private\n     */\n    CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile) {\n        var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n        if (layer.getRenderMode() === VectorTileRenderType.VECTOR) {\n            return false;\n        }\n        var replayState = tile.getReplayState(layer);\n        var revision = layer.getRevision();\n        var resolution = tile.wantedResolution;\n        return (replayState.renderedTileResolution !== resolution ||\n            replayState.renderedTileRevision !== revision);\n    };\n    /**\n     * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {\n        var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (this.getLayer());\n        var replayState = tile.getReplayState(layer);\n        var revision = layer.getRevision();\n        var executorGroups = tile.executorGroups[getUid(layer)];\n        replayState.renderedTileRevision = revision;\n        var tileCoord = tile.wrappedTileCoord;\n        var z = tileCoord[0];\n        var source = layer.getSource();\n        var pixelRatio = frameState.pixelRatio;\n        var viewState = frameState.viewState;\n        var projection = viewState.projection;\n        var tileGrid = source.getTileGridForProjection(projection);\n        var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n        var renderPixelRatio = (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n        var resolution = tileGrid.getResolution(z);\n        var context = tile.getContext(layer);\n        // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n        pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));\n        var size = source.getTilePixelSize(z, pixelRatio, projection);\n        context.canvas.width = size[0];\n        context.canvas.height = size[1];\n        var renderScale = pixelRatio / renderPixelRatio;\n        if (renderScale !== 1) {\n            var canvasTransform = resetTransform(this.tmpTransform_);\n            scaleTransform(canvasTransform, renderScale, renderScale);\n            context.setTransform.apply(context, canvasTransform);\n        }\n        var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n        var pixelScale = renderPixelRatio / resolution;\n        var transform = resetTransform(this.tmpTransform_);\n        scaleTransform(transform, pixelScale, -pixelScale);\n        translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n        for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n            var executorGroup = executorGroups[i];\n            executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n        }\n        replayState.renderedTileResolution = tile.wantedResolution;\n    };\n    return CanvasVectorTileLayerRenderer;\n}(CanvasTileLayerRenderer));\nexport default CanvasVectorTileLayerRenderer;\n//# sourceMappingURL=VectorTileLayer.js.map"]},"metadata":{},"sourceType":"module"}
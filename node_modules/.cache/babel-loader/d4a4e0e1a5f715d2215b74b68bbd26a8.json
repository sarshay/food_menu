{"ast":null,"code":"import _ol_ from './index.js';\nimport _ol_TileState_ from './tilestate.js';\nimport _ol_easing_ from './easing.js';\nimport _ol_events_EventTarget_ from './events/eventtarget.js';\nimport _ol_events_EventType_ from './events/eventtype.js';\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @constructor\n * @abstract\n * @extends {ol.events.EventTarget}\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @param {ol.TileState} state State.\n * @param {olx.TileOptions=} opt_options Tile options.\n */\n\nvar _ol_Tile_ = function (tileCoord, state, opt_options) {\n  _ol_events_EventTarget_.call(this);\n\n  var options = opt_options ? opt_options : {};\n  /**\n   * @type {ol.TileCoord}\n   */\n\n  this.tileCoord = tileCoord;\n  /**\n   * @protected\n   * @type {ol.TileState}\n   */\n\n  this.state = state;\n  /**\n   * An \"interim\" tile for this tile. The interim tile may be used while this\n   * one is loading, for \"smooth\" transitions when changing params/dimensions\n   * on the source.\n   * @type {ol.Tile}\n   */\n\n  this.interimTile = null;\n  /**\n   * A key assigned to the tile. This is used by the tile source to determine\n   * if this tile can effectively be used, or if a new tile should be created\n   * and this one be used as an interim tile for this new tile.\n   * @type {string}\n   */\n\n  this.key = '';\n  /**\n   * The duration for the opacity transition.\n   * @type {number}\n   */\n\n  this.transition_ = options.transition === undefined ? 250 : options.transition;\n  /**\n   * Lookup of start times for rendering transitions.  If the start time is\n   * equal to -1, the transition is complete.\n   * @type {Object.<number, number>}\n   */\n\n  this.transitionStarts_ = {};\n};\n\n_ol_.inherits(_ol_Tile_, _ol_events_EventTarget_);\n/**\n * @protected\n */\n\n\n_ol_Tile_.prototype.changed = function () {\n  this.dispatchEvent(_ol_events_EventType_.CHANGE);\n};\n/**\n * @return {string} Key.\n */\n\n\n_ol_Tile_.prototype.getKey = function () {\n  return this.key + '/' + this.tileCoord;\n};\n/**\n * Get the interim tile most suitable for rendering using the chain of interim\n * tiles. This corresponds to the  most recent tile that has been loaded, if no\n * such tile exists, the original tile is returned.\n * @return {!ol.Tile} Best tile for rendering.\n */\n\n\n_ol_Tile_.prototype.getInterimTile = function () {\n  if (!this.interimTile) {\n    //empty chain\n    return this;\n  }\n\n  var tile = this.interimTile; // find the first loaded tile and return it. Since the chain is sorted in\n  // decreasing order of creation time, there is no need to search the remainder\n  // of the list (all those tiles correspond to older requests and will be\n  // cleaned up by refreshInterimChain)\n\n  do {\n    if (tile.getState() == _ol_TileState_.LOADED) {\n      return tile;\n    }\n\n    tile = tile.interimTile;\n  } while (tile); // we can not find a better tile\n\n\n  return this;\n};\n/**\n * Goes through the chain of interim tiles and discards sections of the chain\n * that are no longer relevant.\n */\n\n\n_ol_Tile_.prototype.refreshInterimChain = function () {\n  if (!this.interimTile) {\n    return;\n  }\n\n  var tile = this.interimTile;\n  var prev = this;\n\n  do {\n    if (tile.getState() == _ol_TileState_.LOADED) {\n      //we have a loaded tile, we can discard the rest of the list\n      //we would could abort any LOADING tile request\n      //older than this tile (i.e. any LOADING tile following this entry in the chain)\n      tile.interimTile = null;\n      break;\n    } else if (tile.getState() == _ol_TileState_.LOADING) {\n      //keep this LOADING tile any loaded tiles later in the chain are\n      //older than this tile, so we're still interested in the request\n      prev = tile;\n    } else if (tile.getState() == _ol_TileState_.IDLE) {\n      //the head of the list is the most current tile, we don't need\n      //to start any other requests for this chain\n      prev.interimTile = tile.interimTile;\n    } else {\n      prev = tile;\n    }\n\n    tile = prev.interimTile;\n  } while (tile);\n};\n/**\n * Get the tile coordinate for this tile.\n * @return {ol.TileCoord} The tile coordinate.\n * @api\n */\n\n\n_ol_Tile_.prototype.getTileCoord = function () {\n  return this.tileCoord;\n};\n/**\n * @return {ol.TileState} State.\n */\n\n\n_ol_Tile_.prototype.getState = function () {\n  return this.state;\n};\n/**\n * @param {ol.TileState} state State.\n */\n\n\n_ol_Tile_.prototype.setState = function (state) {\n  this.state = state;\n  this.changed();\n};\n/**\n * Load the image or retry if loading previously failed.\n * Loading is taken care of by the tile queue, and calling this method is\n * only needed for preloading or for reloading in case of an error.\n * @abstract\n * @api\n */\n\n\n_ol_Tile_.prototype.load = function () {};\n/**\n * Get the alpha value for rendering.\n * @param {number} id An id for the renderer.\n * @param {number} time The render frame time.\n * @return {number} A number between 0 and 1.\n */\n\n\n_ol_Tile_.prototype.getAlpha = function (id, time) {\n  if (!this.transition_) {\n    return 1;\n  }\n\n  var start = this.transitionStarts_[id];\n\n  if (!start) {\n    start = time;\n    this.transitionStarts_[id] = start;\n  } else if (start === -1) {\n    return 1;\n  }\n\n  var delta = time - start + 1000 / 60; // avoid rendering at 0\n\n  if (delta >= this.transition_) {\n    return 1;\n  }\n\n  return _ol_easing_.easeIn(delta / this.transition_);\n};\n/**\n * Determine if a tile is in an alpha transition.  A tile is considered in\n * transition if tile.getAlpha() has not yet been called or has been called\n * and returned 1.\n * @param {number} id An id for the renderer.\n * @return {boolean} The tile is in transition.\n */\n\n\n_ol_Tile_.prototype.inTransition = function (id) {\n  if (!this.transition_) {\n    return false;\n  }\n\n  return this.transitionStarts_[id] !== -1;\n};\n/**\n * Mark a transition as complete.\n * @param {number} id An id for the renderer.\n */\n\n\n_ol_Tile_.prototype.endTransition = function (id) {\n  if (this.transition_) {\n    this.transitionStarts_[id] = -1;\n  }\n};\n\nexport default _ol_Tile_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/tile.js"],"names":["_ol_","_ol_TileState_","_ol_easing_","_ol_events_EventTarget_","_ol_events_EventType_","_ol_Tile_","tileCoord","state","opt_options","call","options","interimTile","key","transition_","transition","undefined","transitionStarts_","inherits","prototype","changed","dispatchEvent","CHANGE","getKey","getInterimTile","tile","getState","LOADED","refreshInterimChain","prev","LOADING","IDLE","getTileCoord","setState","load","getAlpha","id","time","start","delta","easeIn","inTransition","endTransition"],"mappings":"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","sourcesContent":["import _ol_ from './index.js';\nimport _ol_TileState_ from './tilestate.js';\nimport _ol_easing_ from './easing.js';\nimport _ol_events_EventTarget_ from './events/eventtarget.js';\nimport _ol_events_EventType_ from './events/eventtype.js';\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @constructor\n * @abstract\n * @extends {ol.events.EventTarget}\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @param {ol.TileState} state State.\n * @param {olx.TileOptions=} opt_options Tile options.\n */\nvar _ol_Tile_ = function(tileCoord, state, opt_options) {\n  _ol_events_EventTarget_.call(this);\n\n  var options = opt_options ? opt_options : {};\n\n  /**\n   * @type {ol.TileCoord}\n   */\n  this.tileCoord = tileCoord;\n\n  /**\n   * @protected\n   * @type {ol.TileState}\n   */\n  this.state = state;\n\n  /**\n   * An \"interim\" tile for this tile. The interim tile may be used while this\n   * one is loading, for \"smooth\" transitions when changing params/dimensions\n   * on the source.\n   * @type {ol.Tile}\n   */\n  this.interimTile = null;\n\n  /**\n   * A key assigned to the tile. This is used by the tile source to determine\n   * if this tile can effectively be used, or if a new tile should be created\n   * and this one be used as an interim tile for this new tile.\n   * @type {string}\n   */\n  this.key = '';\n\n  /**\n   * The duration for the opacity transition.\n   * @type {number}\n   */\n  this.transition_ = options.transition === undefined ?\n    250 : options.transition;\n\n  /**\n   * Lookup of start times for rendering transitions.  If the start time is\n   * equal to -1, the transition is complete.\n   * @type {Object.<number, number>}\n   */\n  this.transitionStarts_ = {};\n\n};\n\n_ol_.inherits(_ol_Tile_, _ol_events_EventTarget_);\n\n\n/**\n * @protected\n */\n_ol_Tile_.prototype.changed = function() {\n  this.dispatchEvent(_ol_events_EventType_.CHANGE);\n};\n\n\n/**\n * @return {string} Key.\n */\n_ol_Tile_.prototype.getKey = function() {\n  return this.key + '/' + this.tileCoord;\n};\n\n/**\n * Get the interim tile most suitable for rendering using the chain of interim\n * tiles. This corresponds to the  most recent tile that has been loaded, if no\n * such tile exists, the original tile is returned.\n * @return {!ol.Tile} Best tile for rendering.\n */\n_ol_Tile_.prototype.getInterimTile = function() {\n  if (!this.interimTile) {\n    //empty chain\n    return this;\n  }\n  var tile = this.interimTile;\n\n  // find the first loaded tile and return it. Since the chain is sorted in\n  // decreasing order of creation time, there is no need to search the remainder\n  // of the list (all those tiles correspond to older requests and will be\n  // cleaned up by refreshInterimChain)\n  do {\n    if (tile.getState() == _ol_TileState_.LOADED) {\n      return tile;\n    }\n    tile = tile.interimTile;\n  } while (tile);\n\n  // we can not find a better tile\n  return this;\n};\n\n/**\n * Goes through the chain of interim tiles and discards sections of the chain\n * that are no longer relevant.\n */\n_ol_Tile_.prototype.refreshInterimChain = function() {\n  if (!this.interimTile) {\n    return;\n  }\n\n  var tile = this.interimTile;\n  var prev = this;\n\n  do {\n    if (tile.getState() == _ol_TileState_.LOADED) {\n      //we have a loaded tile, we can discard the rest of the list\n      //we would could abort any LOADING tile request\n      //older than this tile (i.e. any LOADING tile following this entry in the chain)\n      tile.interimTile = null;\n      break;\n    } else if (tile.getState() == _ol_TileState_.LOADING) {\n      //keep this LOADING tile any loaded tiles later in the chain are\n      //older than this tile, so we're still interested in the request\n      prev = tile;\n    } else if (tile.getState() == _ol_TileState_.IDLE) {\n      //the head of the list is the most current tile, we don't need\n      //to start any other requests for this chain\n      prev.interimTile = tile.interimTile;\n    } else {\n      prev = tile;\n    }\n    tile = prev.interimTile;\n  } while (tile);\n};\n\n/**\n * Get the tile coordinate for this tile.\n * @return {ol.TileCoord} The tile coordinate.\n * @api\n */\n_ol_Tile_.prototype.getTileCoord = function() {\n  return this.tileCoord;\n};\n\n\n/**\n * @return {ol.TileState} State.\n */\n_ol_Tile_.prototype.getState = function() {\n  return this.state;\n};\n\n/**\n * @param {ol.TileState} state State.\n */\n_ol_Tile_.prototype.setState = function(state) {\n  this.state = state;\n  this.changed();\n};\n\n/**\n * Load the image or retry if loading previously failed.\n * Loading is taken care of by the tile queue, and calling this method is\n * only needed for preloading or for reloading in case of an error.\n * @abstract\n * @api\n */\n_ol_Tile_.prototype.load = function() {};\n\n/**\n * Get the alpha value for rendering.\n * @param {number} id An id for the renderer.\n * @param {number} time The render frame time.\n * @return {number} A number between 0 and 1.\n */\n_ol_Tile_.prototype.getAlpha = function(id, time) {\n  if (!this.transition_) {\n    return 1;\n  }\n\n  var start = this.transitionStarts_[id];\n  if (!start) {\n    start = time;\n    this.transitionStarts_[id] = start;\n  } else if (start === -1) {\n    return 1;\n  }\n\n  var delta = time - start + (1000 / 60); // avoid rendering at 0\n  if (delta >= this.transition_) {\n    return 1;\n  }\n  return _ol_easing_.easeIn(delta / this.transition_);\n};\n\n/**\n * Determine if a tile is in an alpha transition.  A tile is considered in\n * transition if tile.getAlpha() has not yet been called or has been called\n * and returned 1.\n * @param {number} id An id for the renderer.\n * @return {boolean} The tile is in transition.\n */\n_ol_Tile_.prototype.inTransition = function(id) {\n  if (!this.transition_) {\n    return false;\n  }\n  return this.transitionStarts_[id] !== -1;\n};\n\n/**\n * Mark a transition as complete.\n * @param {number} id An id for the renderer.\n */\n_ol_Tile_.prototype.endTransition = function(id) {\n  if (this.transition_) {\n    this.transitionStarts_[id] = -1;\n  }\n};\nexport default _ol_Tile_;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/layer/WebGLTile\n */\n\n\nimport BaseTileLayer from './BaseTile.js';\nimport WebGLTileLayerRenderer, { Attributes, Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable } from '../style/expressions.js';\nimport { assign } from '../obj.js';\n/**\n * @typedef {Object} Style\n * Translates tile data to rendered pixels.\n *\n * @property {Object<string, number>} [variables] Style variables.  Each variable must hold a number.  These\n * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`\n * {@link import(\"../style/expressions.js\").ExpressionValue expressions}, using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [color] An expression applied to color values.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [brightness=0] Value used to decrease or increase\n * the layer brightness.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [contrast=0] Value used to decrease or increase\n * the layer contrast.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [exposure=0] Value used to decrease or increase\n * the layer exposure.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [saturation=0] Value used to decrease or increase\n * the layer saturation.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.\n * Values range from 0 to infinity.\n */\n\n/**\n * @typedef {Object} Options\n * @property {Style} [style] Style to apply to the layer.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {import(\"../source/Tile.js\").default} [source] Source for this layer.\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n\n/**\n * @typedef {Object} ParsedStyle\n * @property {string} vertexShader The vertex shader.\n * @property {string} fragmentShader The fragment shader.\n * @property {Object<string,import(\"../webgl/Helper.js\").UniformValue>} uniforms Uniform definitions.\n */\n\n/**\n * @param {Style} style The layer style.\n * @param {number} [bandCount] The number of bands.\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\n */\n\nfunction parseStyle(style, bandCount) {\n  var vertexShader = \"\\n    attribute vec2 \" + Attributes.TEXTURE_COORD + \";\\n    uniform mat4 \" + Uniforms.TILE_TRANSFORM + \";\\n    uniform float \" + Uniforms.DEPTH + \";\\n\\n    varying vec2 v_textureCoord;\\n\\n    void main() {\\n      v_textureCoord = \" + Attributes.TEXTURE_COORD + \";\\n      gl_Position = \" + Uniforms.TILE_TRANSFORM + \" * vec4(\" + Attributes.TEXTURE_COORD + \", \" + Uniforms.DEPTH + \", 1.0);\\n    }\\n  \";\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n\n  var context = {\n    inFragmentShader: true,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {},\n    bandCount: bandCount\n  };\n  var pipeline = [];\n\n  if (style.color !== undefined) {\n    var color = expressionToGlsl(context, style.color, ValueTypes.COLOR);\n    pipeline.push(\"color = \" + color + \";\");\n  }\n\n  if (style.contrast !== undefined) {\n    var contrast = expressionToGlsl(context, style.contrast, ValueTypes.NUMBER);\n    pipeline.push(\"color.rgb = clamp((\" + contrast + \" + 1.0) * color.rgb - (\" + contrast + \" / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\");\n  }\n\n  if (style.exposure !== undefined) {\n    var exposure = expressionToGlsl(context, style.exposure, ValueTypes.NUMBER);\n    pipeline.push(\"color.rgb = clamp((\" + exposure + \" + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\");\n  }\n\n  if (style.saturation !== undefined) {\n    var saturation = expressionToGlsl(context, style.saturation, ValueTypes.NUMBER);\n    pipeline.push(\"\\n      float saturation = \" + saturation + \" + 1.0;\\n      float sr = (1.0 - saturation) * 0.2126;\\n      float sg = (1.0 - saturation) * 0.7152;\\n      float sb = (1.0 - saturation) * 0.0722;\\n      mat3 saturationMatrix = mat3(\\n        sr + saturation, sr, sr,\\n        sg, sg + saturation, sg,\\n        sb, sb, sb + saturation\\n      );\\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\\n    \");\n  }\n\n  if (style.gamma !== undefined) {\n    var gamma = expressionToGlsl(context, style.gamma, ValueTypes.NUMBER);\n    pipeline.push(\"color.rgb = pow(color.rgb, vec3(1.0 / \" + gamma + \"));\");\n  }\n\n  if (style.brightness !== undefined) {\n    var brightness = expressionToGlsl(context, style.brightness, ValueTypes.NUMBER);\n    pipeline.push(\"color.rgb = clamp(color.rgb + \" + brightness + \", vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\");\n  }\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n\n\n  var uniforms = {};\n  var numVariables = context.variables.length;\n\n  if (numVariables > 1 && !style.variables) {\n    throw new Error(\"Missing variables in style (expected \" + context.variables + \")\");\n  }\n\n  var _loop_1 = function (i) {\n    var variableName = context.variables[i];\n\n    if (!(variableName in style.variables)) {\n      throw new Error(\"Missing '\" + variableName + \"' in style variables\");\n    }\n\n    var uniformName = uniformNameForVariable(variableName);\n\n    uniforms[uniformName] = function () {\n      var value = style.variables[variableName];\n\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(context, value);\n      }\n\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  };\n\n  for (var i = 0; i < numVariables; ++i) {\n    _loop_1(i);\n  }\n\n  var uniformDeclarations = Object.keys(uniforms).map(function (name) {\n    return \"uniform float \" + name + \";\";\n  });\n  var textureCount = Math.ceil(bandCount / 4);\n  var colorAssignments = new Array(textureCount);\n\n  for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n    var uniformName = Uniforms.TILE_TEXTURE_PREFIX + textureIndex;\n    uniformDeclarations.push(\"uniform sampler2D \" + uniformName + \";\");\n    colorAssignments[textureIndex] = \"vec4 color\" + textureIndex + \" = texture2D(\" + uniformName + \", v_textureCoord);\";\n  }\n\n  var fragmentShader = \"\\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\\n    precision highp float;\\n    #else\\n    precision mediump float;\\n    #endif\\n\\n    varying vec2 v_textureCoord;\\n    uniform float \" + Uniforms.TRANSITION_ALPHA + \";\\n    uniform float \" + Uniforms.TEXTURE_PIXEL_WIDTH + \";\\n    uniform float \" + Uniforms.TEXTURE_PIXEL_HEIGHT + \";\\n    uniform float \" + Uniforms.RESOLUTION + \";\\n    uniform float \" + Uniforms.ZOOM + \";\\n\\n    \" + uniformDeclarations.join('\\n') + \"\\n\\n    void main() {\\n      \" + colorAssignments.join('\\n') + \"\\n\\n      vec4 color = color0;\\n\\n      \" + pipeline.join('\\n') + \"\\n\\n      if (color.a == 0.0) {\\n        discard;\\n      }\\n\\n      gl_FragColor = color;\\n      gl_FragColor.rgb *= gl_FragColor.a;\\n      gl_FragColor *= \" + Uniforms.TRANSITION_ALPHA + \";\\n    }\";\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    uniforms: uniforms\n  };\n}\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * **Important**: after removing a `WebGLTile` layer from your map, call `layer.dispose()`\n * to clean up underlying resources.\n *\n * @extends BaseTileLayer<import(\"../source/DataTile.js\").default|import(\"../source/TileImage.js\").default>\n * @api\n */\n\n\nvar WebGLTileLayer =\n/** @class */\nfunction (_super) {\n  __extends(WebGLTileLayer, _super);\n  /**\n   * @param {Options} opt_options Tile layer options.\n   */\n\n\n  function WebGLTileLayer(opt_options) {\n    var _this = this;\n\n    var options = opt_options ? assign({}, opt_options) : {};\n    var style = options.style || {};\n    delete options.style;\n    var cacheSize = options.cacheSize;\n    delete options.cacheSize;\n    _this = _super.call(this, options) || this;\n    /**\n     * @type {Style}\n     * @private\n     */\n\n    _this.style_ = style;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.cacheSize_ = cacheSize;\n    return _this;\n  }\n  /**\n   * Create a renderer for this layer.\n   * @return {import(\"../renderer/Layer.js\").default} A layer renderer.\n   * @protected\n   */\n\n\n  WebGLTileLayer.prototype.createRenderer = function () {\n    var source = this.getSource();\n    var parsedStyle = parseStyle(this.style_, 'bandCount' in source ? source.bandCount : 4);\n    this.styleVariables_ = this.style_.variables || {};\n    return new WebGLTileLayerRenderer(this, {\n      vertexShader: parsedStyle.vertexShader,\n      fragmentShader: parsedStyle.fragmentShader,\n      uniforms: parsedStyle.uniforms,\n      className: this.getClassName(),\n      cacheSize: this.cacheSize_\n    });\n  };\n  /**\n   * Update any variables used by the layer style and trigger a re-render.\n   * @param {Object<string, number>} variables Variables to update.\n   * @api\n   */\n\n\n  WebGLTileLayer.prototype.updateStyleVariables = function (variables) {\n    assign(this.styleVariables_, variables);\n    this.changed();\n  };\n\n  return WebGLTileLayer;\n}(BaseTileLayer);\n/**\n * Clean up underlying WebGL resources.\n * @function\n * @api\n */\n\n\nWebGLTileLayer.prototype.dispose;\nexport default WebGLTileLayer;","map":{"version":3,"sources":["../src/layer/WebGLTile.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/layer/WebGLTile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport WebGLTileLayerRenderer, { Attributes, Uniforms, } from '../renderer/webgl/TileLayer.js';\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable, } from '../style/expressions.js';\nimport { assign } from '../obj.js';\n/**\n * @typedef {Object} Style\n * Translates tile data to rendered pixels.\n *\n * @property {Object<string, number>} [variables] Style variables.  Each variable must hold a number.  These\n * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`\n * {@link import(\"../style/expressions.js\").ExpressionValue expressions}, using the `['var', 'varName']` operator.\n * To update style variables, use the {@link import(\"./WebGLTile.js\").default#updateStyleVariables} method.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [color] An expression applied to color values.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [brightness=0] Value used to decrease or increase\n * the layer brightness.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [contrast=0] Value used to decrease or increase\n * the layer contrast.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [exposure=0] Value used to decrease or increase\n * the layer exposure.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [saturation=0] Value used to decrease or increase\n * the layer saturation.  Values range from -1 to 1.\n * @property {import(\"../style/expressions.js\").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.\n * Values range from 0 to infinity.\n */\n/**\n * @typedef {Object} Options\n * @property {Style} [style] Style to apply to the layer.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {import(\"../source/Tile.js\").default} [source] Source for this layer.\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render\n * two zoom levels worth of tiles.\n */\n/**\n * @typedef {Object} ParsedStyle\n * @property {string} vertexShader The vertex shader.\n * @property {string} fragmentShader The fragment shader.\n * @property {Object<string,import(\"../webgl/Helper.js\").UniformValue>} uniforms Uniform definitions.\n */\n/**\n * @param {Style} style The layer style.\n * @param {number} [bandCount] The number of bands.\n * @return {ParsedStyle} Shaders and uniforms generated from the style.\n */\nfunction parseStyle(style, bandCount) {\n    var vertexShader = \"\\n    attribute vec2 \" + Attributes.TEXTURE_COORD + \";\\n    uniform mat4 \" + Uniforms.TILE_TRANSFORM + \";\\n    uniform float \" + Uniforms.DEPTH + \";\\n\\n    varying vec2 v_textureCoord;\\n\\n    void main() {\\n      v_textureCoord = \" + Attributes.TEXTURE_COORD + \";\\n      gl_Position = \" + Uniforms.TILE_TRANSFORM + \" * vec4(\" + Attributes.TEXTURE_COORD + \", \" + Uniforms.DEPTH + \", 1.0);\\n    }\\n  \";\n    /**\n     * @type {import(\"../style/expressions.js\").ParsingContext}\n     */\n    var context = {\n        inFragmentShader: true,\n        variables: [],\n        attributes: [],\n        stringLiteralsMap: {},\n        bandCount: bandCount,\n    };\n    var pipeline = [];\n    if (style.color !== undefined) {\n        var color = expressionToGlsl(context, style.color, ValueTypes.COLOR);\n        pipeline.push(\"color = \" + color + \";\");\n    }\n    if (style.contrast !== undefined) {\n        var contrast = expressionToGlsl(context, style.contrast, ValueTypes.NUMBER);\n        pipeline.push(\"color.rgb = clamp((\" + contrast + \" + 1.0) * color.rgb - (\" + contrast + \" / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\");\n    }\n    if (style.exposure !== undefined) {\n        var exposure = expressionToGlsl(context, style.exposure, ValueTypes.NUMBER);\n        pipeline.push(\"color.rgb = clamp((\" + exposure + \" + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\");\n    }\n    if (style.saturation !== undefined) {\n        var saturation = expressionToGlsl(context, style.saturation, ValueTypes.NUMBER);\n        pipeline.push(\"\\n      float saturation = \" + saturation + \" + 1.0;\\n      float sr = (1.0 - saturation) * 0.2126;\\n      float sg = (1.0 - saturation) * 0.7152;\\n      float sb = (1.0 - saturation) * 0.0722;\\n      mat3 saturationMatrix = mat3(\\n        sr + saturation, sr, sr,\\n        sg, sg + saturation, sg,\\n        sb, sb, sb + saturation\\n      );\\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\\n    \");\n    }\n    if (style.gamma !== undefined) {\n        var gamma = expressionToGlsl(context, style.gamma, ValueTypes.NUMBER);\n        pipeline.push(\"color.rgb = pow(color.rgb, vec3(1.0 / \" + gamma + \"));\");\n    }\n    if (style.brightness !== undefined) {\n        var brightness = expressionToGlsl(context, style.brightness, ValueTypes.NUMBER);\n        pipeline.push(\"color.rgb = clamp(color.rgb + \" + brightness + \", vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\");\n    }\n    /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n    var uniforms = {};\n    var numVariables = context.variables.length;\n    if (numVariables > 1 && !style.variables) {\n        throw new Error(\"Missing variables in style (expected \" + context.variables + \")\");\n    }\n    var _loop_1 = function (i) {\n        var variableName = context.variables[i];\n        if (!(variableName in style.variables)) {\n            throw new Error(\"Missing '\" + variableName + \"' in style variables\");\n        }\n        var uniformName = uniformNameForVariable(variableName);\n        uniforms[uniformName] = function () {\n            var value = style.variables[variableName];\n            if (typeof value === 'string') {\n                value = getStringNumberEquivalent(context, value);\n            }\n            return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        };\n    };\n    for (var i = 0; i < numVariables; ++i) {\n        _loop_1(i);\n    }\n    var uniformDeclarations = Object.keys(uniforms).map(function (name) {\n        return \"uniform float \" + name + \";\";\n    });\n    var textureCount = Math.ceil(bandCount / 4);\n    var colorAssignments = new Array(textureCount);\n    for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n        var uniformName = Uniforms.TILE_TEXTURE_PREFIX + textureIndex;\n        uniformDeclarations.push(\"uniform sampler2D \" + uniformName + \";\");\n        colorAssignments[textureIndex] = \"vec4 color\" + textureIndex + \" = texture2D(\" + uniformName + \", v_textureCoord);\";\n    }\n    var fragmentShader = \"\\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\\n    precision highp float;\\n    #else\\n    precision mediump float;\\n    #endif\\n\\n    varying vec2 v_textureCoord;\\n    uniform float \" + Uniforms.TRANSITION_ALPHA + \";\\n    uniform float \" + Uniforms.TEXTURE_PIXEL_WIDTH + \";\\n    uniform float \" + Uniforms.TEXTURE_PIXEL_HEIGHT + \";\\n    uniform float \" + Uniforms.RESOLUTION + \";\\n    uniform float \" + Uniforms.ZOOM + \";\\n\\n    \" + uniformDeclarations.join('\\n') + \"\\n\\n    void main() {\\n      \" + colorAssignments.join('\\n') + \"\\n\\n      vec4 color = color0;\\n\\n      \" + pipeline.join('\\n') + \"\\n\\n      if (color.a == 0.0) {\\n        discard;\\n      }\\n\\n      gl_FragColor = color;\\n      gl_FragColor.rgb *= gl_FragColor.a;\\n      gl_FragColor *= \" + Uniforms.TRANSITION_ALPHA + \";\\n    }\";\n    return {\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader,\n        uniforms: uniforms,\n    };\n}\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * **Important**: after removing a `WebGLTile` layer from your map, call `layer.dispose()`\n * to clean up underlying resources.\n *\n * @extends BaseTileLayer<import(\"../source/DataTile.js\").default|import(\"../source/TileImage.js\").default>\n * @api\n */\nvar WebGLTileLayer = /** @class */ (function (_super) {\n    __extends(WebGLTileLayer, _super);\n    /**\n     * @param {Options} opt_options Tile layer options.\n     */\n    function WebGLTileLayer(opt_options) {\n        var _this = this;\n        var options = opt_options ? assign({}, opt_options) : {};\n        var style = options.style || {};\n        delete options.style;\n        var cacheSize = options.cacheSize;\n        delete options.cacheSize;\n        _this = _super.call(this, options) || this;\n        /**\n         * @type {Style}\n         * @private\n         */\n        _this.style_ = style;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.cacheSize_ = cacheSize;\n        return _this;\n    }\n    /**\n     * Create a renderer for this layer.\n     * @return {import(\"../renderer/Layer.js\").default} A layer renderer.\n     * @protected\n     */\n    WebGLTileLayer.prototype.createRenderer = function () {\n        var source = this.getSource();\n        var parsedStyle = parseStyle(this.style_, 'bandCount' in source ? source.bandCount : 4);\n        this.styleVariables_ = this.style_.variables || {};\n        return new WebGLTileLayerRenderer(this, {\n            vertexShader: parsedStyle.vertexShader,\n            fragmentShader: parsedStyle.fragmentShader,\n            uniforms: parsedStyle.uniforms,\n            className: this.getClassName(),\n            cacheSize: this.cacheSize_,\n        });\n    };\n    /**\n     * Update any variables used by the layer style and trigger a re-render.\n     * @param {Object<string, number>} variables Variables to update.\n     * @api\n     */\n    WebGLTileLayer.prototype.updateStyleVariables = function (variables) {\n        assign(this.styleVariables_, variables);\n        this.changed();\n    };\n    return WebGLTileLayer;\n}(BaseTileLayer));\n/**\n * Clean up underlying WebGL resources.\n * @function\n * @api\n */\nWebGLTileLayer.prototype.dispose;\nexport default WebGLTileLayer;\n//# sourceMappingURL=WebGLTile.js.map"]},"metadata":{},"sourceType":"module"}
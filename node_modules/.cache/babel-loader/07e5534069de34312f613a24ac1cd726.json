{"ast":null,"code":"import _ol_TileRange_ from './tilerange.js';\nimport _ol_math_ from './math.js';\nimport _ol_tilegrid_ from './tilegrid.js';\n/**\n * @classdesc\n * An attribution for a layer source.\n *\n * Example:\n *\n *     source: new ol.source.OSM({\n *       attributions: [\n *         new ol.Attribution({\n *           html: 'All maps &copy; ' +\n *               '<a href=\"https://www.opencyclemap.org/\">OpenCycleMap</a>'\n *         }),\n *         ol.source.OSM.ATTRIBUTION\n *       ],\n *     ..\n *\n * @constructor\n * @deprecated This class is deprecated and will removed in the next major release.\n * @param {olx.AttributionOptions} options Attribution options.\n * @struct\n * @api\n */\n\nvar _ol_Attribution_ = function (options) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this.html_ = options.html;\n  /**\n   * @private\n   * @type {Object.<string, Array.<ol.TileRange>>}\n   */\n\n  this.tileRanges_ = options.tileRanges ? options.tileRanges : null;\n};\n/**\n * Get the attribution markup.\n * @return {string} The attribution HTML.\n * @api\n */\n\n\n_ol_Attribution_.prototype.getHTML = function () {\n  return this.html_;\n};\n/**\n * @param {Object.<string, ol.TileRange>} tileRanges Tile ranges.\n * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.\n * @param {!ol.proj.Projection} projection Projection.\n * @return {boolean} Intersects any tile range.\n */\n\n\n_ol_Attribution_.prototype.intersectsAnyTileRange = function (tileRanges, tileGrid, projection) {\n  if (!this.tileRanges_) {\n    return true;\n  }\n\n  var i, ii, tileRange, zKey;\n\n  for (zKey in tileRanges) {\n    if (!(zKey in this.tileRanges_)) {\n      continue;\n    }\n\n    tileRange = tileRanges[zKey];\n    var testTileRange;\n\n    for (i = 0, ii = this.tileRanges_[zKey].length; i < ii; ++i) {\n      testTileRange = this.tileRanges_[zKey][i];\n\n      if (testTileRange.intersects(tileRange)) {\n        return true;\n      }\n\n      var extentTileRange = tileGrid.getTileRangeForExtentAndZ(_ol_tilegrid_.extentFromProjection(projection), parseInt(zKey, 10));\n      var width = extentTileRange.getWidth();\n\n      if (tileRange.minX < extentTileRange.minX || tileRange.maxX > extentTileRange.maxX) {\n        if (testTileRange.intersects(new _ol_TileRange_(_ol_math_.modulo(tileRange.minX, width), _ol_math_.modulo(tileRange.maxX, width), tileRange.minY, tileRange.maxY))) {\n          return true;\n        }\n\n        if (tileRange.getWidth() > width && testTileRange.intersects(extentTileRange)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n\nexport default _ol_Attribution_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/attribution.js"],"names":["_ol_TileRange_","_ol_math_","_ol_tilegrid_","_ol_Attribution_","options","html_","html","tileRanges_","tileRanges","prototype","getHTML","intersectsAnyTileRange","tileGrid","projection","i","ii","tileRange","zKey","testTileRange","length","intersects","extentTileRange","getTileRangeForExtentAndZ","extentFromProjection","parseInt","width","getWidth","minX","maxX","modulo","minY","maxY"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,gBAA3B;AACA,OAAOC,SAAP,MAAsB,WAAtB;AACA,OAAOC,aAAP,MAA0B,eAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,gBAAgB,GAAG,UAASC,OAAT,EAAkB;AAEvC;AACF;AACA;AACA;AACE,OAAKC,KAAL,GAAaD,OAAO,CAACE,IAArB;AAEA;AACF;AACA;AACA;;AACE,OAAKC,WAAL,GAAmBH,OAAO,CAACI,UAAR,GAAqBJ,OAAO,CAACI,UAA7B,GAA0C,IAA7D;AAED,CAdD;AAiBA;AACA;AACA;AACA;AACA;;;AACAL,gBAAgB,CAACM,SAAjB,CAA2BC,OAA3B,GAAqC,YAAW;AAC9C,SAAO,KAAKL,KAAZ;AACD,CAFD;AAKA;AACA;AACA;AACA;AACA;AACA;;;AACAF,gBAAgB,CAACM,SAAjB,CAA2BE,sBAA3B,GAAoD,UAASH,UAAT,EAAqBI,QAArB,EAA+BC,UAA/B,EAA2C;AAC7F,MAAI,CAAC,KAAKN,WAAV,EAAuB;AACrB,WAAO,IAAP;AACD;;AACD,MAAIO,CAAJ,EAAOC,EAAP,EAAWC,SAAX,EAAsBC,IAAtB;;AACA,OAAKA,IAAL,IAAaT,UAAb,EAAyB;AACvB,QAAI,EAAES,IAAI,IAAI,KAAKV,WAAf,CAAJ,EAAiC;AAC/B;AACD;;AACDS,IAAAA,SAAS,GAAGR,UAAU,CAACS,IAAD,CAAtB;AACA,QAAIC,aAAJ;;AACA,SAAKJ,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAG,KAAKR,WAAL,CAAiBU,IAAjB,EAAuBE,MAAxC,EAAgDL,CAAC,GAAGC,EAApD,EAAwD,EAAED,CAA1D,EAA6D;AAC3DI,MAAAA,aAAa,GAAG,KAAKX,WAAL,CAAiBU,IAAjB,EAAuBH,CAAvB,CAAhB;;AACA,UAAII,aAAa,CAACE,UAAd,CAAyBJ,SAAzB,CAAJ,EAAyC;AACvC,eAAO,IAAP;AACD;;AACD,UAAIK,eAAe,GAAGT,QAAQ,CAACU,yBAAT,CAClBpB,aAAa,CAACqB,oBAAd,CAAmCV,UAAnC,CADkB,EAC8BW,QAAQ,CAACP,IAAD,EAAO,EAAP,CADtC,CAAtB;AAEA,UAAIQ,KAAK,GAAGJ,eAAe,CAACK,QAAhB,EAAZ;;AACA,UAAIV,SAAS,CAACW,IAAV,GAAiBN,eAAe,CAACM,IAAjC,IACAX,SAAS,CAACY,IAAV,GAAiBP,eAAe,CAACO,IADrC,EAC2C;AACzC,YAAIV,aAAa,CAACE,UAAd,CAAyB,IAAIpB,cAAJ,CACzBC,SAAS,CAAC4B,MAAV,CAAiBb,SAAS,CAACW,IAA3B,EAAiCF,KAAjC,CADyB,EAEzBxB,SAAS,CAAC4B,MAAV,CAAiBb,SAAS,CAACY,IAA3B,EAAiCH,KAAjC,CAFyB,EAGzBT,SAAS,CAACc,IAHe,EAGTd,SAAS,CAACe,IAHD,CAAzB,CAAJ,EAGsC;AACpC,iBAAO,IAAP;AACD;;AACD,YAAIf,SAAS,CAACU,QAAV,KAAuBD,KAAvB,IACAP,aAAa,CAACE,UAAd,CAAyBC,eAAzB,CADJ,EAC+C;AAC7C,iBAAO,IAAP;AACD;AACF;AACF;AACF;;AACD,SAAO,KAAP;AACD,CAnCD;;AAoCA,eAAelB,gBAAf","sourcesContent":["import _ol_TileRange_ from './tilerange.js';\nimport _ol_math_ from './math.js';\nimport _ol_tilegrid_ from './tilegrid.js';\n\n/**\n * @classdesc\n * An attribution for a layer source.\n *\n * Example:\n *\n *     source: new ol.source.OSM({\n *       attributions: [\n *         new ol.Attribution({\n *           html: 'All maps &copy; ' +\n *               '<a href=\"https://www.opencyclemap.org/\">OpenCycleMap</a>'\n *         }),\n *         ol.source.OSM.ATTRIBUTION\n *       ],\n *     ..\n *\n * @constructor\n * @deprecated This class is deprecated and will removed in the next major release.\n * @param {olx.AttributionOptions} options Attribution options.\n * @struct\n * @api\n */\nvar _ol_Attribution_ = function(options) {\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this.html_ = options.html;\n\n  /**\n   * @private\n   * @type {Object.<string, Array.<ol.TileRange>>}\n   */\n  this.tileRanges_ = options.tileRanges ? options.tileRanges : null;\n\n};\n\n\n/**\n * Get the attribution markup.\n * @return {string} The attribution HTML.\n * @api\n */\n_ol_Attribution_.prototype.getHTML = function() {\n  return this.html_;\n};\n\n\n/**\n * @param {Object.<string, ol.TileRange>} tileRanges Tile ranges.\n * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.\n * @param {!ol.proj.Projection} projection Projection.\n * @return {boolean} Intersects any tile range.\n */\n_ol_Attribution_.prototype.intersectsAnyTileRange = function(tileRanges, tileGrid, projection) {\n  if (!this.tileRanges_) {\n    return true;\n  }\n  var i, ii, tileRange, zKey;\n  for (zKey in tileRanges) {\n    if (!(zKey in this.tileRanges_)) {\n      continue;\n    }\n    tileRange = tileRanges[zKey];\n    var testTileRange;\n    for (i = 0, ii = this.tileRanges_[zKey].length; i < ii; ++i) {\n      testTileRange = this.tileRanges_[zKey][i];\n      if (testTileRange.intersects(tileRange)) {\n        return true;\n      }\n      var extentTileRange = tileGrid.getTileRangeForExtentAndZ(\n          _ol_tilegrid_.extentFromProjection(projection), parseInt(zKey, 10));\n      var width = extentTileRange.getWidth();\n      if (tileRange.minX < extentTileRange.minX ||\n          tileRange.maxX > extentTileRange.maxX) {\n        if (testTileRange.intersects(new _ol_TileRange_(\n            _ol_math_.modulo(tileRange.minX, width),\n            _ol_math_.modulo(tileRange.maxX, width),\n            tileRange.minY, tileRange.maxY))) {\n          return true;\n        }\n        if (tileRange.getWidth() > width &&\n            testTileRange.intersects(extentTileRange)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\nexport default _ol_Attribution_;\n"]},"metadata":{},"sourceType":"module"}
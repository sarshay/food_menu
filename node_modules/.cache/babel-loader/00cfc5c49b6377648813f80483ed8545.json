{"ast":null,"code":"import _ol_dom_ from './dom.js';\nimport _ol_extent_ from './extent.js';\nimport _ol_math_ from './math.js';\nimport _ol_proj_ from './proj.js';\nvar _ol_reproj_ = {};\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {ol.proj.Projection} sourceProj Source projection.\n * @param {ol.proj.Projection} targetProj Target projection.\n * @param {ol.Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\n\n_ol_reproj_.calculateSourceResolution = function (sourceProj, targetProj, targetCenter, targetResolution) {\n  var sourceCenter = _ol_proj_.transform(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data\n\n\n  var sourceResolution = _ol_proj_.getPointResolution(targetProj, targetResolution, targetCenter);\n\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  } // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n\n  var sourceExtent = sourceProj.getExtent();\n\n  if (!sourceExtent || _ol_extent_.containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor = _ol_proj_.getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;\n\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n};\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {ol.Coordinate} New point 1 px farther from the centroid.\n * @private\n */\n\n\n_ol_reproj_.enlargeClipPoint_ = function (centroidX, centroidY, x, y) {\n  var dX = x - centroidX,\n      dY = y - centroidY;\n  var distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n};\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {ol.Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {ol.Extent} targetExtent Target extent.\n * @param {ol.reproj.Triangulation} triangulation Calculated triangulation.\n * @param {Array.<{extent: ol.Extent,\n *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources\n *             Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\n\n\n_ol_reproj_.render = function (width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {\n  var context = _ol_dom_.createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  var sourceDataExtent = _ol_extent_.createEmpty();\n\n  sources.forEach(function (src, i, arr) {\n    _ol_extent_.extend(sourceDataExtent, src.extent);\n  });\n\n  var canvasWidthInUnits = _ol_extent_.getWidth(sourceDataExtent);\n\n  var canvasHeightInUnits = _ol_extent_.getHeight(sourceDataExtent);\n\n  var stitchContext = _ol_dom_.createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n\n  var stitchScale = pixelRatio / sourceResolution;\n  sources.forEach(function (src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n\n    var srcWidth = _ol_extent_.getWidth(src.extent);\n\n    var srcHeight = _ol_extent_.getHeight(src.extent);\n\n    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n\n  var targetTopLeft = _ol_extent_.getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source,\n        target = triangle.target;\n    var x0 = source[0][0],\n        y0 = source[0][1],\n        x1 = source[1][0],\n        y1 = source[1][1],\n        x2 = source[2][0],\n        y2 = source[2][1];\n    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,\n        v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,\n        v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,\n        v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution; // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n\n    var sourceNumericalShiftX = x0,\n        sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];\n\n    var affineCoefs = _ol_math_.solveLinearSystem(augmentedMatrix);\n\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n    var centroidX = (u0 + u1 + u2) / 3,\n        centroidY = (v0 + v1 + v2) / 3;\n\n    var p0 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u0, v0);\n\n    var p1 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u1, v1);\n\n    var p2 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u2, v2);\n\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,\n          v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,\n          v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,\n          v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n    context.restore();\n  }\n\n  return context.canvas;\n};\n\nexport default _ol_reproj_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/reproj.js"],"names":["_ol_dom_","_ol_extent_","_ol_math_","_ol_proj_","_ol_reproj_","calculateSourceResolution","sourceProj","targetProj","targetCenter","targetResolution","sourceCenter","transform","sourceResolution","getPointResolution","targetMetersPerUnit","getMetersPerUnit","undefined","sourceMetersPerUnit","sourceExtent","getExtent","containsCoordinate","compensationFactor","isFinite","enlargeClipPoint_","centroidX","centroidY","x","y","dX","dY","distance","Math","sqrt","round","render","width","height","pixelRatio","targetExtent","triangulation","sources","gutter","opt_renderEdges","context","createCanvasContext2D","length","canvas","scale","sourceDataExtent","createEmpty","forEach","src","i","arr","extend","extent","canvasWidthInUnits","getWidth","canvasHeightInUnits","getHeight","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","drawImage","image","targetTopLeft","getTopLeft","getTriangles","triangle","source","target","x0","y0","x1","y1","x2","y2","u0","v0","u1","v1","u2","v2","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","solveLinearSystem","save","beginPath","p0","p1","p2","moveTo","lineTo","clip","translate","restore","strokeStyle","lineWidth","closePath","stroke"],"mappings":"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","sourcesContent":["import _ol_dom_ from './dom.js';\nimport _ol_extent_ from './extent.js';\nimport _ol_math_ from './math.js';\nimport _ol_proj_ from './proj.js';\nvar _ol_reproj_ = {};\n\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {ol.proj.Projection} sourceProj Source projection.\n * @param {ol.proj.Projection} targetProj Target projection.\n * @param {ol.Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\n_ol_reproj_.calculateSourceResolution = function(sourceProj, targetProj,\n    targetCenter, targetResolution) {\n\n  var sourceCenter = _ol_proj_.transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  var sourceResolution =\n      _ol_proj_.getPointResolution(targetProj, targetResolution, targetCenter);\n\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  var sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || _ol_extent_.containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor =\n        _ol_proj_.getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n        sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n};\n\n\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {ol.Coordinate} New point 1 px farther from the centroid.\n * @private\n */\n_ol_reproj_.enlargeClipPoint_ = function(centroidX, centroidY, x, y) {\n  var dX = x - centroidX, dY = y - centroidY;\n  var distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n};\n\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {ol.Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {ol.Extent} targetExtent Target extent.\n * @param {ol.reproj.Triangulation} triangulation Calculated triangulation.\n * @param {Array.<{extent: ol.Extent,\n *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources\n *             Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\n_ol_reproj_.render = function(width, height, pixelRatio,\n    sourceResolution, sourceExtent, targetResolution, targetExtent,\n    triangulation, sources, gutter, opt_renderEdges) {\n\n  var context = _ol_dom_.createCanvasContext2D(Math.round(pixelRatio * width),\n      Math.round(pixelRatio * height));\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  var sourceDataExtent = _ol_extent_.createEmpty();\n  sources.forEach(function(src, i, arr) {\n    _ol_extent_.extend(sourceDataExtent, src.extent);\n  });\n\n  var canvasWidthInUnits = _ol_extent_.getWidth(sourceDataExtent);\n  var canvasHeightInUnits = _ol_extent_.getHeight(sourceDataExtent);\n  var stitchContext = _ol_dom_.createCanvasContext2D(\n      Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),\n      Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n\n  var stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function(src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = _ol_extent_.getWidth(src.extent);\n    var srcHeight = _ol_extent_.getHeight(src.extent);\n\n    stitchContext.drawImage(\n        src.image,\n        gutter, gutter,\n        src.image.width - 2 * gutter, src.image.height - 2 * gutter,\n        xPos * stitchScale, yPos * stitchScale,\n        srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n\n  var targetTopLeft = _ol_extent_.getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function(triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source, target = triangle.target;\n    var x0 = source[0][0], y0 = source[0][1],\n        x1 = source[1][0], y1 = source[1][1],\n        x2 = source[2][0], y2 = source[2][1];\n    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,\n        v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,\n        v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,\n        v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    var sourceNumericalShiftX = x0, sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    var augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0]\n    ];\n    var affineCoefs = _ol_math_.solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n    var centroidX = (u0 + u1 + u2) / 3, centroidY = (v0 + v1 + v2) / 3;\n    var p0 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u0, v0);\n    var p1 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u1, v1);\n    var p2 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u2, v2);\n\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n\n    context.transform(\n        affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,\n        sourceDataExtent[3] - sourceNumericalShiftY);\n\n    context.scale(sourceResolution / pixelRatio,\n        -sourceResolution / pixelRatio);\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function(triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,\n          v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,\n          v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,\n          v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n};\nexport default _ol_reproj_;\n"]},"metadata":{},"sourceType":"module"}
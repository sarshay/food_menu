{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/webgl/Layer\n */\n\n\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\n/**\n * @enum {string}\n */\n\nexport var WebGLWorkerMessageType = {\n  GENERATE_BUFFERS: 'GENERATE_BUFFERS'\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n */\n\nvar WebGLLayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(WebGLLayerRenderer, _super);\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function WebGLLayerRenderer(layer, opt_options) {\n    var _this = _super.call(this, layer) || this;\n\n    var options = opt_options || {};\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n\n    _this.helper = new WebGLHelper({\n      postProcesses: options.postProcesses,\n      uniforms: options.uniforms\n    });\n\n    if (options.className !== undefined) {\n      _this.helper.getCanvas().className = options.className;\n    }\n\n    return _this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  WebGLLayerRenderer.prototype.disposeInternal = function () {\n    this.helper.dispose();\n    delete this.helper;\n\n    _super.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, frameState) {\n    var layer = this.getLayer();\n\n    if (layer.hasListener(type)) {\n      // RenderEvent does not get a context or an inversePixelTransform, because WebGL allows much less direct editing than Canvas2d does.\n      var event_1 = new RenderEvent(type, null, frameState, null);\n      layer.dispatchEvent(event_1);\n    }\n  };\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  WebGLLayerRenderer.prototype.preRender = function (frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, frameState);\n  };\n  /**\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  WebGLLayerRenderer.prototype.postRender = function (frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, frameState);\n  };\n\n  return WebGLLayerRenderer;\n}(LayerRenderer);\n\nvar tmpArray_ = [];\nvar bufferPositions_ = {\n  vertexPosition: 0,\n  indexPosition: 0\n};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\n\n\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n  // This is for x, y and index\n  var baseVertexAttrsCount = 3;\n  var baseInstructionsCount = 2;\n  var stride = baseVertexAttrsCount + customAttributesCount;\n  var x = instructions[elementIndex + 0];\n  var y = instructions[elementIndex + 1]; // read custom numerical attributes on the feature\n\n  var customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n\n  for (var i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  var baseIndex = vPos / stride; // push vertices for each of the four quad corners (first standard then custom attributes)\n\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n  return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\n\nexport function getBlankImageData() {\n  var canvas = document.createElement('canvas');\n  var image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\n\nexport function colorEncodeId(id, opt_array) {\n  var array = opt_array || [];\n  var radix = 256;\n  var divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = Math.floor(id / radix / radix) % radix / divide;\n  array[2] = Math.floor(id / radix) % radix / divide;\n  array[3] = id % radix / divide;\n  return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\n\nexport function colorDecodeId(color) {\n  var id = 0;\n  var radix = 256;\n  var mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\nexport default WebGLLayerRenderer;","map":{"version":3,"sources":["../../src/renderer/webgl/Layer.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n    GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n */\nvar WebGLLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLLayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLLayerRenderer(layer, opt_options) {\n        var _this = _super.call(this, layer) || this;\n        var options = opt_options || {};\n        /**\n         * @type {WebGLHelper}\n         * @protected\n         */\n        _this.helper = new WebGLHelper({\n            postProcesses: options.postProcesses,\n            uniforms: options.uniforms,\n        });\n        if (options.className !== undefined) {\n            _this.helper.getCanvas().className = options.className;\n        }\n        return _this;\n    }\n    /**\n     * Clean up.\n     */\n    WebGLLayerRenderer.prototype.disposeInternal = function () {\n        this.helper.dispose();\n        delete this.helper;\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * @param {import(\"../../render/EventType.js\").default} type Event type.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(type)) {\n            // RenderEvent does not get a context or an inversePixelTransform, because WebGL allows much less direct editing than Canvas2d does.\n            var event_1 = new RenderEvent(type, null, frameState, null);\n            layer.dispatchEvent(event_1);\n        }\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.preRender = function (frameState) {\n        this.dispatchRenderEvent_(RenderEventType.PRERENDER, frameState);\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.postRender = function (frameState) {\n        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, frameState);\n    };\n    return WebGLLayerRenderer;\n}(LayerRenderer));\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n    buffer[pos + 0] = x;\n    buffer[pos + 1] = y;\n    buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n    // This is for x, y and index\n    var baseVertexAttrsCount = 3;\n    var baseInstructionsCount = 2;\n    var stride = baseVertexAttrsCount + customAttributesCount;\n    var x = instructions[elementIndex + 0];\n    var y = instructions[elementIndex + 1];\n    // read custom numerical attributes on the feature\n    var customAttrs = tmpArray_;\n    customAttrs.length = customAttributesCount;\n    for (var i = 0; i < customAttrs.length; i++) {\n        customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n    }\n    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n    var baseIndex = vPos / stride;\n    // push vertices for each of the four quad corners (first standard then custom attributes)\n    writePointVertex(vertexBuffer, vPos, x, y, 0);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 1);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 2);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 3);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    indexBuffer[iPos++] = baseIndex;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 3;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 2;\n    indexBuffer[iPos++] = baseIndex + 3;\n    bufferPositions_.vertexPosition = vPos;\n    bufferPositions_.indexPosition = iPos;\n    return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n    var canvas = document.createElement('canvas');\n    var image = canvas.getContext('2d').createImageData(1, 1);\n    image.data[0] = 255;\n    image.data[1] = 255;\n    image.data[2] = 255;\n    image.data[3] = 255;\n    return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n    var array = opt_array || [];\n    var radix = 256;\n    var divide = radix - 1;\n    array[0] = Math.floor(id / radix / radix / radix) / divide;\n    array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n    array[2] = (Math.floor(id / radix) % radix) / divide;\n    array[3] = (id % radix) / divide;\n    return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n    var id = 0;\n    var radix = 256;\n    var mult = radix - 1;\n    id += Math.round(color[0] * radix * radix * radix * mult);\n    id += Math.round(color[1] * radix * radix * mult);\n    id += Math.round(color[2] * radix * mult);\n    id += Math.round(color[3] * mult);\n    return id;\n}\nexport default WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _ol_ from './index.js';\nimport _ol_has_ from './has.js';\nimport _ol_MapBrowserEventType_ from './mapbrowsereventtype.js';\nimport _ol_MapBrowserPointerEvent_ from './mapbrowserpointerevent.js';\nimport _ol_events_ from './events.js';\nimport _ol_events_EventTarget_ from './events/eventtarget.js';\nimport _ol_pointer_EventType_ from './pointer/eventtype.js';\nimport _ol_pointer_PointerEventHandler_ from './pointer/pointereventhandler.js';\n/**\n * @param {ol.PluggableMap} map The map with the viewport to listen to events on.\n * @param {number|undefined} moveTolerance The minimal distance the pointer must travel to trigger a move.\n * @constructor\n * @extends {ol.events.EventTarget}\n */\n\nvar _ol_MapBrowserEventHandler_ = function (map, moveTolerance) {\n  _ol_events_EventTarget_.call(this);\n  /**\n   * This is the element that we will listen to the real events on.\n   * @type {ol.PluggableMap}\n   * @private\n   */\n\n\n  this.map_ = map;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.clickTimeoutId_ = 0;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this.dragging_ = false;\n  /**\n   * @type {!Array.<ol.EventsKey>}\n   * @private\n   */\n\n  this.dragListenerKeys_ = [];\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.moveTolerance_ = moveTolerance ? moveTolerance * _ol_has_.DEVICE_PIXEL_RATIO : _ol_has_.DEVICE_PIXEL_RATIO;\n  /**\n   * The most recent \"down\" type event (or null if none have occurred).\n   * Set on pointerdown.\n   * @type {ol.pointer.PointerEvent}\n   * @private\n   */\n\n  this.down_ = null;\n  var element = this.map_.getViewport();\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.activePointers_ = 0;\n  /**\n   * @type {!Object.<number, boolean>}\n   * @private\n   */\n\n  this.trackedTouches_ = {};\n  /**\n   * Event handler which generates pointer events for\n   * the viewport element.\n   *\n   * @type {ol.pointer.PointerEventHandler}\n   * @private\n   */\n\n  this.pointerEventHandler_ = new _ol_pointer_PointerEventHandler_(element);\n  /**\n   * Event handler which generates pointer events for\n   * the document (used when dragging).\n   *\n   * @type {ol.pointer.PointerEventHandler}\n   * @private\n   */\n\n  this.documentPointerEventHandler_ = null;\n  /**\n   * @type {?ol.EventsKey}\n   * @private\n   */\n\n  this.pointerdownListenerKey_ = _ol_events_.listen(this.pointerEventHandler_, _ol_pointer_EventType_.POINTERDOWN, this.handlePointerDown_, this);\n  /**\n   * @type {?ol.EventsKey}\n   * @private\n   */\n\n  this.relayedListenerKey_ = _ol_events_.listen(this.pointerEventHandler_, _ol_pointer_EventType_.POINTERMOVE, this.relayEvent_, this);\n};\n\n_ol_.inherits(_ol_MapBrowserEventHandler_, _ol_events_EventTarget_);\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n\n\n_ol_MapBrowserEventHandler_.prototype.emulateClick_ = function (pointerEvent) {\n  var newEvent = new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.CLICK, this.map_, pointerEvent);\n  this.dispatchEvent(newEvent);\n\n  if (this.clickTimeoutId_ !== 0) {\n    // double-click\n    clearTimeout(this.clickTimeoutId_);\n    this.clickTimeoutId_ = 0;\n    newEvent = new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.DBLCLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n  } else {\n    // click\n    this.clickTimeoutId_ = setTimeout(function () {\n      this.clickTimeoutId_ = 0;\n      var newEvent = new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.SINGLECLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    }.bind(this), 250);\n  }\n};\n/**\n * Keeps track on how many pointers are currently active.\n *\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n\n\n_ol_MapBrowserEventHandler_.prototype.updateActivePointers_ = function (pointerEvent) {\n  var event = pointerEvent;\n\n  if (event.type == _ol_MapBrowserEventType_.POINTERUP || event.type == _ol_MapBrowserEventType_.POINTERCANCEL) {\n    delete this.trackedTouches_[event.pointerId];\n  } else if (event.type == _ol_MapBrowserEventType_.POINTERDOWN) {\n    this.trackedTouches_[event.pointerId] = true;\n  }\n\n  this.activePointers_ = Object.keys(this.trackedTouches_).length;\n};\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n\n\n_ol_MapBrowserEventHandler_.prototype.handlePointerUp_ = function (pointerEvent) {\n  this.updateActivePointers_(pointerEvent);\n  var newEvent = new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.POINTERUP, this.map_, pointerEvent);\n  this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen\n  // contact. isMouseActionButton returns true in these cases (evt.button is set\n  // to 0).\n  // See http://www.w3.org/TR/pointerevents/#button-states\n  // We only fire click, singleclick, and doubleclick if nobody has called\n  // event.stopPropagation() or event.preventDefault().\n\n  if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n    this.emulateClick_(this.down_);\n  }\n\n  if (this.activePointers_ === 0) {\n    this.dragListenerKeys_.forEach(_ol_events_.unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.dragging_ = false;\n    this.down_ = null;\n    this.documentPointerEventHandler_.dispose();\n    this.documentPointerEventHandler_ = null;\n  }\n};\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @return {boolean} If the left mouse button was pressed.\n * @private\n */\n\n\n_ol_MapBrowserEventHandler_.prototype.isMouseActionButton_ = function (pointerEvent) {\n  return pointerEvent.button === 0;\n};\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n\n\n_ol_MapBrowserEventHandler_.prototype.handlePointerDown_ = function (pointerEvent) {\n  this.updateActivePointers_(pointerEvent);\n  var newEvent = new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.POINTERDOWN, this.map_, pointerEvent);\n  this.dispatchEvent(newEvent);\n  this.down_ = pointerEvent;\n\n  if (this.dragListenerKeys_.length === 0) {\n    /* Set up a pointer event handler on the `document`,\n     * which is required when the pointer is moved outside\n     * the viewport when dragging.\n     */\n    this.documentPointerEventHandler_ = new _ol_pointer_PointerEventHandler_(document);\n    this.dragListenerKeys_.push(_ol_events_.listen(this.documentPointerEventHandler_, _ol_MapBrowserEventType_.POINTERMOVE, this.handlePointerMove_, this), _ol_events_.listen(this.documentPointerEventHandler_, _ol_MapBrowserEventType_.POINTERUP, this.handlePointerUp_, this),\n    /* Note that the listener for `pointercancel is set up on\n    * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n    * the `pointerup` and `pointermove` listeners.\n    *\n    * The reason for this is the following: `TouchSource.vacuumTouches_()`\n    * issues `pointercancel` events, when there was no `touchend` for a\n    * `touchstart`. Now, let's say a first `touchstart` is registered on\n    * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n    * But `documentPointerEventHandler_` doesn't know about the first\n    * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n    * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n    * only registered there.\n    */\n    _ol_events_.listen(this.pointerEventHandler_, _ol_MapBrowserEventType_.POINTERCANCEL, this.handlePointerUp_, this));\n  }\n};\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n\n\n_ol_MapBrowserEventHandler_.prototype.handlePointerMove_ = function (pointerEvent) {\n  // Between pointerdown and pointerup, pointermove events are triggered.\n  // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n  // moved a significant distance.\n  if (this.isMoving_(pointerEvent)) {\n    this.dragging_ = true;\n    var newEvent = new _ol_MapBrowserPointerEvent_(_ol_MapBrowserEventType_.POINTERDRAG, this.map_, pointerEvent, this.dragging_);\n    this.dispatchEvent(newEvent);\n  } // Some native android browser triggers mousemove events during small period\n  // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\n  // https://code.google.com/p/android/issues/detail?id=19827\n  // ex: Galaxy Tab P3110 + Android 4.1.1\n\n\n  pointerEvent.preventDefault();\n};\n/**\n * Wrap and relay a pointer event.  Note that this requires that the type\n * string for the MapBrowserPointerEvent matches the PointerEvent type.\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n\n\n_ol_MapBrowserEventHandler_.prototype.relayEvent_ = function (pointerEvent) {\n  var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n  this.dispatchEvent(new _ol_MapBrowserPointerEvent_(pointerEvent.type, this.map_, pointerEvent, dragging));\n};\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @return {boolean} Is moving.\n * @private\n */\n\n\n_ol_MapBrowserEventHandler_.prototype.isMoving_ = function (pointerEvent) {\n  return Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_MapBrowserEventHandler_.prototype.disposeInternal = function () {\n  if (this.relayedListenerKey_) {\n    _ol_events_.unlistenByKey(this.relayedListenerKey_);\n\n    this.relayedListenerKey_ = null;\n  }\n\n  if (this.pointerdownListenerKey_) {\n    _ol_events_.unlistenByKey(this.pointerdownListenerKey_);\n\n    this.pointerdownListenerKey_ = null;\n  }\n\n  this.dragListenerKeys_.forEach(_ol_events_.unlistenByKey);\n  this.dragListenerKeys_.length = 0;\n\n  if (this.documentPointerEventHandler_) {\n    this.documentPointerEventHandler_.dispose();\n    this.documentPointerEventHandler_ = null;\n  }\n\n  if (this.pointerEventHandler_) {\n    this.pointerEventHandler_.dispose();\n    this.pointerEventHandler_ = null;\n  }\n\n  _ol_events_EventTarget_.prototype.disposeInternal.call(this);\n};\n\nexport default _ol_MapBrowserEventHandler_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/mapbrowsereventhandler.js"],"names":["_ol_","_ol_has_","_ol_MapBrowserEventType_","_ol_MapBrowserPointerEvent_","_ol_events_","_ol_events_EventTarget_","_ol_pointer_EventType_","_ol_pointer_PointerEventHandler_","_ol_MapBrowserEventHandler_","map","moveTolerance","call","map_","clickTimeoutId_","dragging_","dragListenerKeys_","moveTolerance_","DEVICE_PIXEL_RATIO","down_","element","getViewport","activePointers_","trackedTouches_","pointerEventHandler_","documentPointerEventHandler_","pointerdownListenerKey_","listen","POINTERDOWN","handlePointerDown_","relayedListenerKey_","POINTERMOVE","relayEvent_","inherits","prototype","emulateClick_","pointerEvent","newEvent","CLICK","dispatchEvent","clearTimeout","DBLCLICK","setTimeout","SINGLECLICK","bind","updateActivePointers_","event","type","POINTERUP","POINTERCANCEL","pointerId","Object","keys","length","handlePointerUp_","propagationStopped","isMouseActionButton_","forEach","unlistenByKey","dispose","button","document","push","handlePointerMove_","isMoving_","POINTERDRAG","preventDefault","dragging","Math","abs","clientX","clientY","disposeInternal"],"mappings":"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","sourcesContent":["import _ol_ from './index.js';\nimport _ol_has_ from './has.js';\nimport _ol_MapBrowserEventType_ from './mapbrowsereventtype.js';\nimport _ol_MapBrowserPointerEvent_ from './mapbrowserpointerevent.js';\nimport _ol_events_ from './events.js';\nimport _ol_events_EventTarget_ from './events/eventtarget.js';\nimport _ol_pointer_EventType_ from './pointer/eventtype.js';\nimport _ol_pointer_PointerEventHandler_ from './pointer/pointereventhandler.js';\n\n/**\n * @param {ol.PluggableMap} map The map with the viewport to listen to events on.\n * @param {number|undefined} moveTolerance The minimal distance the pointer must travel to trigger a move.\n * @constructor\n * @extends {ol.events.EventTarget}\n */\nvar _ol_MapBrowserEventHandler_ = function(map, moveTolerance) {\n\n  _ol_events_EventTarget_.call(this);\n\n  /**\n   * This is the element that we will listen to the real events on.\n   * @type {ol.PluggableMap}\n   * @private\n   */\n  this.map_ = map;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.clickTimeoutId_ = 0;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.dragging_ = false;\n\n  /**\n   * @type {!Array.<ol.EventsKey>}\n   * @private\n   */\n  this.dragListenerKeys_ = [];\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.moveTolerance_ = moveTolerance ?\n    moveTolerance * _ol_has_.DEVICE_PIXEL_RATIO : _ol_has_.DEVICE_PIXEL_RATIO;\n\n  /**\n   * The most recent \"down\" type event (or null if none have occurred).\n   * Set on pointerdown.\n   * @type {ol.pointer.PointerEvent}\n   * @private\n   */\n  this.down_ = null;\n\n  var element = this.map_.getViewport();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.activePointers_ = 0;\n\n  /**\n   * @type {!Object.<number, boolean>}\n   * @private\n   */\n  this.trackedTouches_ = {};\n\n  /**\n   * Event handler which generates pointer events for\n   * the viewport element.\n   *\n   * @type {ol.pointer.PointerEventHandler}\n   * @private\n   */\n  this.pointerEventHandler_ = new _ol_pointer_PointerEventHandler_(element);\n\n  /**\n   * Event handler which generates pointer events for\n   * the document (used when dragging).\n   *\n   * @type {ol.pointer.PointerEventHandler}\n   * @private\n   */\n  this.documentPointerEventHandler_ = null;\n\n  /**\n   * @type {?ol.EventsKey}\n   * @private\n   */\n  this.pointerdownListenerKey_ = _ol_events_.listen(this.pointerEventHandler_,\n      _ol_pointer_EventType_.POINTERDOWN,\n      this.handlePointerDown_, this);\n\n  /**\n   * @type {?ol.EventsKey}\n   * @private\n   */\n  this.relayedListenerKey_ = _ol_events_.listen(this.pointerEventHandler_,\n      _ol_pointer_EventType_.POINTERMOVE,\n      this.relayEvent_, this);\n\n};\n\n_ol_.inherits(_ol_MapBrowserEventHandler_, _ol_events_EventTarget_);\n\n\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n_ol_MapBrowserEventHandler_.prototype.emulateClick_ = function(pointerEvent) {\n  var newEvent = new _ol_MapBrowserPointerEvent_(\n      _ol_MapBrowserEventType_.CLICK, this.map_, pointerEvent);\n  this.dispatchEvent(newEvent);\n  if (this.clickTimeoutId_ !== 0) {\n    // double-click\n    clearTimeout(this.clickTimeoutId_);\n    this.clickTimeoutId_ = 0;\n    newEvent = new _ol_MapBrowserPointerEvent_(\n        _ol_MapBrowserEventType_.DBLCLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n  } else {\n    // click\n    this.clickTimeoutId_ = setTimeout(function() {\n      this.clickTimeoutId_ = 0;\n      var newEvent = new _ol_MapBrowserPointerEvent_(\n          _ol_MapBrowserEventType_.SINGLECLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    }.bind(this), 250);\n  }\n};\n\n\n/**\n * Keeps track on how many pointers are currently active.\n *\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n_ol_MapBrowserEventHandler_.prototype.updateActivePointers_ = function(pointerEvent) {\n  var event = pointerEvent;\n\n  if (event.type == _ol_MapBrowserEventType_.POINTERUP ||\n      event.type == _ol_MapBrowserEventType_.POINTERCANCEL) {\n    delete this.trackedTouches_[event.pointerId];\n  } else if (event.type == _ol_MapBrowserEventType_.POINTERDOWN) {\n    this.trackedTouches_[event.pointerId] = true;\n  }\n  this.activePointers_ = Object.keys(this.trackedTouches_).length;\n};\n\n\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n_ol_MapBrowserEventHandler_.prototype.handlePointerUp_ = function(pointerEvent) {\n  this.updateActivePointers_(pointerEvent);\n  var newEvent = new _ol_MapBrowserPointerEvent_(\n      _ol_MapBrowserEventType_.POINTERUP, this.map_, pointerEvent);\n  this.dispatchEvent(newEvent);\n\n  // We emulate click events on left mouse button click, touch contact, and pen\n  // contact. isMouseActionButton returns true in these cases (evt.button is set\n  // to 0).\n  // See http://www.w3.org/TR/pointerevents/#button-states\n  // We only fire click, singleclick, and doubleclick if nobody has called\n  // event.stopPropagation() or event.preventDefault().\n  if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n    this.emulateClick_(this.down_);\n  }\n\n  if (this.activePointers_ === 0) {\n    this.dragListenerKeys_.forEach(_ol_events_.unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.dragging_ = false;\n    this.down_ = null;\n    this.documentPointerEventHandler_.dispose();\n    this.documentPointerEventHandler_ = null;\n  }\n};\n\n\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @return {boolean} If the left mouse button was pressed.\n * @private\n */\n_ol_MapBrowserEventHandler_.prototype.isMouseActionButton_ = function(pointerEvent) {\n  return pointerEvent.button === 0;\n};\n\n\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n_ol_MapBrowserEventHandler_.prototype.handlePointerDown_ = function(pointerEvent) {\n  this.updateActivePointers_(pointerEvent);\n  var newEvent = new _ol_MapBrowserPointerEvent_(\n      _ol_MapBrowserEventType_.POINTERDOWN, this.map_, pointerEvent);\n  this.dispatchEvent(newEvent);\n\n  this.down_ = pointerEvent;\n\n  if (this.dragListenerKeys_.length === 0) {\n    /* Set up a pointer event handler on the `document`,\n     * which is required when the pointer is moved outside\n     * the viewport when dragging.\n     */\n    this.documentPointerEventHandler_ =\n        new _ol_pointer_PointerEventHandler_(document);\n\n    this.dragListenerKeys_.push(\n        _ol_events_.listen(this.documentPointerEventHandler_,\n            _ol_MapBrowserEventType_.POINTERMOVE,\n            this.handlePointerMove_, this),\n        _ol_events_.listen(this.documentPointerEventHandler_,\n            _ol_MapBrowserEventType_.POINTERUP,\n            this.handlePointerUp_, this),\n        /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn't know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n        _ol_events_.listen(this.pointerEventHandler_,\n            _ol_MapBrowserEventType_.POINTERCANCEL,\n            this.handlePointerUp_, this)\n    );\n  }\n};\n\n\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n_ol_MapBrowserEventHandler_.prototype.handlePointerMove_ = function(pointerEvent) {\n  // Between pointerdown and pointerup, pointermove events are triggered.\n  // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n  // moved a significant distance.\n  if (this.isMoving_(pointerEvent)) {\n    this.dragging_ = true;\n    var newEvent = new _ol_MapBrowserPointerEvent_(\n        _ol_MapBrowserEventType_.POINTERDRAG, this.map_, pointerEvent,\n        this.dragging_);\n    this.dispatchEvent(newEvent);\n  }\n\n  // Some native android browser triggers mousemove events during small period\n  // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\n  // https://code.google.com/p/android/issues/detail?id=19827\n  // ex: Galaxy Tab P3110 + Android 4.1.1\n  pointerEvent.preventDefault();\n};\n\n\n/**\n * Wrap and relay a pointer event.  Note that this requires that the type\n * string for the MapBrowserPointerEvent matches the PointerEvent type.\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @private\n */\n_ol_MapBrowserEventHandler_.prototype.relayEvent_ = function(pointerEvent) {\n  var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n  this.dispatchEvent(new _ol_MapBrowserPointerEvent_(\n      pointerEvent.type, this.map_, pointerEvent, dragging));\n};\n\n\n/**\n * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.\n * @return {boolean} Is moving.\n * @private\n */\n_ol_MapBrowserEventHandler_.prototype.isMoving_ = function(pointerEvent) {\n  return Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ ||\n      Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_MapBrowserEventHandler_.prototype.disposeInternal = function() {\n  if (this.relayedListenerKey_) {\n    _ol_events_.unlistenByKey(this.relayedListenerKey_);\n    this.relayedListenerKey_ = null;\n  }\n  if (this.pointerdownListenerKey_) {\n    _ol_events_.unlistenByKey(this.pointerdownListenerKey_);\n    this.pointerdownListenerKey_ = null;\n  }\n\n  this.dragListenerKeys_.forEach(_ol_events_.unlistenByKey);\n  this.dragListenerKeys_.length = 0;\n\n  if (this.documentPointerEventHandler_) {\n    this.documentPointerEventHandler_.dispose();\n    this.documentPointerEventHandler_ = null;\n  }\n  if (this.pointerEventHandler_) {\n    this.pointerEventHandler_.dispose();\n    this.pointerEventHandler_ = null;\n  }\n  _ol_events_EventTarget_.prototype.disposeInternal.call(this);\n};\nexport default _ol_MapBrowserEventHandler_;\n"]},"metadata":{},"sourceType":"module"}
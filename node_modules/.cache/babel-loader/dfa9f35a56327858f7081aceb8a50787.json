{"ast":null,"code":"import _ol_ from './index.js';\nimport _ol_Sphere_ from './sphere.js';\nimport _ol_extent_ from './extent.js';\nimport _ol_math_ from './math.js';\nimport _ol_proj_EPSG3857_ from './proj/epsg3857.js';\nimport _ol_proj_EPSG4326_ from './proj/epsg4326.js';\nimport _ol_proj_Projection_ from './proj/projection.js';\nimport _ol_proj_Units_ from './proj/units.js';\nimport _ol_proj_proj4_ from './proj/proj4.js';\nimport _ol_proj_projections_ from './proj/projections.js';\nimport _ol_proj_transforms_ from './proj/transforms.js';\nvar _ol_proj_ = {};\n/**\n * Meters per unit lookup table.\n * @const\n * @type {Object.<ol.proj.Units, number>}\n * @api\n */\n\n_ol_proj_.METERS_PER_UNIT = _ol_proj_Units_.METERS_PER_UNIT;\n/**\n * A place to store the mean radius of the Earth.\n * @private\n * @type {ol.Sphere}\n */\n\n_ol_proj_.SPHERE_ = new _ol_Sphere_(_ol_Sphere_.DEFAULT_RADIUS);\n\nif (_ol_.ENABLE_PROJ4JS) {\n  /**\n   * Register proj4. If not explicitly registered, it will be assumed that\n   * proj4js will be loaded in the global namespace. For example in a\n   * browserify ES6 environment you could use:\n   *\n   *     import ol from 'openlayers';\n   *     import proj4 from 'proj4';\n   *     ol.proj.setProj4(proj4);\n   *\n   * @param {Proj4} proj4 Proj4.\n   * @api\n   */\n  _ol_proj_.setProj4 = function (proj4) {\n    _ol_proj_proj4_.set(proj4);\n  };\n}\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the 'point' pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link ol.proj.Projection} constructor or by using\n * {@link ol.proj.Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ol.ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {ol.Coordinate} point Point to find adjusted resolution at.\n * @param {ol.proj.Units=} opt_units Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\n\n\n_ol_proj_.getPointResolution = function (projection, resolution, point, opt_units) {\n  projection = _ol_proj_.get(projection);\n  var pointResolution;\n  var getter = projection.getPointResolutionFunc();\n\n  if (getter) {\n    pointResolution = getter(resolution, point);\n  } else {\n    var units = projection.getUnits();\n\n    if (units == _ol_proj_Units_.DEGREES && !opt_units || opt_units == _ol_proj_Units_.DEGREES) {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      var toEPSG4326 = _ol_proj_.getTransformFromProjections(projection, _ol_proj_.get('EPSG:4326'));\n\n      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];\n      vertices = toEPSG4326(vertices, vertices, 2);\n\n      var width = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n\n      var height = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n\n      pointResolution = (width + height) / 2;\n      var metersPerUnit = opt_units ? _ol_proj_Units_.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();\n\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n\n  return pointResolution;\n};\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array.<ol.proj.Projection>} projections Projections.\n * @api\n */\n\n\n_ol_proj_.addEquivalentProjections = function (projections) {\n  _ol_proj_.addProjections(projections);\n\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        _ol_proj_transforms_.add(source, destination, _ol_proj_.cloneTransform);\n      }\n    });\n  });\n};\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array.<ol.proj.Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array.<ol.proj.Projection>} projections2 Projections with equal\n *     meaning.\n * @param {ol.TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {ol.TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\n\n\n_ol_proj_.addEquivalentTransforms = function (projections1, projections2, forwardTransform, inverseTransform) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      _ol_proj_transforms_.add(projection1, projection2, forwardTransform);\n\n      _ol_proj_transforms_.add(projection2, projection1, inverseTransform);\n    });\n  });\n};\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {ol.proj.Projection} projection Projection instance.\n * @api\n */\n\n\n_ol_proj_.addProjection = function (projection) {\n  _ol_proj_projections_.add(projection.getCode(), projection);\n\n  _ol_proj_transforms_.add(projection, projection, _ol_proj_.cloneTransform);\n};\n/**\n * @param {Array.<ol.proj.Projection>} projections Projections.\n */\n\n\n_ol_proj_.addProjections = function (projections) {\n  projections.forEach(_ol_proj_.addProjection);\n};\n/**\n * Clear all cached projections and transforms.\n */\n\n\n_ol_proj_.clearAllProjections = function () {\n  _ol_proj_projections_.clear();\n\n  _ol_proj_transforms_.clear();\n};\n/**\n * @param {ol.proj.Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {ol.proj.Projection} Projection.\n */\n\n\n_ol_proj_.createProjection = function (projection, defaultCode) {\n  if (!projection) {\n    return _ol_proj_.get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return _ol_proj_.get(projection);\n  } else {\n    return (\n      /** @type {ol.proj.Projection} */\n      projection\n    );\n  }\n};\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ol.ProjectionLike} source Source projection.\n * @param {ol.ProjectionLike} destination Destination projection.\n * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @api\n */\n\n\n_ol_proj_.addCoordinateTransforms = function (source, destination, forward, inverse) {\n  var sourceProj = _ol_proj_.get(source);\n\n  var destProj = _ol_proj_.get(destination);\n\n  _ol_proj_transforms_.add(sourceProj, destProj, _ol_proj_.createTransformFromCoordinateTransform(forward));\n\n  _ol_proj_transforms_.add(destProj, sourceProj, _ol_proj_.createTransformFromCoordinateTransform(inverse));\n};\n/**\n * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate\n *     transform.\n * @return {ol.TransformFunction} Transform function.\n */\n\n\n_ol_proj_.createTransformFromCoordinateTransform = function (transform) {\n  return (\n    /**\n     * @param {Array.<number>} input Input.\n     * @param {Array.<number>=} opt_output Output.\n     * @param {number=} opt_dimension Dimension.\n     * @return {Array.<number>} Output.\n     */\n    function (input, opt_output, opt_dimension) {\n      var length = input.length;\n      var dimension = opt_dimension !== undefined ? opt_dimension : 2;\n      var output = opt_output !== undefined ? opt_output : new Array(length);\n      var point, i, j;\n\n      for (i = 0; i < length; i += dimension) {\n        point = transform([input[i], input[i + 1]]);\n        output[i] = point[0];\n        output[i + 1] = point[1];\n\n        for (j = dimension - 1; j >= 2; --j) {\n          output[i + j] = input[i + j];\n        }\n      }\n\n      return output;\n    }\n  );\n};\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ol.ProjectionLike=} opt_projection Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate projected to the target projection.\n * @api\n */\n\n\n_ol_proj_.fromLonLat = function (coordinate, opt_projection) {\n  return _ol_proj_.transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');\n};\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {ol.Coordinate} coordinate Projected coordinate.\n * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\n\n\n_ol_proj_.toLonLat = function (coordinate, opt_projection) {\n  var lonLat = _ol_proj_.transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');\n\n  var lon = lonLat[0];\n\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = _ol_math_.modulo(lon + 180, 360) - 180;\n  }\n\n  return lonLat;\n};\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ol.ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {ol.proj.Projection} Projection object, or null if not in list.\n * @api\n */\n\n\n_ol_proj_.get = function (projectionLike) {\n  var projection = null;\n\n  if (projectionLike instanceof _ol_proj_Projection_) {\n    projection = projectionLike;\n  } else if (typeof projectionLike === 'string') {\n    var code = projectionLike;\n    projection = _ol_proj_projections_.get(code);\n\n    if (_ol_.ENABLE_PROJ4JS && !projection) {\n      var proj4js = _ol_proj_proj4_.get();\n\n      if (typeof proj4js == 'function' && proj4js.defs(code) !== undefined) {\n        projection = new _ol_proj_Projection_({\n          code: code\n        });\n\n        _ol_proj_.addProjection(projection);\n      }\n    }\n  }\n\n  return projection;\n};\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {ol.proj.Projection} projection1 Projection 1.\n * @param {ol.proj.Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\n\n\n_ol_proj_.equivalent = function (projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n\n  var equalUnits = projection1.getUnits() === projection2.getUnits();\n\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    var transformFn = _ol_proj_.getTransformFromProjections(projection1, projection2);\n\n    return transformFn === _ol_proj_.cloneTransform && equalUnits;\n  }\n};\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ol.ProjectionLike} source Source.\n * @param {ol.ProjectionLike} destination Destination.\n * @return {ol.TransformFunction} Transform function.\n * @api\n */\n\n\n_ol_proj_.getTransform = function (source, destination) {\n  var sourceProjection = _ol_proj_.get(source);\n\n  var destinationProjection = _ol_proj_.get(destination);\n\n  return _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);\n};\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {ol.proj.Projection} sourceProjection Source Projection object.\n * @param {ol.proj.Projection} destinationProjection Destination Projection\n *     object.\n * @return {ol.TransformFunction} Transform function.\n */\n\n\n_ol_proj_.getTransformFromProjections = function (sourceProjection, destinationProjection) {\n  var sourceCode = sourceProjection.getCode();\n  var destinationCode = destinationProjection.getCode();\n\n  var transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n\n  if (_ol_.ENABLE_PROJ4JS && !transform) {\n    var proj4js = _ol_proj_proj4_.get();\n\n    if (typeof proj4js == 'function') {\n      var sourceDef = proj4js.defs(sourceCode);\n      var destinationDef = proj4js.defs(destinationCode);\n\n      if (sourceDef !== undefined && destinationDef !== undefined) {\n        if (sourceDef === destinationDef) {\n          _ol_proj_.addEquivalentProjections([destinationProjection, sourceProjection]);\n        } else {\n          var proj4Transform = proj4js(destinationCode, sourceCode);\n\n          _ol_proj_.addCoordinateTransforms(destinationProjection, sourceProjection, proj4Transform.forward, proj4Transform.inverse);\n        }\n\n        transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n      }\n    }\n  }\n\n  if (!transform) {\n    transform = _ol_proj_.identityTransform;\n  }\n\n  return transform;\n};\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Input coordinate array (same array as input).\n */\n\n\n_ol_proj_.identityTransform = function (input, opt_output, opt_dimension) {\n  if (opt_output !== undefined && input !== opt_output) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n\n    input = opt_output;\n  }\n\n  return input;\n};\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\n\n\n_ol_proj_.cloneTransform = function (input, opt_output, opt_dimension) {\n  var output;\n\n  if (opt_output !== undefined) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n\n    output = opt_output;\n  } else {\n    output = input.slice();\n  }\n\n  return output;\n};\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link ol.proj.transformExtent} for extent transformation.\n * See the transform method of {@link ol.geom.Geometry} and its subclasses for\n * geometry transforms.\n *\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Coordinate} Coordinate.\n * @api\n */\n\n\n_ol_proj_.transform = function (coordinate, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n\n  return transformFn(coordinate, undefined, coordinate.length);\n};\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {ol.Extent} extent The extent to transform.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Extent} The transformed extent.\n * @api\n */\n\n\n_ol_proj_.transformExtent = function (extent, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n\n  return _ol_extent_.applyTransform(extent, transformFn);\n};\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {ol.Coordinate} point Point.\n * @param {ol.proj.Projection} sourceProjection Source projection.\n * @param {ol.proj.Projection} destinationProjection Destination projection.\n * @return {ol.Coordinate} Point.\n */\n\n\n_ol_proj_.transformWithProjections = function (point, sourceProjection, destinationProjection) {\n  var transformFn = _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);\n\n  return transformFn(point);\n};\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `ol.proj.clearAllProjections()` is called (e.g. in tests).\n */\n\n\n_ol_proj_.addCommon = function () {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG3857_.PROJECTIONS);\n\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG4326_.PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n\n\n  _ol_proj_.addEquivalentTransforms(_ol_proj_EPSG4326_.PROJECTIONS, _ol_proj_EPSG3857_.PROJECTIONS, _ol_proj_EPSG3857_.fromEPSG4326, _ol_proj_EPSG3857_.toEPSG4326);\n};\n\n_ol_proj_.addCommon();\n\nexport default _ol_proj_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/proj.js"],"names":["_ol_","_ol_Sphere_","_ol_extent_","_ol_math_","_ol_proj_EPSG3857_","_ol_proj_EPSG4326_","_ol_proj_Projection_","_ol_proj_Units_","_ol_proj_proj4_","_ol_proj_projections_","_ol_proj_transforms_","_ol_proj_","METERS_PER_UNIT","SPHERE_","DEFAULT_RADIUS","ENABLE_PROJ4JS","setProj4","proj4","set","getPointResolution","projection","resolution","point","opt_units","get","pointResolution","getter","getPointResolutionFunc","units","getUnits","DEGREES","toEPSG4326","getTransformFromProjections","vertices","width","haversineDistance","slice","height","metersPerUnit","getMetersPerUnit","undefined","addEquivalentProjections","projections","addProjections","forEach","source","destination","add","cloneTransform","addEquivalentTransforms","projections1","projections2","forwardTransform","inverseTransform","projection1","projection2","addProjection","getCode","clearAllProjections","clear","createProjection","defaultCode","addCoordinateTransforms","forward","inverse","sourceProj","destProj","createTransformFromCoordinateTransform","transform","input","opt_output","opt_dimension","length","dimension","output","Array","i","j","fromLonLat","coordinate","opt_projection","toLonLat","lonLat","lon","modulo","projectionLike","code","proj4js","defs","equivalent","equalUnits","transformFn","getTransform","sourceProjection","destinationProjection","sourceCode","destinationCode","sourceDef","destinationDef","proj4Transform","identityTransform","ii","transformExtent","extent","applyTransform","transformWithProjections","addCommon","PROJECTIONS","fromEPSG4326"],"mappings":"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","sourcesContent":["import _ol_ from './index.js';\nimport _ol_Sphere_ from './sphere.js';\nimport _ol_extent_ from './extent.js';\nimport _ol_math_ from './math.js';\nimport _ol_proj_EPSG3857_ from './proj/epsg3857.js';\nimport _ol_proj_EPSG4326_ from './proj/epsg4326.js';\nimport _ol_proj_Projection_ from './proj/projection.js';\nimport _ol_proj_Units_ from './proj/units.js';\nimport _ol_proj_proj4_ from './proj/proj4.js';\nimport _ol_proj_projections_ from './proj/projections.js';\nimport _ol_proj_transforms_ from './proj/transforms.js';\nvar _ol_proj_ = {};\n\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {Object.<ol.proj.Units, number>}\n * @api\n */\n_ol_proj_.METERS_PER_UNIT = _ol_proj_Units_.METERS_PER_UNIT;\n\n\n/**\n * A place to store the mean radius of the Earth.\n * @private\n * @type {ol.Sphere}\n */\n_ol_proj_.SPHERE_ = new _ol_Sphere_(_ol_Sphere_.DEFAULT_RADIUS);\n\n\nif (_ol_.ENABLE_PROJ4JS) {\n  /**\n   * Register proj4. If not explicitly registered, it will be assumed that\n   * proj4js will be loaded in the global namespace. For example in a\n   * browserify ES6 environment you could use:\n   *\n   *     import ol from 'openlayers';\n   *     import proj4 from 'proj4';\n   *     ol.proj.setProj4(proj4);\n   *\n   * @param {Proj4} proj4 Proj4.\n   * @api\n   */\n  _ol_proj_.setProj4 = function(proj4) {\n    _ol_proj_proj4_.set(proj4);\n  };\n}\n\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the 'point' pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link ol.proj.Projection} constructor or by using\n * {@link ol.proj.Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ol.ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {ol.Coordinate} point Point to find adjusted resolution at.\n * @param {ol.proj.Units=} opt_units Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\n_ol_proj_.getPointResolution = function(projection, resolution, point, opt_units) {\n  projection = _ol_proj_.get(projection);\n  var pointResolution;\n  var getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n  } else {\n    var units = projection.getUnits();\n    if (units == _ol_proj_Units_.DEGREES && !opt_units || opt_units == _ol_proj_Units_.DEGREES) {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      var toEPSG4326 = _ol_proj_.getTransformFromProjections(projection, _ol_proj_.get('EPSG:4326'));\n      var vertices = [\n        point[0] - resolution / 2, point[1],\n        point[0] + resolution / 2, point[1],\n        point[0], point[1] - resolution / 2,\n        point[0], point[1] + resolution / 2\n      ];\n      vertices = toEPSG4326(vertices, vertices, 2);\n      var width = _ol_proj_.SPHERE_.haversineDistance(\n          vertices.slice(0, 2), vertices.slice(2, 4));\n      var height = _ol_proj_.SPHERE_.haversineDistance(\n          vertices.slice(4, 6), vertices.slice(6, 8));\n      pointResolution = (width + height) / 2;\n      var metersPerUnit = opt_units ?\n        _ol_proj_Units_.METERS_PER_UNIT[opt_units] :\n        projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n};\n\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array.<ol.proj.Projection>} projections Projections.\n * @api\n */\n_ol_proj_.addEquivalentProjections = function(projections) {\n  _ol_proj_.addProjections(projections);\n  projections.forEach(function(source) {\n    projections.forEach(function(destination) {\n      if (source !== destination) {\n        _ol_proj_transforms_.add(source, destination, _ol_proj_.cloneTransform);\n      }\n    });\n  });\n};\n\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array.<ol.proj.Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array.<ol.proj.Projection>} projections2 Projections with equal\n *     meaning.\n * @param {ol.TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {ol.TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\n_ol_proj_.addEquivalentTransforms = function(projections1, projections2, forwardTransform, inverseTransform) {\n  projections1.forEach(function(projection1) {\n    projections2.forEach(function(projection2) {\n      _ol_proj_transforms_.add(projection1, projection2, forwardTransform);\n      _ol_proj_transforms_.add(projection2, projection1, inverseTransform);\n    });\n  });\n};\n\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {ol.proj.Projection} projection Projection instance.\n * @api\n */\n_ol_proj_.addProjection = function(projection) {\n  _ol_proj_projections_.add(projection.getCode(), projection);\n  _ol_proj_transforms_.add(projection, projection, _ol_proj_.cloneTransform);\n};\n\n\n/**\n * @param {Array.<ol.proj.Projection>} projections Projections.\n */\n_ol_proj_.addProjections = function(projections) {\n  projections.forEach(_ol_proj_.addProjection);\n};\n\n\n/**\n * Clear all cached projections and transforms.\n */\n_ol_proj_.clearAllProjections = function() {\n  _ol_proj_projections_.clear();\n  _ol_proj_transforms_.clear();\n};\n\n\n/**\n * @param {ol.proj.Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {ol.proj.Projection} Projection.\n */\n_ol_proj_.createProjection = function(projection, defaultCode) {\n  if (!projection) {\n    return _ol_proj_.get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return _ol_proj_.get(projection);\n  } else {\n    return /** @type {ol.proj.Projection} */ (projection);\n  }\n};\n\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ol.ProjectionLike} source Source projection.\n * @param {ol.ProjectionLike} destination Destination projection.\n * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @api\n */\n_ol_proj_.addCoordinateTransforms = function(source, destination, forward, inverse) {\n  var sourceProj = _ol_proj_.get(source);\n  var destProj = _ol_proj_.get(destination);\n  _ol_proj_transforms_.add(sourceProj, destProj,\n      _ol_proj_.createTransformFromCoordinateTransform(forward));\n  _ol_proj_transforms_.add(destProj, sourceProj,\n      _ol_proj_.createTransformFromCoordinateTransform(inverse));\n};\n\n\n/**\n * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate\n *     transform.\n * @return {ol.TransformFunction} Transform function.\n */\n_ol_proj_.createTransformFromCoordinateTransform = function(transform) {\n  return (\n    /**\n     * @param {Array.<number>} input Input.\n     * @param {Array.<number>=} opt_output Output.\n     * @param {number=} opt_dimension Dimension.\n     * @return {Array.<number>} Output.\n     */\n    function(input, opt_output, opt_dimension) {\n      var length = input.length;\n      var dimension = opt_dimension !== undefined ? opt_dimension : 2;\n      var output = opt_output !== undefined ? opt_output : new Array(length);\n      var point, i, j;\n      for (i = 0; i < length; i += dimension) {\n        point = transform([input[i], input[i + 1]]);\n        output[i] = point[0];\n        output[i + 1] = point[1];\n        for (j = dimension - 1; j >= 2; --j) {\n          output[i + j] = input[i + j];\n        }\n      }\n      return output;\n    });\n};\n\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ol.ProjectionLike=} opt_projection Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate projected to the target projection.\n * @api\n */\n_ol_proj_.fromLonLat = function(coordinate, opt_projection) {\n  return _ol_proj_.transform(coordinate, 'EPSG:4326',\n      opt_projection !== undefined ? opt_projection : 'EPSG:3857');\n};\n\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {ol.Coordinate} coordinate Projected coordinate.\n * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\n_ol_proj_.toLonLat = function(coordinate, opt_projection) {\n  var lonLat = _ol_proj_.transform(coordinate,\n      opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');\n  var lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = _ol_math_.modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n};\n\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ol.ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {ol.proj.Projection} Projection object, or null if not in list.\n * @api\n */\n_ol_proj_.get = function(projectionLike) {\n  var projection = null;\n  if (projectionLike instanceof _ol_proj_Projection_) {\n    projection = projectionLike;\n  } else if (typeof projectionLike === 'string') {\n    var code = projectionLike;\n    projection = _ol_proj_projections_.get(code);\n    if (_ol_.ENABLE_PROJ4JS && !projection) {\n      var proj4js = _ol_proj_proj4_.get();\n      if (typeof proj4js == 'function' &&\n          proj4js.defs(code) !== undefined) {\n        projection = new _ol_proj_Projection_({code: code});\n        _ol_proj_.addProjection(projection);\n      }\n    }\n  }\n  return projection;\n};\n\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {ol.proj.Projection} projection1 Projection 1.\n * @param {ol.proj.Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\n_ol_proj_.equivalent = function(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  var equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    var transformFn = _ol_proj_.getTransformFromProjections(\n        projection1, projection2);\n    return transformFn === _ol_proj_.cloneTransform && equalUnits;\n  }\n};\n\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ol.ProjectionLike} source Source.\n * @param {ol.ProjectionLike} destination Destination.\n * @return {ol.TransformFunction} Transform function.\n * @api\n */\n_ol_proj_.getTransform = function(source, destination) {\n  var sourceProjection = _ol_proj_.get(source);\n  var destinationProjection = _ol_proj_.get(destination);\n  return _ol_proj_.getTransformFromProjections(\n      sourceProjection, destinationProjection);\n};\n\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {ol.proj.Projection} sourceProjection Source Projection object.\n * @param {ol.proj.Projection} destinationProjection Destination Projection\n *     object.\n * @return {ol.TransformFunction} Transform function.\n */\n_ol_proj_.getTransformFromProjections = function(sourceProjection, destinationProjection) {\n  var sourceCode = sourceProjection.getCode();\n  var destinationCode = destinationProjection.getCode();\n  var transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n  if (_ol_.ENABLE_PROJ4JS && !transform) {\n    var proj4js = _ol_proj_proj4_.get();\n    if (typeof proj4js == 'function') {\n      var sourceDef = proj4js.defs(sourceCode);\n      var destinationDef = proj4js.defs(destinationCode);\n\n      if (sourceDef !== undefined && destinationDef !== undefined) {\n        if (sourceDef === destinationDef) {\n          _ol_proj_.addEquivalentProjections([destinationProjection, sourceProjection]);\n        } else {\n          var proj4Transform = proj4js(destinationCode, sourceCode);\n          _ol_proj_.addCoordinateTransforms(destinationProjection, sourceProjection,\n              proj4Transform.forward, proj4Transform.inverse);\n        }\n        transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n      }\n    }\n  }\n  if (!transform) {\n    transform = _ol_proj_.identityTransform;\n  }\n  return transform;\n};\n\n\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Input coordinate array (same array as input).\n */\n_ol_proj_.identityTransform = function(input, opt_output, opt_dimension) {\n  if (opt_output !== undefined && input !== opt_output) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    input = opt_output;\n  }\n  return input;\n};\n\n\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\n_ol_proj_.cloneTransform = function(input, opt_output, opt_dimension) {\n  var output;\n  if (opt_output !== undefined) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    output = opt_output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n};\n\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link ol.proj.transformExtent} for extent transformation.\n * See the transform method of {@link ol.geom.Geometry} and its subclasses for\n * geometry transforms.\n *\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Coordinate} Coordinate.\n * @api\n */\n_ol_proj_.transform = function(coordinate, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n  return transformFn(coordinate, undefined, coordinate.length);\n};\n\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {ol.Extent} extent The extent to transform.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Extent} The transformed extent.\n * @api\n */\n_ol_proj_.transformExtent = function(extent, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n  return _ol_extent_.applyTransform(extent, transformFn);\n};\n\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {ol.Coordinate} point Point.\n * @param {ol.proj.Projection} sourceProjection Source projection.\n * @param {ol.proj.Projection} destinationProjection Destination projection.\n * @return {ol.Coordinate} Point.\n */\n_ol_proj_.transformWithProjections = function(point, sourceProjection, destinationProjection) {\n  var transformFn = _ol_proj_.getTransformFromProjections(\n      sourceProjection, destinationProjection);\n  return transformFn(point);\n};\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `ol.proj.clearAllProjections()` is called (e.g. in tests).\n */\n_ol_proj_.addCommon = function() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG3857_.PROJECTIONS);\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG4326_.PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  _ol_proj_.addEquivalentTransforms(\n      _ol_proj_EPSG4326_.PROJECTIONS,\n      _ol_proj_EPSG3857_.PROJECTIONS,\n      _ol_proj_EPSG3857_.fromEPSG4326,\n      _ol_proj_EPSG3857_.toEPSG4326);\n};\n\n_ol_proj_.addCommon();\nexport default _ol_proj_;\n"]},"metadata":{},"sourceType":"module"}
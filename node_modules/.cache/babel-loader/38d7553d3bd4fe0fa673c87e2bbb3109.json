{"ast":null,"code":"import _ol_ from '../../index.js';\nimport _ol_extent_ from '../../extent.js';\nimport _ol_obj_ from '../../obj.js';\nimport _ol_render_webgl_texturereplay_defaultshader_ from '../webgl/texturereplay/defaultshader.js';\nimport _ol_render_webgl_texturereplay_defaultshader_Locations_ from '../webgl/texturereplay/defaultshader/locations.js';\nimport _ol_render_webgl_Replay_ from '../webgl/replay.js';\nimport _ol_webgl_ from '../../webgl.js';\nimport _ol_webgl_Context_ from '../../webgl/context.js';\n/**\n * @constructor\n * @abstract\n * @extends {ol.render.webgl.Replay}\n * @param {number} tolerance Tolerance.\n * @param {ol.Extent} maxExtent Max extent.\n * @struct\n */\n\nvar _ol_render_webgl_TextureReplay_ = function (tolerance, maxExtent) {\n  _ol_render_webgl_Replay_.call(this, tolerance, maxExtent);\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n\n\n  this.anchorX = undefined;\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n\n  this.anchorY = undefined;\n  /**\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this.groupIndices = [];\n  /**\n   * @type {Array.<number>}\n   * @protected\n   */\n\n  this.hitDetectionGroupIndices = [];\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n\n  this.height = undefined;\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n\n  this.imageHeight = undefined;\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n\n  this.imageWidth = undefined;\n  /**\n   * @protected\n   * @type {ol.render.webgl.texturereplay.defaultshader.Locations}\n   */\n\n  this.defaultLocations = null;\n  /**\n   * @protected\n   * @type {number|undefined}\n   */\n\n  this.opacity = undefined;\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n\n  this.originX = undefined;\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n\n  this.originY = undefined;\n  /**\n   * @protected\n   * @type {boolean|undefined}\n   */\n\n  this.rotateWithView = undefined;\n  /**\n   * @protected\n   * @type {number|undefined}\n   */\n\n  this.rotation = undefined;\n  /**\n   * @protected\n   * @type {number|undefined}\n   */\n\n  this.scale = undefined;\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n\n  this.width = undefined;\n};\n\n_ol_.inherits(_ol_render_webgl_TextureReplay_, _ol_render_webgl_Replay_);\n/**\n * @inheritDoc\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.getDeleteResourcesFunction = function (context) {\n  var verticesBuffer = this.verticesBuffer;\n  var indicesBuffer = this.indicesBuffer;\n  var textures = this.getTextures(true);\n  var gl = context.getGL();\n  return function () {\n    if (!gl.isContextLost()) {\n      var i, ii;\n\n      for (i = 0, ii = textures.length; i < ii; ++i) {\n        gl.deleteTexture(textures[i]);\n      }\n    }\n\n    context.deleteBuffer(verticesBuffer);\n    context.deleteBuffer(indicesBuffer);\n  };\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} My end.\n * @protected\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.drawCoordinates = function (flatCoordinates, offset, end, stride) {\n  var anchorX =\n  /** @type {number} */\n  this.anchorX;\n  var anchorY =\n  /** @type {number} */\n  this.anchorY;\n  var height =\n  /** @type {number} */\n  this.height;\n  var imageHeight =\n  /** @type {number} */\n  this.imageHeight;\n  var imageWidth =\n  /** @type {number} */\n  this.imageWidth;\n  var opacity =\n  /** @type {number} */\n  this.opacity;\n  var originX =\n  /** @type {number} */\n  this.originX;\n  var originY =\n  /** @type {number} */\n  this.originY;\n  var rotateWithView = this.rotateWithView ? 1.0 : 0.0; // this.rotation_ is anti-clockwise, but rotation is clockwise\n\n  var rotation =\n  /** @type {number} */\n  -this.rotation;\n  var scale =\n  /** @type {number} */\n  this.scale;\n  var width =\n  /** @type {number} */\n  this.width;\n  var cos = Math.cos(rotation);\n  var sin = Math.sin(rotation);\n  var numIndices = this.indices.length;\n  var numVertices = this.vertices.length;\n  var i, n, offsetX, offsetY, x, y;\n\n  for (i = offset; i < end; i += stride) {\n    x = flatCoordinates[i] - this.origin[0];\n    y = flatCoordinates[i + 1] - this.origin[1]; // There are 4 vertices per [x, y] point, one for each corner of the\n    // rectangle we're going to draw. We'd use 1 vertex per [x, y] point if\n    // WebGL supported Geometry Shaders (which can emit new vertices), but that\n    // is not currently the case.\n    //\n    // And each vertex includes 8 values: the x and y coordinates, the x and\n    // y offsets used to calculate the position of the corner, the u and\n    // v texture coordinates for the corner, the opacity, and whether the\n    // the image should be rotated with the view (rotateWithView).\n\n    n = numVertices / 8; // bottom-left corner\n\n    offsetX = -scale * anchorX;\n    offsetY = -scale * (height - anchorY);\n    this.vertices[numVertices++] = x;\n    this.vertices[numVertices++] = y;\n    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n    this.vertices[numVertices++] = originX / imageWidth;\n    this.vertices[numVertices++] = (originY + height) / imageHeight;\n    this.vertices[numVertices++] = opacity;\n    this.vertices[numVertices++] = rotateWithView; // bottom-right corner\n\n    offsetX = scale * (width - anchorX);\n    offsetY = -scale * (height - anchorY);\n    this.vertices[numVertices++] = x;\n    this.vertices[numVertices++] = y;\n    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n    this.vertices[numVertices++] = (originX + width) / imageWidth;\n    this.vertices[numVertices++] = (originY + height) / imageHeight;\n    this.vertices[numVertices++] = opacity;\n    this.vertices[numVertices++] = rotateWithView; // top-right corner\n\n    offsetX = scale * (width - anchorX);\n    offsetY = scale * anchorY;\n    this.vertices[numVertices++] = x;\n    this.vertices[numVertices++] = y;\n    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n    this.vertices[numVertices++] = (originX + width) / imageWidth;\n    this.vertices[numVertices++] = originY / imageHeight;\n    this.vertices[numVertices++] = opacity;\n    this.vertices[numVertices++] = rotateWithView; // top-left corner\n\n    offsetX = -scale * anchorX;\n    offsetY = scale * anchorY;\n    this.vertices[numVertices++] = x;\n    this.vertices[numVertices++] = y;\n    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n    this.vertices[numVertices++] = originX / imageWidth;\n    this.vertices[numVertices++] = originY / imageHeight;\n    this.vertices[numVertices++] = opacity;\n    this.vertices[numVertices++] = rotateWithView;\n    this.indices[numIndices++] = n;\n    this.indices[numIndices++] = n + 1;\n    this.indices[numIndices++] = n + 2;\n    this.indices[numIndices++] = n;\n    this.indices[numIndices++] = n + 2;\n    this.indices[numIndices++] = n + 3;\n  }\n\n  return numVertices;\n};\n/**\n * @protected\n * @param {Array.<WebGLTexture>} textures Textures.\n * @param {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>} images\n *    Images.\n * @param {Object.<string, WebGLTexture>} texturePerImage Texture cache.\n * @param {WebGLRenderingContext} gl Gl.\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.createTextures = function (textures, images, texturePerImage, gl) {\n  var texture, image, uid, i;\n  var ii = images.length;\n\n  for (i = 0; i < ii; ++i) {\n    image = images[i];\n    uid = _ol_.getUid(image).toString();\n\n    if (uid in texturePerImage) {\n      texture = texturePerImage[uid];\n    } else {\n      texture = _ol_webgl_Context_.createTexture(gl, image, _ol_webgl_.CLAMP_TO_EDGE, _ol_webgl_.CLAMP_TO_EDGE);\n      texturePerImage[uid] = texture;\n    }\n\n    textures[i] = texture;\n  }\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {\n  // get the program\n  var fragmentShader = _ol_render_webgl_texturereplay_defaultshader_.fragment;\n  var vertexShader = _ol_render_webgl_texturereplay_defaultshader_.vertex;\n  var program = context.getProgram(fragmentShader, vertexShader); // get the locations\n\n  var locations;\n\n  if (!this.defaultLocations) {\n    locations = new _ol_render_webgl_texturereplay_defaultshader_Locations_(gl, program);\n    this.defaultLocations = locations;\n  } else {\n    locations = this.defaultLocations;\n  } // use the program (FIXME: use the return value)\n\n\n  context.useProgram(program); // enable the vertex attrib arrays\n\n  gl.enableVertexAttribArray(locations.a_position);\n  gl.vertexAttribPointer(locations.a_position, 2, _ol_webgl_.FLOAT, false, 32, 0);\n  gl.enableVertexAttribArray(locations.a_offsets);\n  gl.vertexAttribPointer(locations.a_offsets, 2, _ol_webgl_.FLOAT, false, 32, 8);\n  gl.enableVertexAttribArray(locations.a_texCoord);\n  gl.vertexAttribPointer(locations.a_texCoord, 2, _ol_webgl_.FLOAT, false, 32, 16);\n  gl.enableVertexAttribArray(locations.a_opacity);\n  gl.vertexAttribPointer(locations.a_opacity, 1, _ol_webgl_.FLOAT, false, 32, 24);\n  gl.enableVertexAttribArray(locations.a_rotateWithView);\n  gl.vertexAttribPointer(locations.a_rotateWithView, 1, _ol_webgl_.FLOAT, false, 32, 28);\n  return locations;\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.shutDownProgram = function (gl, locations) {\n  gl.disableVertexAttribArray(locations.a_position);\n  gl.disableVertexAttribArray(locations.a_offsets);\n  gl.disableVertexAttribArray(locations.a_texCoord);\n  gl.disableVertexAttribArray(locations.a_opacity);\n  gl.disableVertexAttribArray(locations.a_rotateWithView);\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {\n  var textures = hitDetection ? this.getHitDetectionTextures() : this.getTextures();\n  var groupIndices = hitDetection ? this.hitDetectionGroupIndices : this.groupIndices;\n\n  if (!_ol_obj_.isEmpty(skippedFeaturesHash)) {\n    this.drawReplaySkipping(gl, context, skippedFeaturesHash, textures, groupIndices);\n  } else {\n    var i, ii, start;\n\n    for (i = 0, ii = textures.length, start = 0; i < ii; ++i) {\n      gl.bindTexture(_ol_webgl_.TEXTURE_2D, textures[i]);\n      var end = groupIndices[i];\n      this.drawElements(gl, context, start, end);\n      start = end;\n    }\n  }\n};\n/**\n * Draw the replay while paying attention to skipped features.\n *\n * This functions creates groups of features that can be drawn to together,\n * so that the number of `drawElements` calls is minimized.\n *\n * For example given the following texture groups:\n *\n *    Group 1: A B C\n *    Group 2: D [E] F G\n *\n * If feature E should be skipped, the following `drawElements` calls will be\n * made:\n *\n *    drawElements with feature A, B and C\n *    drawElements with feature D\n *    drawElements with feature F and G\n *\n * @protected\n * @param {WebGLRenderingContext} gl gl.\n * @param {ol.webgl.Context} context Context.\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n *  to skip.\n * @param {Array.<WebGLTexture>} textures Textures.\n * @param {Array.<number>} groupIndices Texture group indices.\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.drawReplaySkipping = function (gl, context, skippedFeaturesHash, textures, groupIndices) {\n  var featureIndex = 0;\n  var i, ii;\n\n  for (i = 0, ii = textures.length; i < ii; ++i) {\n    gl.bindTexture(_ol_webgl_.TEXTURE_2D, textures[i]);\n    var groupStart = i > 0 ? groupIndices[i - 1] : 0;\n    var groupEnd = groupIndices[i];\n    var start = groupStart;\n    var end = groupStart;\n\n    while (featureIndex < this.startIndices.length && this.startIndices[featureIndex] <= groupEnd) {\n      var feature = this.startIndicesFeature[featureIndex];\n\n      var featureUid = _ol_.getUid(feature).toString();\n\n      if (skippedFeaturesHash[featureUid] !== undefined) {\n        // feature should be skipped\n        if (start !== end) {\n          // draw the features so far\n          this.drawElements(gl, context, start, end);\n        } // continue with the next feature\n\n\n        start = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];\n        end = start;\n      } else {\n        // the feature is not skipped, augment the end index\n        end = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];\n      }\n\n      featureIndex++;\n    }\n\n    if (start !== end) {\n      // draw the remaining features (in case there was no skipped feature\n      // in this texture group, all features of a group are drawn together)\n      this.drawElements(gl, context, start, end);\n    }\n  }\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {\n  var i, groupStart, start, end, feature, featureUid;\n  var featureIndex = this.startIndices.length - 1;\n  var hitDetectionTextures = this.getHitDetectionTextures();\n\n  for (i = hitDetectionTextures.length - 1; i >= 0; --i) {\n    gl.bindTexture(_ol_webgl_.TEXTURE_2D, hitDetectionTextures[i]);\n    groupStart = i > 0 ? this.hitDetectionGroupIndices[i - 1] : 0;\n    end = this.hitDetectionGroupIndices[i]; // draw all features for this texture group\n\n    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {\n      start = this.startIndices[featureIndex];\n      feature = this.startIndicesFeature[featureIndex];\n      featureUid = _ol_.getUid(feature).toString();\n\n      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _ol_extent_.intersects(\n      /** @type {Array<number>} */\n      opt_hitExtent, feature.getGeometry().getExtent()))) {\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        this.drawElements(gl, context, start, end);\n        var result = featureCallback(feature);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      end = start;\n      featureIndex--;\n    }\n  }\n\n  return undefined;\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.finish = function (context) {\n  this.anchorX = undefined;\n  this.anchorY = undefined;\n  this.height = undefined;\n  this.imageHeight = undefined;\n  this.imageWidth = undefined;\n  this.indices = null;\n  this.opacity = undefined;\n  this.originX = undefined;\n  this.originY = undefined;\n  this.rotateWithView = undefined;\n  this.rotation = undefined;\n  this.scale = undefined;\n  this.vertices = null;\n  this.width = undefined;\n};\n/**\n * @abstract\n * @protected\n * @param {boolean=} opt_all Return hit detection textures with regular ones.\n * @returns {Array.<WebGLTexture>} Textures.\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.getTextures = function (opt_all) {};\n/**\n * @abstract\n * @protected\n * @returns {Array.<WebGLTexture>} Textures.\n */\n\n\n_ol_render_webgl_TextureReplay_.prototype.getHitDetectionTextures = function () {};\n\nexport default _ol_render_webgl_TextureReplay_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/render/webgl/texturereplay.js"],"names":["_ol_","_ol_extent_","_ol_obj_","_ol_render_webgl_texturereplay_defaultshader_","_ol_render_webgl_texturereplay_defaultshader_Locations_","_ol_render_webgl_Replay_","_ol_webgl_","_ol_webgl_Context_","_ol_render_webgl_TextureReplay_","tolerance","maxExtent","call","anchorX","undefined","anchorY","groupIndices","hitDetectionGroupIndices","height","imageHeight","imageWidth","defaultLocations","opacity","originX","originY","rotateWithView","rotation","scale","width","inherits","prototype","getDeleteResourcesFunction","context","verticesBuffer","indicesBuffer","textures","getTextures","gl","getGL","isContextLost","i","ii","length","deleteTexture","deleteBuffer","drawCoordinates","flatCoordinates","offset","end","stride","cos","Math","sin","numIndices","indices","numVertices","vertices","n","offsetX","offsetY","x","y","origin","createTextures","images","texturePerImage","texture","image","uid","getUid","toString","createTexture","CLAMP_TO_EDGE","setUpProgram","size","pixelRatio","fragmentShader","fragment","vertexShader","vertex","program","getProgram","locations","useProgram","enableVertexAttribArray","a_position","vertexAttribPointer","FLOAT","a_offsets","a_texCoord","a_opacity","a_rotateWithView","shutDownProgram","disableVertexAttribArray","drawReplay","skippedFeaturesHash","hitDetection","getHitDetectionTextures","isEmpty","drawReplaySkipping","start","bindTexture","TEXTURE_2D","drawElements","featureIndex","groupStart","groupEnd","startIndices","feature","startIndicesFeature","featureUid","drawHitDetectionReplayOneByOne","featureCallback","opt_hitExtent","hitDetectionTextures","getGeometry","intersects","getExtent","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","result","finish","opt_all"],"mappings":"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","sourcesContent":["import _ol_ from '../../index.js';\nimport _ol_extent_ from '../../extent.js';\nimport _ol_obj_ from '../../obj.js';\nimport _ol_render_webgl_texturereplay_defaultshader_ from '../webgl/texturereplay/defaultshader.js';\nimport _ol_render_webgl_texturereplay_defaultshader_Locations_ from '../webgl/texturereplay/defaultshader/locations.js';\nimport _ol_render_webgl_Replay_ from '../webgl/replay.js';\nimport _ol_webgl_ from '../../webgl.js';\nimport _ol_webgl_Context_ from '../../webgl/context.js';\n\n/**\n * @constructor\n * @abstract\n * @extends {ol.render.webgl.Replay}\n * @param {number} tolerance Tolerance.\n * @param {ol.Extent} maxExtent Max extent.\n * @struct\n */\nvar _ol_render_webgl_TextureReplay_ = function(tolerance, maxExtent) {\n  _ol_render_webgl_Replay_.call(this, tolerance, maxExtent);\n\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n  this.anchorX = undefined;\n\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n  this.anchorY = undefined;\n\n  /**\n   * @type {Array.<number>}\n   * @protected\n   */\n  this.groupIndices = [];\n\n  /**\n   * @type {Array.<number>}\n   * @protected\n   */\n  this.hitDetectionGroupIndices = [];\n\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n  this.height = undefined;\n\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n  this.imageHeight = undefined;\n\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n  this.imageWidth = undefined;\n\n  /**\n   * @protected\n   * @type {ol.render.webgl.texturereplay.defaultshader.Locations}\n   */\n  this.defaultLocations = null;\n\n  /**\n   * @protected\n   * @type {number|undefined}\n   */\n  this.opacity = undefined;\n\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n  this.originX = undefined;\n\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n  this.originY = undefined;\n\n  /**\n   * @protected\n   * @type {boolean|undefined}\n   */\n  this.rotateWithView = undefined;\n\n  /**\n   * @protected\n   * @type {number|undefined}\n   */\n  this.rotation = undefined;\n\n  /**\n   * @protected\n   * @type {number|undefined}\n   */\n  this.scale = undefined;\n\n  /**\n   * @type {number|undefined}\n   * @protected\n   */\n  this.width = undefined;\n};\n\n_ol_.inherits(_ol_render_webgl_TextureReplay_, _ol_render_webgl_Replay_);\n\n\n/**\n * @inheritDoc\n */\n_ol_render_webgl_TextureReplay_.prototype.getDeleteResourcesFunction = function(context) {\n  var verticesBuffer = this.verticesBuffer;\n  var indicesBuffer = this.indicesBuffer;\n  var textures = this.getTextures(true);\n  var gl = context.getGL();\n  return function() {\n    if (!gl.isContextLost()) {\n      var i, ii;\n      for (i = 0, ii = textures.length; i < ii; ++i) {\n        gl.deleteTexture(textures[i]);\n      }\n    }\n    context.deleteBuffer(verticesBuffer);\n    context.deleteBuffer(indicesBuffer);\n  };\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} My end.\n * @protected\n */\n_ol_render_webgl_TextureReplay_.prototype.drawCoordinates = function(flatCoordinates, offset, end, stride) {\n  var anchorX = /** @type {number} */ (this.anchorX);\n  var anchorY = /** @type {number} */ (this.anchorY);\n  var height = /** @type {number} */ (this.height);\n  var imageHeight = /** @type {number} */ (this.imageHeight);\n  var imageWidth = /** @type {number} */ (this.imageWidth);\n  var opacity = /** @type {number} */ (this.opacity);\n  var originX = /** @type {number} */ (this.originX);\n  var originY = /** @type {number} */ (this.originY);\n  var rotateWithView = this.rotateWithView ? 1.0 : 0.0;\n  // this.rotation_ is anti-clockwise, but rotation is clockwise\n  var rotation = /** @type {number} */ (-this.rotation);\n  var scale = /** @type {number} */ (this.scale);\n  var width = /** @type {number} */ (this.width);\n  var cos = Math.cos(rotation);\n  var sin = Math.sin(rotation);\n  var numIndices = this.indices.length;\n  var numVertices = this.vertices.length;\n  var i, n, offsetX, offsetY, x, y;\n  for (i = offset; i < end; i += stride) {\n    x = flatCoordinates[i] - this.origin[0];\n    y = flatCoordinates[i + 1] - this.origin[1];\n\n    // There are 4 vertices per [x, y] point, one for each corner of the\n    // rectangle we're going to draw. We'd use 1 vertex per [x, y] point if\n    // WebGL supported Geometry Shaders (which can emit new vertices), but that\n    // is not currently the case.\n    //\n    // And each vertex includes 8 values: the x and y coordinates, the x and\n    // y offsets used to calculate the position of the corner, the u and\n    // v texture coordinates for the corner, the opacity, and whether the\n    // the image should be rotated with the view (rotateWithView).\n\n    n = numVertices / 8;\n\n    // bottom-left corner\n    offsetX = -scale * anchorX;\n    offsetY = -scale * (height - anchorY);\n    this.vertices[numVertices++] = x;\n    this.vertices[numVertices++] = y;\n    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n    this.vertices[numVertices++] = originX / imageWidth;\n    this.vertices[numVertices++] = (originY + height) / imageHeight;\n    this.vertices[numVertices++] = opacity;\n    this.vertices[numVertices++] = rotateWithView;\n\n    // bottom-right corner\n    offsetX = scale * (width - anchorX);\n    offsetY = -scale * (height - anchorY);\n    this.vertices[numVertices++] = x;\n    this.vertices[numVertices++] = y;\n    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n    this.vertices[numVertices++] = (originX + width) / imageWidth;\n    this.vertices[numVertices++] = (originY + height) / imageHeight;\n    this.vertices[numVertices++] = opacity;\n    this.vertices[numVertices++] = rotateWithView;\n\n    // top-right corner\n    offsetX = scale * (width - anchorX);\n    offsetY = scale * anchorY;\n    this.vertices[numVertices++] = x;\n    this.vertices[numVertices++] = y;\n    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n    this.vertices[numVertices++] = (originX + width) / imageWidth;\n    this.vertices[numVertices++] = originY / imageHeight;\n    this.vertices[numVertices++] = opacity;\n    this.vertices[numVertices++] = rotateWithView;\n\n    // top-left corner\n    offsetX = -scale * anchorX;\n    offsetY = scale * anchorY;\n    this.vertices[numVertices++] = x;\n    this.vertices[numVertices++] = y;\n    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;\n    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;\n    this.vertices[numVertices++] = originX / imageWidth;\n    this.vertices[numVertices++] = originY / imageHeight;\n    this.vertices[numVertices++] = opacity;\n    this.vertices[numVertices++] = rotateWithView;\n\n    this.indices[numIndices++] = n;\n    this.indices[numIndices++] = n + 1;\n    this.indices[numIndices++] = n + 2;\n    this.indices[numIndices++] = n;\n    this.indices[numIndices++] = n + 2;\n    this.indices[numIndices++] = n + 3;\n  }\n\n  return numVertices;\n};\n\n\n/**\n * @protected\n * @param {Array.<WebGLTexture>} textures Textures.\n * @param {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>} images\n *    Images.\n * @param {Object.<string, WebGLTexture>} texturePerImage Texture cache.\n * @param {WebGLRenderingContext} gl Gl.\n */\n_ol_render_webgl_TextureReplay_.prototype.createTextures = function(textures, images, texturePerImage, gl) {\n  var texture, image, uid, i;\n  var ii = images.length;\n  for (i = 0; i < ii; ++i) {\n    image = images[i];\n\n    uid = _ol_.getUid(image).toString();\n    if (uid in texturePerImage) {\n      texture = texturePerImage[uid];\n    } else {\n      texture = _ol_webgl_Context_.createTexture(\n          gl, image, _ol_webgl_.CLAMP_TO_EDGE, _ol_webgl_.CLAMP_TO_EDGE);\n      texturePerImage[uid] = texture;\n    }\n    textures[i] = texture;\n  }\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_webgl_TextureReplay_.prototype.setUpProgram = function(gl, context, size, pixelRatio) {\n  // get the program\n  var fragmentShader = _ol_render_webgl_texturereplay_defaultshader_.fragment;\n  var vertexShader = _ol_render_webgl_texturereplay_defaultshader_.vertex;\n  var program = context.getProgram(fragmentShader, vertexShader);\n\n  // get the locations\n  var locations;\n  if (!this.defaultLocations) {\n    locations = new _ol_render_webgl_texturereplay_defaultshader_Locations_(gl, program);\n    this.defaultLocations = locations;\n  } else {\n    locations = this.defaultLocations;\n  }\n\n  // use the program (FIXME: use the return value)\n  context.useProgram(program);\n\n  // enable the vertex attrib arrays\n  gl.enableVertexAttribArray(locations.a_position);\n  gl.vertexAttribPointer(locations.a_position, 2, _ol_webgl_.FLOAT,\n      false, 32, 0);\n\n  gl.enableVertexAttribArray(locations.a_offsets);\n  gl.vertexAttribPointer(locations.a_offsets, 2, _ol_webgl_.FLOAT,\n      false, 32, 8);\n\n  gl.enableVertexAttribArray(locations.a_texCoord);\n  gl.vertexAttribPointer(locations.a_texCoord, 2, _ol_webgl_.FLOAT,\n      false, 32, 16);\n\n  gl.enableVertexAttribArray(locations.a_opacity);\n  gl.vertexAttribPointer(locations.a_opacity, 1, _ol_webgl_.FLOAT,\n      false, 32, 24);\n\n  gl.enableVertexAttribArray(locations.a_rotateWithView);\n  gl.vertexAttribPointer(locations.a_rotateWithView, 1, _ol_webgl_.FLOAT,\n      false, 32, 28);\n\n  return locations;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_webgl_TextureReplay_.prototype.shutDownProgram = function(gl, locations) {\n  gl.disableVertexAttribArray(locations.a_position);\n  gl.disableVertexAttribArray(locations.a_offsets);\n  gl.disableVertexAttribArray(locations.a_texCoord);\n  gl.disableVertexAttribArray(locations.a_opacity);\n  gl.disableVertexAttribArray(locations.a_rotateWithView);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_webgl_TextureReplay_.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {\n  var textures = hitDetection ? this.getHitDetectionTextures() : this.getTextures();\n  var groupIndices = hitDetection ? this.hitDetectionGroupIndices : this.groupIndices;\n\n  if (!_ol_obj_.isEmpty(skippedFeaturesHash)) {\n    this.drawReplaySkipping(\n        gl, context, skippedFeaturesHash, textures, groupIndices);\n  } else {\n    var i, ii, start;\n    for (i = 0, ii = textures.length, start = 0; i < ii; ++i) {\n      gl.bindTexture(_ol_webgl_.TEXTURE_2D, textures[i]);\n      var end = groupIndices[i];\n      this.drawElements(gl, context, start, end);\n      start = end;\n    }\n  }\n};\n\n\n/**\n * Draw the replay while paying attention to skipped features.\n *\n * This functions creates groups of features that can be drawn to together,\n * so that the number of `drawElements` calls is minimized.\n *\n * For example given the following texture groups:\n *\n *    Group 1: A B C\n *    Group 2: D [E] F G\n *\n * If feature E should be skipped, the following `drawElements` calls will be\n * made:\n *\n *    drawElements with feature A, B and C\n *    drawElements with feature D\n *    drawElements with feature F and G\n *\n * @protected\n * @param {WebGLRenderingContext} gl gl.\n * @param {ol.webgl.Context} context Context.\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n *  to skip.\n * @param {Array.<WebGLTexture>} textures Textures.\n * @param {Array.<number>} groupIndices Texture group indices.\n */\n_ol_render_webgl_TextureReplay_.prototype.drawReplaySkipping = function(gl, context, skippedFeaturesHash, textures,\n    groupIndices) {\n  var featureIndex = 0;\n\n  var i, ii;\n  for (i = 0, ii = textures.length; i < ii; ++i) {\n    gl.bindTexture(_ol_webgl_.TEXTURE_2D, textures[i]);\n    var groupStart = (i > 0) ? groupIndices[i - 1] : 0;\n    var groupEnd = groupIndices[i];\n\n    var start = groupStart;\n    var end = groupStart;\n    while (featureIndex < this.startIndices.length &&\n        this.startIndices[featureIndex] <= groupEnd) {\n      var feature = this.startIndicesFeature[featureIndex];\n\n      var featureUid = _ol_.getUid(feature).toString();\n      if (skippedFeaturesHash[featureUid] !== undefined) {\n        // feature should be skipped\n        if (start !== end) {\n          // draw the features so far\n          this.drawElements(gl, context, start, end);\n        }\n        // continue with the next feature\n        start = (featureIndex === this.startIndices.length - 1) ?\n          groupEnd : this.startIndices[featureIndex + 1];\n        end = start;\n      } else {\n        // the feature is not skipped, augment the end index\n        end = (featureIndex === this.startIndices.length - 1) ?\n          groupEnd : this.startIndices[featureIndex + 1];\n      }\n      featureIndex++;\n    }\n\n    if (start !== end) {\n      // draw the remaining features (in case there was no skipped feature\n      // in this texture group, all features of a group are drawn together)\n      this.drawElements(gl, context, start, end);\n    }\n  }\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_webgl_TextureReplay_.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash,\n    featureCallback, opt_hitExtent) {\n  var i, groupStart, start, end, feature, featureUid;\n  var featureIndex = this.startIndices.length - 1;\n  var hitDetectionTextures = this.getHitDetectionTextures();\n  for (i = hitDetectionTextures.length - 1; i >= 0; --i) {\n    gl.bindTexture(_ol_webgl_.TEXTURE_2D, hitDetectionTextures[i]);\n    groupStart = (i > 0) ? this.hitDetectionGroupIndices[i - 1] : 0;\n    end = this.hitDetectionGroupIndices[i];\n\n    // draw all features for this texture group\n    while (featureIndex >= 0 &&\n        this.startIndices[featureIndex] >= groupStart) {\n      start = this.startIndices[featureIndex];\n      feature = this.startIndicesFeature[featureIndex];\n      featureUid = _ol_.getUid(feature).toString();\n\n      if (skippedFeaturesHash[featureUid] === undefined &&\n          feature.getGeometry() &&\n          (opt_hitExtent === undefined || _ol_extent_.intersects(\n              /** @type {Array<number>} */ (opt_hitExtent),\n              feature.getGeometry().getExtent()))) {\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        this.drawElements(gl, context, start, end);\n\n        var result = featureCallback(feature);\n        if (result) {\n          return result;\n        }\n      }\n\n      end = start;\n      featureIndex--;\n    }\n  }\n  return undefined;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_webgl_TextureReplay_.prototype.finish = function(context) {\n  this.anchorX = undefined;\n  this.anchorY = undefined;\n  this.height = undefined;\n  this.imageHeight = undefined;\n  this.imageWidth = undefined;\n  this.indices = null;\n  this.opacity = undefined;\n  this.originX = undefined;\n  this.originY = undefined;\n  this.rotateWithView = undefined;\n  this.rotation = undefined;\n  this.scale = undefined;\n  this.vertices = null;\n  this.width = undefined;\n};\n\n\n/**\n * @abstract\n * @protected\n * @param {boolean=} opt_all Return hit detection textures with regular ones.\n * @returns {Array.<WebGLTexture>} Textures.\n */\n_ol_render_webgl_TextureReplay_.prototype.getTextures = function(opt_all) {};\n\n\n/**\n * @abstract\n * @protected\n * @returns {Array.<WebGLTexture>} Textures.\n */\n_ol_render_webgl_TextureReplay_.prototype.getHitDetectionTextures = function() {};\nexport default _ol_render_webgl_TextureReplay_;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/webgl/TileLayer\n */\n\n\nimport LRUCache from '../../structs/LRUCache.js';\nimport State from '../../source/State.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport { AttributeType } from '../../webgl/Helper.js';\nimport { ELEMENT_ARRAY_BUFFER, STATIC_DRAW } from '../../webgl.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\nimport { create as createMat4, fromTransform as mat4FromTransform } from '../../vec/mat4.js';\nimport { createOrUpdate as createTileCoord, getKeyZXY, getKey as getTileCoordKey } from '../../tilecoord.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getIntersection } from '../../extent.js';\nimport { getUid } from '../../util.js';\nimport { isEmpty } from '../../extent.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\nexport var Uniforms = {\n  TILE_TEXTURE_PREFIX: 'u_tileTexture',\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom'\n};\nexport var Attributes = {\n  TEXTURE_COORD: 'a_textureCoord'\n};\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\n\nvar attributeDescriptions = [{\n  name: Attributes.TEXTURE_COORD,\n  size: 2,\n  type: AttributeType.FLOAT\n}];\nvar empty = {};\n/**\n * Transform a zoom level into a depth value ranging from -1 to 1.\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\n\nfunction depthForZ(z) {\n  return 2 * (1 - 1 / (z + 1)) - 1;\n}\n/**\n * Add a tile texture to the lookup.\n * @param {Object<string, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n * tile textures by zoom level.\n * @param {import(\"../../webgl/TileTexture.js\").default} tileTexture A tile texture.\n * @param {number} z The zoom level.\n */\n\n\nfunction addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {\n  if (!(z in tileTexturesByZ)) {\n    tileTexturesByZ[z] = [];\n  }\n\n  tileTexturesByZ[z].push(tileTexture);\n}\n/**\n * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\n\n\nfunction getRenderExtent(frameState, extent) {\n  var layerState = frameState.layerStatesArray[frameState.layerIndex];\n\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n\n  return extent;\n}\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @api\n */\n\n\nvar WebGLTileLayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(WebGLTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/WebGLTile.js\").default} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n\n\n  function WebGLTileLayerRenderer(tileLayer, options) {\n    var _this = _super.call(this, tileLayer, {\n      uniforms: options.uniforms,\n      className: options.className\n    }) || this;\n    /**\n     * This transform converts tile i, j coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n\n\n    _this.tileTransform_ = createTransform();\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    _this.tempMat4_ = createMat4();\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n\n    _this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n\n    _this.tempTileCoord_ = createTileCoord(0, 0, 0);\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n\n    _this.tempSize_ = [0, 0];\n    _this.program_ = _this.helper.getProgram(options.fragmentShader, options.vertexShader);\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     */\n\n    var indices = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    indices.fromArray([0, 1, 3, 1, 2, 3]);\n\n    _this.helper.flushBufferData(indices);\n\n    _this.indices_ = indices;\n    var cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../webgl/TileTexture.js\").default>}\n     * @private\n     */\n\n    _this.tileTextureCache_ = new LRUCache(cacheSize);\n    _this.renderedOpacity_ = NaN;\n    return _this;\n  }\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n\n  WebGLTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    var tileLayer = this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  WebGLTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n\n    var source = this.getLayer().getSource();\n\n    if (!source) {\n      return false;\n    }\n\n    return source.getState() === State.READY;\n  };\n\n  WebGLTileLayerRenderer.prototype.enqueueTiles = function (frameState, extent, z, tileTexturesByZ) {\n    var viewState = frameState.viewState;\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    var tileTextureCache = this.tileTextureCache_;\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    var tileSourceKey = getUid(tileSource);\n\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileResolution = tileGrid.getResolution(z);\n\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        var tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n        var tileCoordKey = getTileCoordKey(tileCoord);\n        var tileTexture = void 0,\n            tile = void 0;\n\n        if (tileTextureCache.containsKey(tileCoordKey)) {\n          tileTexture = tileTextureCache.get(tileCoordKey);\n          tile = tileTexture.tile;\n        }\n\n        if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {\n          tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);\n\n          if (!tileTexture) {\n            tileTexture = new TileTexture(tile, tileGrid, this.helper);\n            tileTextureCache.set(tileCoordKey, tileTexture);\n          } else {\n            tileTexture.setTile(this.isDrawableTile(tile) ? tile : tile.getInterimTile());\n          }\n        }\n\n        addTileTextureToLookup(tileTexturesByZ, tileTexture, z);\n        var tileQueueKey = tile.getKey();\n        wantedTiles[tileQueueKey] = true;\n\n        if (tile.getState() === TileState.IDLE) {\n          if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n            frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  WebGLTileLayerRenderer.prototype.renderFrame = function (frameState) {\n    this.preRender(frameState);\n    var viewState = frameState.viewState;\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var extent = getRenderExtent(frameState, frameState.extent);\n    var tileLayer = this.getLayer();\n    var tileSource = tileLayer.getSource();\n    var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n    /**\n     * @type {Object<string, Array<import(\"../../webgl/TileTexture.js\").default>>}\n     */\n\n    var tileTexturesByZ = {};\n\n    if (frameState.nextExtent) {\n      var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      var nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileTexturesByZ);\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n\n    var alphaLookup = {};\n    var uid = getUid(this);\n    var time = frameState.time;\n    var blend = false; // look for cached tiles to use if a target tile is not ready\n\n    var tileTextures = tileTexturesByZ[z];\n\n    for (var i = 0, ii = tileTextures.length; i < ii; ++i) {\n      var tileTexture = tileTextures[i];\n      var tile = tileTexture.tile;\n      var tileCoord = tile.tileCoord;\n\n      if (tileTexture.loaded) {\n        var alpha = tile.getAlpha(uid, time);\n\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n\n        blend = true;\n        var tileCoordKey = getTileCoordKey(tileCoord);\n        alphaLookup[tileCoordKey] = alpha;\n      } // first look for child tiles (at z + 1)\n\n\n      var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);\n\n      if (coveredByChildren) {\n        continue;\n      } // next look for parent tiles\n\n\n      for (var parentZ = z - 1; parentZ >= tileGrid.minZoom; --parentZ) {\n        var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    this.helper.useProgram(this.program_);\n    this.helper.prepareDraw(frameState, !blend);\n    var zs = Object.keys(tileTexturesByZ).map(Number).sort(numberSafeCompareFunction);\n    var gl = this.helper.getGL();\n    var centerX = viewState.center[0];\n    var centerY = viewState.center[1];\n\n    for (var j = 0, jj = zs.length; j < jj; ++j) {\n      var tileZ = zs[j];\n      var tileResolution = tileGrid.getResolution(tileZ);\n      var tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n      var tileOrigin = tileGrid.getOrigin(tileZ);\n      var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n      var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n      var tileScale = viewState.resolution / tileResolution;\n      var depth = depthForZ(tileZ);\n      var tileTextures_1 = tileTexturesByZ[tileZ];\n\n      for (var i = 0, ii = tileTextures_1.length; i < ii; ++i) {\n        var tileTexture = tileTextures_1[i];\n\n        if (!tileTexture.loaded) {\n          continue;\n        }\n\n        var tile = tileTexture.tile;\n        var tileCoord = tile.tileCoord;\n        var tileCoordKey = getTileCoordKey(tileCoord);\n        var tileCenterI = tileCoord[1];\n        var tileCenterJ = tileCoord[2];\n        composeTransform(this.tileTransform_, 0, 0, 2 / (frameState.size[0] * tileScale / tileSize[0]), -2 / (frameState.size[1] * tileScale / tileSize[1]), viewState.rotation, -(centerI - tileCenterI), -(centerJ - tileCenterJ));\n        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, mat4FromTransform(this.tempMat4_, this.tileTransform_));\n        this.helper.bindBuffer(tileTexture.coords);\n        this.helper.bindBuffer(this.indices_);\n        this.helper.enableAttributes(attributeDescriptions);\n\n        for (var textureIndex = 0; textureIndex < tileTexture.textures.length; ++textureIndex) {\n          var textureProperty = 'TEXTURE' + textureIndex;\n          var uniformName = Uniforms.TILE_TEXTURE_PREFIX + textureIndex;\n          gl.activeTexture(gl[textureProperty]);\n          gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureIndex]);\n          gl.uniform1i(this.helper.getUniformLocation(uniformName), textureIndex);\n        }\n\n        var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n        if (alpha < 1) {\n          frameState.animate = true;\n        }\n\n        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileSize[0]);\n        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileSize[1]);\n        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n        this.helper.drawElements(0, this.indices_.getSize());\n      }\n    }\n\n    this.helper.finalizeDraw(frameState);\n    var canvas = this.helper.getCanvas();\n    var opacity = layerState.opacity;\n\n    if (this.renderedOpacity_ !== opacity) {\n      canvas.style.opacity = String(opacity);\n      this.renderedOpacity_ = opacity;\n    }\n\n    var tileTextureCache = this.tileTextureCache_;\n\n    while (tileTextureCache.canExpireCache()) {\n      var tileTexture = tileTextureCache.pop();\n      tileTexture.dispose();\n    } // TODO: let the renderers manage their own cache instead of managing the source cache\n\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../PluggableMap.js\").default} map Map.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     */\n\n\n    var postRenderFunction = function (map, frameState) {\n      tileSource.expireCache(tileSource.getProjection(), empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n    this.postRender(frameState);\n    return canvas;\n  };\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {Object<string, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n   * tile textures by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n\n\n  WebGLTileLayerRenderer.prototype.findAltTiles_ = function (tileGrid, tileCoord, altZ, tileTexturesByZ) {\n    var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n\n    if (!tileRange) {\n      return false;\n    }\n\n    var covered = true;\n    var tileTextureCache = this.tileTextureCache_;\n\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        var cacheKey = getKeyZXY(altZ, x, y);\n        var loaded = false;\n\n        if (tileTextureCache.containsKey(cacheKey)) {\n          var tileTexture = tileTextureCache.get(cacheKey);\n\n          if (tileTexture.loaded) {\n            addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);\n            loaded = true;\n          }\n        }\n\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n\n    return covered;\n  };\n  /**\n   * Clean up.\n   */\n\n\n  WebGLTileLayerRenderer.prototype.disposeInternal = function () {\n    var helper = this.helper;\n    var gl = helper.getGL();\n    helper.deleteBuffer(this.indices_);\n    delete this.indices_;\n    gl.deleteProgram(this.program_);\n    delete this.program_;\n    var tileTextureCache = this.tileTextureCache_;\n    tileTextureCache.forEach(function (tileTexture) {\n      tileTexture.dispose();\n    });\n    tileTextureCache.clear();\n    delete this.tileTextureCache_;\n\n    _super.prototype.disposeInternal.call(this);\n  };\n\n  return WebGLTileLayerRenderer;\n}(WebGLLayerRenderer);\n/**\n * @function\n * @return {import(\"../../layer/WebGLTile.js\").default}\n */\n\n\nWebGLTileLayerRenderer.prototype.getLayer;\nexport default WebGLTileLayerRenderer;","map":{"version":3,"sources":["../../src/renderer/webgl/TileLayer.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEG;;;AACH,OAAO,QAAP,MAAqB,2BAArB;AACA,OAAO,KAAP,MAAkB,uBAAlB;AACA,OAAO,SAAP,MAAsB,oBAAtB;AACA,OAAO,SAAP,MAAsB,oBAAtB;AACA,OAAO,WAAP,MAAwB,4BAAxB;AACA,OAAO,gBAAP,MAA6B,uBAA7B;AACA,OAAO,kBAAP,MAA+B,YAA/B;AACA,SAAQ,aAAR,QAA4B,uBAA5B;AACA,SAAQ,oBAAR,EAA8B,WAA9B,QAAgD,gBAAhD;AACA,SACE,OAAO,IAAI,gBADb,EAEE,MAAM,IAAI,eAFZ,QAGO,oBAHP;AAIA,SACE,MAAM,IAAI,UADZ,EAEE,aAAa,IAAI,iBAFnB,QAGO,mBAHP;AAIA,SACE,cAAc,IAAI,eADpB,EAEE,SAFF,EAGE,MAAM,IAAI,eAHZ,QAIO,oBAJP;AAKA,SAAQ,cAAR,QAA6B,eAA7B;AACA,SAAQ,eAAR,QAA8B,iBAA9B;AACA,SAAQ,MAAR,QAAqB,eAArB;AACA,SAAQ,OAAR,QAAsB,iBAAtB;AACA,SAAQ,yBAAR,QAAwC,gBAAxC;AACA,SAAQ,MAAR,QAAqB,eAArB;AAEA,OAAO,IAAM,QAAQ,GAAG;AACtB,EAAA,mBAAmB,EAAE,eADC;AAEtB,EAAA,cAAc,EAAE,iBAFM;AAGtB,EAAA,gBAAgB,EAAE,mBAHI;AAItB,EAAA,KAAK,EAAE,SAJe;AAKtB,EAAA,mBAAmB,EAAE,qBALC;AAMtB,EAAA,oBAAoB,EAAE,sBANA;AAOtB,EAAA,UAAU,EAAE,cAPU;AAQtB,EAAA,IAAI,EAAE;AARgB,CAAjB;AAWP,OAAO,IAAM,UAAU,GAAG;AACxB,EAAA,aAAa,EAAE;AADS,CAAnB;AAIP;;AAEG;;AACH,IAAM,qBAAqB,GAAG,CAC5B;AACE,EAAA,IAAI,EAAE,UAAU,CAAC,aADnB;AAEE,EAAA,IAAI,EAAE,CAFR;AAGE,EAAA,IAAI,EAAE,aAAa,CAAC;AAHtB,CAD4B,CAA9B;AAQA,IAAM,KAAK,GAAG,EAAd;AAEA;;;;AAIG;;AACH,SAAS,SAAT,CAAmB,CAAnB,EAAoB;AAClB,SAAO,KAAK,IAAI,KAAK,CAAC,GAAG,CAAT,CAAT,IAAwB,CAA/B;AACD;AAED;;;;;;AAMG;;;AACH,SAAS,sBAAT,CAAgC,eAAhC,EAAiD,WAAjD,EAA8D,CAA9D,EAA+D;AAC7D,MAAI,EAAE,CAAC,IAAI,eAAP,CAAJ,EAA6B;AAC3B,IAAA,eAAe,CAAC,CAAD,CAAf,GAAqB,EAArB;AACD;;AACD,EAAA,eAAe,CAAC,CAAD,CAAf,CAAmB,IAAnB,CAAwB,WAAxB;AACD;AAED;;;;AAIG;;;AACH,SAAS,eAAT,CAAyB,UAAzB,EAAqC,MAArC,EAA2C;AACzC,MAAM,UAAU,GAAG,UAAU,CAAC,gBAAX,CAA4B,UAAU,CAAC,UAAvC,CAAnB;;AACA,MAAI,UAAU,CAAC,MAAf,EAAuB;AACrB,IAAA,MAAM,GAAG,eAAe,CACtB,MADsB,EAEtB,cAAc,CAAC,UAAU,CAAC,MAAZ,EAAoB,UAAU,CAAC,SAAX,CAAqB,UAAzC,CAFQ,CAAxB;AAID;;AACD,SAAO,MAAP;AACD;AAED;;;;;;;;AAQG;;AAEH;;;;AAIG;;;AACH,IAAA,sBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAqC,EAAA,SAAA,CAAA,sBAAA,EAAA,MAAA,CAAA;AACnC;;;AAGG;;;AACH,WAAA,sBAAA,CAAY,SAAZ,EAAuB,OAAvB,EAA8B;AAA9B,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,SAAN,EAAiB;AACf,MAAA,QAAQ,EAAE,OAAO,CAAC,QADH;AAEf,MAAA,SAAS,EAAE,OAAO,CAAC;AAFJ,KAAjB,KAGE,IAJJ;AAME;;;;AAIG;;;AACH,IAAA,KAAI,CAAC,cAAL,GAAsB,eAAe,EAArC;AAEA;;;AAGG;;AACH,IAAA,KAAI,CAAC,SAAL,GAAiB,UAAU,EAA3B;AAEA;;;AAGG;;AACH,IAAA,KAAI,CAAC,cAAL,GAAsB,IAAI,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,CAAtB;AAEA;;;AAGG;;AACH,IAAA,KAAI,CAAC,cAAL,GAAsB,eAAe,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAArC;AAEA;;;AAGG;;AACH,IAAA,KAAI,CAAC,SAAL,GAAiB,CAAC,CAAD,EAAI,CAAJ,CAAjB;AAEA,IAAA,KAAI,CAAC,QAAL,GAAgB,KAAI,CAAC,MAAL,CAAY,UAAZ,CACd,OAAO,CAAC,cADM,EAEd,OAAO,CAAC,YAFM,CAAhB;AAKA;;;;;;;;;;;;;;AAcG;;AACH,QAAM,OAAO,GAAG,IAAI,gBAAJ,CAAqB,oBAArB,EAA2C,WAA3C,CAAhB;AACA,IAAA,OAAO,CAAC,SAAR,CAAkB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAAlB;;AACA,IAAA,KAAI,CAAC,MAAL,CAAY,eAAZ,CAA4B,OAA5B;;AACA,IAAA,KAAI,CAAC,QAAL,GAAgB,OAAhB;AAEA,QAAM,SAAS,GAAG,OAAO,CAAC,SAAR,KAAsB,SAAtB,GAAkC,OAAO,CAAC,SAA1C,GAAsD,GAAxE;AAEA;;;AAGG;;AACH,IAAA,KAAI,CAAC,iBAAL,GAAyB,IAAI,QAAJ,CAAa,SAAb,CAAzB;AAEA,IAAA,KAAI,CAAC,gBAAL,GAAwB,GAAxB;;AACD;AAED;;;;AAIG;;;AACH,EAAA,sBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,IAAf,EAAmB;AACjB,QAAM,SAAS,GAAG,KAAK,QAAL,EAAlB;AACA,QAAM,SAAS,GAAG,IAAI,CAAC,QAAL,EAAlB;AACA,QAAM,sBAAsB,GAAG,SAAS,CAAC,yBAAV,EAA/B;AACA,WACE,SAAS,IAAI,SAAS,CAAC,MAAvB,IACA,SAAS,IAAI,SAAS,CAAC,KADvB,IAEC,SAAS,IAAI,SAAS,CAAC,KAAvB,IAAgC,CAAC,sBAHpC;AAKD,GATD;AAWA;;;;AAIG;;;AACH,EAAA,sBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,UAAb,EAAuB;AACrB,QAAI,OAAO,CAAC,eAAe,CAAC,UAAD,EAAa,UAAU,CAAC,MAAxB,CAAhB,CAAX,EAA6D;AAC3D,aAAO,KAAP;AACD;;AACD,QAAM,MAAM,GAAG,KAAK,QAAL,GAAgB,SAAhB,EAAf;;AACA,QAAI,CAAC,MAAL,EAAa;AACX,aAAO,KAAP;AACD;;AACD,WAAO,MAAM,CAAC,QAAP,OAAsB,KAAK,CAAC,KAAnC;AACD,GATD;;AAWA,EAAA,sBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,UAAb,EAAyB,MAAzB,EAAiC,CAAjC,EAAoC,eAApC,EAAmD;AACjD,QAAM,SAAS,GAAG,UAAU,CAAC,SAA7B;AACA,QAAM,SAAS,GAAG,KAAK,QAAL,EAAlB;AACA,QAAM,UAAU,GAAG,SAAS,CAAC,SAAV,EAAnB;AACA,QAAM,QAAQ,GAAG,UAAU,CAAC,wBAAX,CAAoC,SAAS,CAAC,UAA9C,CAAjB;AACA,QAAM,gBAAgB,GAAG,KAAK,iBAA9B;AACA,QAAM,SAAS,GAAG,QAAQ,CAAC,yBAAT,CAAmC,MAAnC,EAA2C,CAA3C,CAAlB;AAEA,QAAM,aAAa,GAAG,MAAM,CAAC,UAAD,CAA5B;;AACA,QAAI,EAAE,aAAa,IAAI,UAAU,CAAC,WAA9B,CAAJ,EAAgD;AAC9C,MAAA,UAAU,CAAC,WAAX,CAAuB,aAAvB,IAAwC,EAAxC;AACD;;AAED,QAAM,WAAW,GAAG,UAAU,CAAC,WAAX,CAAuB,aAAvB,CAApB;AAEA,QAAM,cAAc,GAAG,QAAQ,CAAC,aAAT,CAAuB,CAAvB,CAAvB;;AAEA,SAAK,IAAI,CAAC,GAAG,SAAS,CAAC,IAAvB,EAA6B,CAAC,IAAI,SAAS,CAAC,IAA5C,EAAkD,EAAE,CAApD,EAAuD;AACrD,WAAK,IAAI,CAAC,GAAG,SAAS,CAAC,IAAvB,EAA6B,CAAC,IAAI,SAAS,CAAC,IAA5C,EAAkD,EAAE,CAApD,EAAuD;AACrD,YAAM,SAAS,GAAG,eAAe,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,KAAK,cAAf,CAAjC;AACA,YAAM,YAAY,GAAG,eAAe,CAAC,SAAD,CAApC;AAEA,YAAI,WAAW,GAAA,KAAA,CAAf;AAAA,YAAiB,IAAI,GAAA,KAAA,CAArB;;AACA,YAAI,gBAAgB,CAAC,WAAjB,CAA6B,YAA7B,CAAJ,EAAgD;AAC9C,UAAA,WAAW,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,YAArB,CAAd;AACA,UAAA,IAAI,GAAG,WAAW,CAAC,IAAnB;AACD;;AACD,YAAI,CAAC,WAAD,IAAgB,WAAW,CAAC,IAAZ,CAAiB,GAAjB,KAAyB,UAAU,CAAC,MAAX,EAA7C,EAAkE;AAChE,UAAA,IAAI,GAAG,UAAU,CAAC,OAAX,CACL,CADK,EAEL,CAFK,EAGL,CAHK,EAIL,UAAU,CAAC,UAJN,EAKL,SAAS,CAAC,UALL,CAAP;;AAOA,cAAI,CAAC,WAAL,EAAkB;AAChB,YAAA,WAAW,GAAG,IAAI,WAAJ,CAAgB,IAAhB,EAAsB,QAAtB,EAAgC,KAAK,MAArC,CAAd;AACA,YAAA,gBAAgB,CAAC,GAAjB,CAAqB,YAArB,EAAmC,WAAnC;AACD,WAHD,MAGO;AACL,YAAA,WAAW,CAAC,OAAZ,CACE,KAAK,cAAL,CAAoB,IAApB,IAA4B,IAA5B,GAAmC,IAAI,CAAC,cAAL,EADrC;AAGD;AACF;;AAED,QAAA,sBAAsB,CAAC,eAAD,EAAkB,WAAlB,EAA+B,CAA/B,CAAtB;AAEA,YAAM,YAAY,GAAG,IAAI,CAAC,MAAL,EAArB;AACA,QAAA,WAAW,CAAC,YAAD,CAAX,GAA4B,IAA5B;;AAEA,YAAI,IAAI,CAAC,QAAL,OAAoB,SAAS,CAAC,IAAlC,EAAwC;AACtC,cAAI,CAAC,UAAU,CAAC,SAAX,CAAqB,WAArB,CAAiC,YAAjC,CAAL,EAAqD;AACnD,YAAA,UAAU,CAAC,SAAX,CAAqB,OAArB,CAA6B,CAC3B,IAD2B,EAE3B,aAF2B,EAG3B,QAAQ,CAAC,kBAAT,CAA4B,SAA5B,CAH2B,EAI3B,cAJ2B,CAA7B;AAMD;AACF;AACF;AACF;AACF,GA9DD;AAgEA;;;;AAIG;;;AACH,EAAA,sBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,UAAZ,EAAsB;AACpB,SAAK,SAAL,CAAe,UAAf;AAEA,QAAM,SAAS,GAAG,UAAU,CAAC,SAA7B;AACA,QAAM,UAAU,GAAG,UAAU,CAAC,gBAAX,CAA4B,UAAU,CAAC,UAAvC,CAAnB;AACA,QAAM,MAAM,GAAG,eAAe,CAAC,UAAD,EAAa,UAAU,CAAC,MAAxB,CAA9B;AACA,QAAM,SAAS,GAAG,KAAK,QAAL,EAAlB;AACA,QAAM,UAAU,GAAG,SAAS,CAAC,SAAV,EAAnB;AACA,QAAM,QAAQ,GAAG,UAAU,CAAC,wBAAX,CAAoC,SAAS,CAAC,UAA9C,CAAjB;AACA,QAAM,CAAC,GAAG,QAAQ,CAAC,iBAAT,CACR,SAAS,CAAC,UADF,EAER,UAAU,CAAC,UAFH,CAAV;AAKA;;AAEG;;AACH,QAAM,eAAe,GAAG,EAAxB;;AAEA,QAAI,UAAU,CAAC,UAAf,EAA2B;AACzB,UAAM,OAAO,GAAG,QAAQ,CAAC,iBAAT,CACd,SAAS,CAAC,cADI,EAEd,UAAU,CAAC,UAFG,CAAhB;AAIA,UAAM,UAAU,GAAG,eAAe,CAAC,UAAD,EAAa,UAAU,CAAC,UAAxB,CAAlC;AACA,WAAK,YAAL,CAAkB,UAAlB,EAA8B,UAA9B,EAA0C,OAA1C,EAAmD,eAAnD;AACD;;AAED,SAAK,YAAL,CAAkB,UAAlB,EAA8B,MAA9B,EAAsC,CAAtC,EAAyC,eAAzC;AAEA;;;;;AAKG;;AACH,QAAM,WAAW,GAAG,EAApB;AAEA,QAAM,GAAG,GAAG,MAAM,CAAC,IAAD,CAAlB;AACA,QAAM,IAAI,GAAG,UAAU,CAAC,IAAxB;AACA,QAAI,KAAK,GAAG,KAAZ,CAxCoB,CA0CpB;;AACA,QAAM,YAAY,GAAG,eAAe,CAAC,CAAD,CAApC;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,YAAY,CAAC,MAAlC,EAA0C,CAAC,GAAG,EAA9C,EAAkD,EAAE,CAApD,EAAuD;AACrD,UAAM,WAAW,GAAG,YAAY,CAAC,CAAD,CAAhC;AACA,UAAM,IAAI,GAAG,WAAW,CAAC,IAAzB;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,SAAvB;;AAEA,UAAI,WAAW,CAAC,MAAhB,EAAwB;AACtB,YAAM,KAAK,GAAG,IAAI,CAAC,QAAL,CAAc,GAAd,EAAmB,IAAnB,CAAd;;AACA,YAAI,KAAK,KAAK,CAAd,EAAiB;AACf;AACA,UAAA,IAAI,CAAC,aAAL,CAAmB,GAAnB;AACA;AACD;;AACD,QAAA,KAAK,GAAG,IAAR;AACA,YAAM,YAAY,GAAG,eAAe,CAAC,SAAD,CAApC;AACA,QAAA,WAAW,CAAC,YAAD,CAAX,GAA4B,KAA5B;AACD,OAfoD,CAiBrD;;;AACA,UAAM,iBAAiB,GAAG,KAAK,aAAL,CACxB,QADwB,EAExB,SAFwB,EAGxB,CAAC,GAAG,CAHoB,EAIxB,eAJwB,CAA1B;;AAOA,UAAI,iBAAJ,EAAuB;AACrB;AACD,OA3BoD,CA6BrD;;;AACA,WAAK,IAAI,OAAO,GAAG,CAAC,GAAG,CAAvB,EAA0B,OAAO,IAAI,QAAQ,CAAC,OAA9C,EAAuD,EAAE,OAAzD,EAAkE;AAChE,YAAM,eAAe,GAAG,KAAK,aAAL,CACtB,QADsB,EAEtB,SAFsB,EAGtB,OAHsB,EAItB,eAJsB,CAAxB;;AAOA,YAAI,eAAJ,EAAqB;AACnB;AACD;AACF;AACF;;AAED,SAAK,MAAL,CAAY,UAAZ,CAAuB,KAAK,QAA5B;AACA,SAAK,MAAL,CAAY,WAAZ,CAAwB,UAAxB,EAAoC,CAAC,KAArC;AAEA,QAAM,EAAE,GAAG,MAAM,CAAC,IAAP,CAAY,eAAZ,EACR,GADQ,CACJ,MADI,EAER,IAFQ,CAEH,yBAFG,CAAX;AAIA,QAAM,EAAE,GAAG,KAAK,MAAL,CAAY,KAAZ,EAAX;AAEA,QAAM,OAAO,GAAG,SAAS,CAAC,MAAV,CAAiB,CAAjB,CAAhB;AACA,QAAM,OAAO,GAAG,SAAS,CAAC,MAAV,CAAiB,CAAjB,CAAhB;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,EAAE,CAAC,MAAxB,EAAgC,CAAC,GAAG,EAApC,EAAwC,EAAE,CAA1C,EAA6C;AAC3C,UAAM,KAAK,GAAG,EAAE,CAAC,CAAD,CAAhB;AACA,UAAM,cAAc,GAAG,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAvB;AACA,UAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,WAAT,CAAqB,KAArB,CAAD,EAA8B,KAAK,SAAnC,CAAvB;AACA,UAAM,UAAU,GAAG,QAAQ,CAAC,SAAT,CAAmB,KAAnB,CAAnB;AAEA,UAAM,OAAO,GACX,CAAC,OAAO,GAAG,UAAU,CAAC,CAAD,CAArB,KAA6B,QAAQ,CAAC,CAAD,CAAR,GAAc,cAA3C,CADF;AAEA,UAAM,OAAO,GACX,CAAC,UAAU,CAAC,CAAD,CAAV,GAAgB,OAAjB,KAA6B,QAAQ,CAAC,CAAD,CAAR,GAAc,cAA3C,CADF;AAGA,UAAM,SAAS,GAAG,SAAS,CAAC,UAAV,GAAuB,cAAzC;AAEA,UAAM,KAAK,GAAG,SAAS,CAAC,KAAD,CAAvB;AACA,UAAM,cAAY,GAAG,eAAe,CAAC,KAAD,CAApC;;AACA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,cAAY,CAAC,MAAlC,EAA0C,CAAC,GAAG,EAA9C,EAAkD,EAAE,CAApD,EAAuD;AACrD,YAAM,WAAW,GAAG,cAAY,CAAC,CAAD,CAAhC;;AACA,YAAI,CAAC,WAAW,CAAC,MAAjB,EAAyB;AACvB;AACD;;AACD,YAAM,IAAI,GAAG,WAAW,CAAC,IAAzB;AACA,YAAM,SAAS,GAAG,IAAI,CAAC,SAAvB;AACA,YAAM,YAAY,GAAG,eAAe,CAAC,SAAD,CAApC;AAEA,YAAM,WAAW,GAAG,SAAS,CAAC,CAAD,CAA7B;AACA,YAAM,WAAW,GAAG,SAAS,CAAC,CAAD,CAA7B;AAEA,QAAA,gBAAgB,CACd,KAAK,cADS,EAEd,CAFc,EAGd,CAHc,EAId,KAAM,UAAU,CAAC,IAAX,CAAgB,CAAhB,IAAqB,SAAtB,GAAmC,QAAQ,CAAC,CAAD,CAAhD,CAJc,EAKd,CAAC,CAAD,IAAO,UAAU,CAAC,IAAX,CAAgB,CAAhB,IAAqB,SAAtB,GAAmC,QAAQ,CAAC,CAAD,CAAjD,CALc,EAMd,SAAS,CAAC,QANI,EAOd,EAAE,OAAO,GAAG,WAAZ,CAPc,EAQd,EAAE,OAAO,GAAG,WAAZ,CARc,CAAhB;AAWA,aAAK,MAAL,CAAY,qBAAZ,CACE,QAAQ,CAAC,cADX,EAEE,iBAAiB,CAAC,KAAK,SAAN,EAAiB,KAAK,cAAtB,CAFnB;AAKA,aAAK,MAAL,CAAY,UAAZ,CAAuB,WAAW,CAAC,MAAnC;AACA,aAAK,MAAL,CAAY,UAAZ,CAAuB,KAAK,QAA5B;AACA,aAAK,MAAL,CAAY,gBAAZ,CAA6B,qBAA7B;;AAEA,aACE,IAAI,YAAY,GAAG,CADrB,EAEE,YAAY,GAAG,WAAW,CAAC,QAAZ,CAAqB,MAFtC,EAGE,EAAE,YAHJ,EAIE;AACA,cAAM,eAAe,GAAG,YAAY,YAApC;AACA,cAAM,WAAW,GAAG,QAAQ,CAAC,mBAAT,GAA+B,YAAnD;AACA,UAAA,EAAE,CAAC,aAAH,CAAiB,EAAE,CAAC,eAAD,CAAnB;AACA,UAAA,EAAE,CAAC,WAAH,CAAe,EAAE,CAAC,UAAlB,EAA8B,WAAW,CAAC,QAAZ,CAAqB,YAArB,CAA9B;AACA,UAAA,EAAE,CAAC,SAAH,CACE,KAAK,MAAL,CAAY,kBAAZ,CAA+B,WAA/B,CADF,EAEE,YAFF;AAID;;AAED,YAAM,KAAK,GACT,YAAY,IAAI,WAAhB,GAA8B,WAAW,CAAC,YAAD,CAAzC,GAA0D,CAD5D;;AAGA,YAAI,KAAK,GAAG,CAAZ,EAAe;AACb,UAAA,UAAU,CAAC,OAAX,GAAqB,IAArB;AACD;;AAED,aAAK,MAAL,CAAY,oBAAZ,CAAiC,QAAQ,CAAC,gBAA1C,EAA4D,KAA5D;AACA,aAAK,MAAL,CAAY,oBAAZ,CAAiC,QAAQ,CAAC,KAA1C,EAAiD,KAAjD;AACA,aAAK,MAAL,CAAY,oBAAZ,CACE,QAAQ,CAAC,mBADX,EAEE,QAAQ,CAAC,CAAD,CAFV;AAIA,aAAK,MAAL,CAAY,oBAAZ,CACE,QAAQ,CAAC,oBADX,EAEE,QAAQ,CAAC,CAAD,CAFV;AAIA,aAAK,MAAL,CAAY,oBAAZ,CACE,QAAQ,CAAC,UADX,EAEE,SAAS,CAAC,UAFZ;AAIA,aAAK,MAAL,CAAY,oBAAZ,CAAiC,QAAQ,CAAC,IAA1C,EAAgD,SAAS,CAAC,IAA1D;AAEA,aAAK,MAAL,CAAY,YAAZ,CAAyB,CAAzB,EAA4B,KAAK,QAAL,CAAc,OAAd,EAA5B;AACD;AACF;;AAED,SAAK,MAAL,CAAY,YAAZ,CAAyB,UAAzB;AAEA,QAAM,MAAM,GAAG,KAAK,MAAL,CAAY,SAAZ,EAAf;AAEA,QAAM,OAAO,GAAG,UAAU,CAAC,OAA3B;;AACA,QAAI,KAAK,gBAAL,KAA0B,OAA9B,EAAuC;AACrC,MAAA,MAAM,CAAC,KAAP,CAAa,OAAb,GAAuB,MAAM,CAAC,OAAD,CAA7B;AACA,WAAK,gBAAL,GAAwB,OAAxB;AACD;;AAED,QAAM,gBAAgB,GAAG,KAAK,iBAA9B;;AACA,WAAO,gBAAgB,CAAC,cAAjB,EAAP,EAA0C;AACxC,UAAM,WAAW,GAAG,gBAAgB,CAAC,GAAjB,EAApB;AACA,MAAA,WAAW,CAAC,OAAZ;AACD,KA3MmB,CA6MpB;;AACA;;;;;AAKG;;;AACH,QAAM,kBAAkB,GAAG,UAAU,GAAV,EAAe,UAAf,EAAyB;AAClD,MAAA,UAAU,CAAC,WAAX,CAAuB,UAAU,CAAC,aAAX,EAAvB,EAAmD,KAAnD;AACD,KAFD;;AAIA,IAAA,UAAU,CAAC,mBAAX,CAA+B,IAA/B,CAAoC,kBAApC;AAEA,SAAK,UAAL,CAAgB,UAAhB;AACA,WAAO,MAAP;AACD,GA5ND;AA8NA;;;;;;;;;;AAUG;;;AACH,EAAA,sBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,QAAd,EAAwB,SAAxB,EAAmC,IAAnC,EAAyC,eAAzC,EAAwD;AACtD,QAAM,SAAS,GAAG,QAAQ,CAAC,4BAAT,CAChB,SADgB,EAEhB,IAFgB,EAGhB,KAAK,cAHW,CAAlB;;AAMA,QAAI,CAAC,SAAL,EAAgB;AACd,aAAO,KAAP;AACD;;AAED,QAAI,OAAO,GAAG,IAAd;AACA,QAAM,gBAAgB,GAAG,KAAK,iBAA9B;;AACA,SAAK,IAAI,CAAC,GAAG,SAAS,CAAC,IAAvB,EAA6B,CAAC,IAAI,SAAS,CAAC,IAA5C,EAAkD,EAAE,CAApD,EAAuD;AACrD,WAAK,IAAI,CAAC,GAAG,SAAS,CAAC,IAAvB,EAA6B,CAAC,IAAI,SAAS,CAAC,IAA5C,EAAkD,EAAE,CAApD,EAAuD;AACrD,YAAM,QAAQ,GAAG,SAAS,CAAC,IAAD,EAAO,CAAP,EAAU,CAAV,CAA1B;AACA,YAAI,MAAM,GAAG,KAAb;;AACA,YAAI,gBAAgB,CAAC,WAAjB,CAA6B,QAA7B,CAAJ,EAA4C;AAC1C,cAAM,WAAW,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,QAArB,CAApB;;AACA,cAAI,WAAW,CAAC,MAAhB,EAAwB;AACtB,YAAA,sBAAsB,CAAC,eAAD,EAAkB,WAAlB,EAA+B,IAA/B,CAAtB;AACA,YAAA,MAAM,GAAG,IAAT;AACD;AACF;;AACD,YAAI,CAAC,MAAL,EAAa;AACX,UAAA,OAAO,GAAG,KAAV;AACD;AACF;AACF;;AACD,WAAO,OAAP;AACD,GA9BD;AAgCA;;AAEG;;;AACH,EAAA,sBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,QAAM,MAAM,GAAG,KAAK,MAApB;AACA,QAAM,EAAE,GAAG,MAAM,CAAC,KAAP,EAAX;AAEA,IAAA,MAAM,CAAC,YAAP,CAAoB,KAAK,QAAzB;AACA,WAAO,KAAK,QAAZ;AAEA,IAAA,EAAE,CAAC,aAAH,CAAiB,KAAK,QAAtB;AACA,WAAO,KAAK,QAAZ;AAEA,QAAM,gBAAgB,GAAG,KAAK,iBAA9B;AACA,IAAA,gBAAgB,CAAC,OAAjB,CAAyB,UAAU,WAAV,EAAqB;AAC5C,MAAA,WAAW,CAAC,OAAZ;AACD,KAFD;AAGA,IAAA,gBAAgB,CAAC,KAAjB;AACA,WAAO,KAAK,iBAAZ;;AAEA,IAAA,MAAA,CAAA,SAAA,CAAM,eAAN,CAAqB,IAArB,CAAqB,IAArB;AACD,GAlBD;;AAmBF,SAAA,sBAAA;AAAC,CAldD,CAAqC,kBAArC,CAAA;AAodA;;;AAGG;;;AACH,sBAAsB,CAAC,SAAvB,CAAiC,QAAjC;AAEA,eAAe,sBAAf","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport State from '../../source/State.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport { AttributeType } from '../../webgl/Helper.js';\nimport { ELEMENT_ARRAY_BUFFER, STATIC_DRAW } from '../../webgl.js';\nimport { compose as composeTransform, create as createTransform, } from '../../transform.js';\nimport { create as createMat4, fromTransform as mat4FromTransform, } from '../../vec/mat4.js';\nimport { createOrUpdate as createTileCoord, getKeyZXY, getKey as getTileCoordKey, } from '../../tilecoord.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getIntersection } from '../../extent.js';\nimport { getUid } from '../../util.js';\nimport { isEmpty } from '../../extent.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\nexport var Uniforms = {\n    TILE_TEXTURE_PREFIX: 'u_tileTexture',\n    TILE_TRANSFORM: 'u_tileTransform',\n    TRANSITION_ALPHA: 'u_transitionAlpha',\n    DEPTH: 'u_depth',\n    TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n    TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n    RESOLUTION: 'u_resolution',\n    ZOOM: 'u_zoom',\n};\nexport var Attributes = {\n    TEXTURE_COORD: 'a_textureCoord',\n};\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nvar attributeDescriptions = [\n    {\n        name: Attributes.TEXTURE_COORD,\n        size: 2,\n        type: AttributeType.FLOAT,\n    },\n];\nvar empty = {};\n/**\n * Transform a zoom level into a depth value ranging from -1 to 1.\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n    return 2 * (1 - 1 / (z + 1)) - 1;\n}\n/**\n * Add a tile texture to the lookup.\n * @param {Object<string, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n * tile textures by zoom level.\n * @param {import(\"../../webgl/TileTexture.js\").default} tileTexture A tile texture.\n * @param {number} z The zoom level.\n */\nfunction addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {\n    if (!(z in tileTexturesByZ)) {\n        tileTexturesByZ[z] = [];\n    }\n    tileTexturesByZ[z].push(tileTexture);\n}\n/**\n * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    if (layerState.extent) {\n        extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n    }\n    return extent;\n}\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @api\n */\nvar WebGLTileLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLTileLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/WebGLTile.js\").default} tileLayer Tile layer.\n     * @param {Options} options Options.\n     */\n    function WebGLTileLayerRenderer(tileLayer, options) {\n        var _this = _super.call(this, tileLayer, {\n            uniforms: options.uniforms,\n            className: options.className,\n        }) || this;\n        /**\n         * This transform converts tile i, j coordinates to screen coordinates.\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.tileTransform_ = createTransform();\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.tempMat4_ = createMat4();\n        /**\n         * @type {import(\"../../TileRange.js\").default}\n         * @private\n         */\n        _this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n        /**\n         * @type {import(\"../../tilecoord.js\").TileCoord}\n         * @private\n         */\n        _this.tempTileCoord_ = createTileCoord(0, 0, 0);\n        /**\n         * @type {import(\"../../size.js\").Size}\n         * @private\n         */\n        _this.tempSize_ = [0, 0];\n        _this.program_ = _this.helper.getProgram(options.fragmentShader, options.vertexShader);\n        /**\n         * Tiles are rendered as a quad with the following structure:\n         *\n         *  [P3]---------[P2]\n         *   |`           |\n         *   |  `     B   |\n         *   |    `       |\n         *   |      `     |\n         *   |   A    `   |\n         *   |          ` |\n         *  [P0]---------[P1]\n         *\n         * Triangle A: P0, P1, P3\n         * Triangle B: P1, P2, P3\n         */\n        var indices = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n        indices.fromArray([0, 1, 3, 1, 2, 3]);\n        _this.helper.flushBufferData(indices);\n        _this.indices_ = indices;\n        var cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n        /**\n         * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../webgl/TileTexture.js\").default>}\n         * @private\n         */\n        _this.tileTextureCache_ = new LRUCache(cacheSize);\n        _this.renderedOpacity_ = NaN;\n        return _this;\n    }\n    /**\n     * @protected\n     * @param {import(\"../../Tile.js\").default} tile Tile.\n     * @return {boolean} Tile is drawable.\n     */\n    WebGLTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n        var tileLayer = this.getLayer();\n        var tileState = tile.getState();\n        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n        return (tileState == TileState.LOADED ||\n            tileState == TileState.EMPTY ||\n            (tileState == TileState.ERROR && !useInterimTilesOnError));\n    };\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n        if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n            return false;\n        }\n        var source = this.getLayer().getSource();\n        if (!source) {\n            return false;\n        }\n        return source.getState() === State.READY;\n    };\n    WebGLTileLayerRenderer.prototype.enqueueTiles = function (frameState, extent, z, tileTexturesByZ) {\n        var viewState = frameState.viewState;\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getSource();\n        var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n        var tileTextureCache = this.tileTextureCache_;\n        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n        var tileSourceKey = getUid(tileSource);\n        if (!(tileSourceKey in frameState.wantedTiles)) {\n            frameState.wantedTiles[tileSourceKey] = {};\n        }\n        var wantedTiles = frameState.wantedTiles[tileSourceKey];\n        var tileResolution = tileGrid.getResolution(z);\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                var tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n                var tileCoordKey = getTileCoordKey(tileCoord);\n                var tileTexture = void 0, tile = void 0;\n                if (tileTextureCache.containsKey(tileCoordKey)) {\n                    tileTexture = tileTextureCache.get(tileCoordKey);\n                    tile = tileTexture.tile;\n                }\n                if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {\n                    tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);\n                    if (!tileTexture) {\n                        tileTexture = new TileTexture(tile, tileGrid, this.helper);\n                        tileTextureCache.set(tileCoordKey, tileTexture);\n                    }\n                    else {\n                        tileTexture.setTile(this.isDrawableTile(tile) ? tile : tile.getInterimTile());\n                    }\n                }\n                addTileTextureToLookup(tileTexturesByZ, tileTexture, z);\n                var tileQueueKey = tile.getKey();\n                wantedTiles[tileQueueKey] = true;\n                if (tile.getState() === TileState.IDLE) {\n                    if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n                        frameState.tileQueue.enqueue([\n                            tile,\n                            tileSourceKey,\n                            tileGrid.getTileCoordCenter(tileCoord),\n                            tileResolution,\n                        ]);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLTileLayerRenderer.prototype.renderFrame = function (frameState) {\n        this.preRender(frameState);\n        var viewState = frameState.viewState;\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var extent = getRenderExtent(frameState, frameState.extent);\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getSource();\n        var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n        var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n        /**\n         * @type {Object<string, Array<import(\"../../webgl/TileTexture.js\").default>>}\n         */\n        var tileTexturesByZ = {};\n        if (frameState.nextExtent) {\n            var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n            var nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n            this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);\n        }\n        this.enqueueTiles(frameState, extent, z, tileTexturesByZ);\n        /**\n         * A lookup of alpha values for tiles at the target rendering resolution\n         * for tiles that are in transition.  If a tile coord key is absent from\n         * this lookup, the tile should be rendered at alpha 1.\n         * @type {Object<string, number>}\n         */\n        var alphaLookup = {};\n        var uid = getUid(this);\n        var time = frameState.time;\n        var blend = false;\n        // look for cached tiles to use if a target tile is not ready\n        var tileTextures = tileTexturesByZ[z];\n        for (var i = 0, ii = tileTextures.length; i < ii; ++i) {\n            var tileTexture = tileTextures[i];\n            var tile = tileTexture.tile;\n            var tileCoord = tile.tileCoord;\n            if (tileTexture.loaded) {\n                var alpha = tile.getAlpha(uid, time);\n                if (alpha === 1) {\n                    // no need to look for alt tiles\n                    tile.endTransition(uid);\n                    continue;\n                }\n                blend = true;\n                var tileCoordKey = getTileCoordKey(tileCoord);\n                alphaLookup[tileCoordKey] = alpha;\n            }\n            // first look for child tiles (at z + 1)\n            var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);\n            if (coveredByChildren) {\n                continue;\n            }\n            // next look for parent tiles\n            for (var parentZ = z - 1; parentZ >= tileGrid.minZoom; --parentZ) {\n                var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);\n                if (coveredByParent) {\n                    break;\n                }\n            }\n        }\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState, !blend);\n        var zs = Object.keys(tileTexturesByZ)\n            .map(Number)\n            .sort(numberSafeCompareFunction);\n        var gl = this.helper.getGL();\n        var centerX = viewState.center[0];\n        var centerY = viewState.center[1];\n        for (var j = 0, jj = zs.length; j < jj; ++j) {\n            var tileZ = zs[j];\n            var tileResolution = tileGrid.getResolution(tileZ);\n            var tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n            var tileOrigin = tileGrid.getOrigin(tileZ);\n            var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n            var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n            var tileScale = viewState.resolution / tileResolution;\n            var depth = depthForZ(tileZ);\n            var tileTextures_1 = tileTexturesByZ[tileZ];\n            for (var i = 0, ii = tileTextures_1.length; i < ii; ++i) {\n                var tileTexture = tileTextures_1[i];\n                if (!tileTexture.loaded) {\n                    continue;\n                }\n                var tile = tileTexture.tile;\n                var tileCoord = tile.tileCoord;\n                var tileCoordKey = getTileCoordKey(tileCoord);\n                var tileCenterI = tileCoord[1];\n                var tileCenterJ = tileCoord[2];\n                composeTransform(this.tileTransform_, 0, 0, 2 / ((frameState.size[0] * tileScale) / tileSize[0]), -2 / ((frameState.size[1] * tileScale) / tileSize[1]), viewState.rotation, -(centerI - tileCenterI), -(centerJ - tileCenterJ));\n                this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, mat4FromTransform(this.tempMat4_, this.tileTransform_));\n                this.helper.bindBuffer(tileTexture.coords);\n                this.helper.bindBuffer(this.indices_);\n                this.helper.enableAttributes(attributeDescriptions);\n                for (var textureIndex = 0; textureIndex < tileTexture.textures.length; ++textureIndex) {\n                    var textureProperty = 'TEXTURE' + textureIndex;\n                    var uniformName = Uniforms.TILE_TEXTURE_PREFIX + textureIndex;\n                    gl.activeTexture(gl[textureProperty]);\n                    gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureIndex]);\n                    gl.uniform1i(this.helper.getUniformLocation(uniformName), textureIndex);\n                }\n                var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n                if (alpha < 1) {\n                    frameState.animate = true;\n                }\n                this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n                this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n                this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileSize[0]);\n                this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileSize[1]);\n                this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n                this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n                this.helper.drawElements(0, this.indices_.getSize());\n            }\n        }\n        this.helper.finalizeDraw(frameState);\n        var canvas = this.helper.getCanvas();\n        var opacity = layerState.opacity;\n        if (this.renderedOpacity_ !== opacity) {\n            canvas.style.opacity = String(opacity);\n            this.renderedOpacity_ = opacity;\n        }\n        var tileTextureCache = this.tileTextureCache_;\n        while (tileTextureCache.canExpireCache()) {\n            var tileTexture = tileTextureCache.pop();\n            tileTexture.dispose();\n        }\n        // TODO: let the renderers manage their own cache instead of managing the source cache\n        /**\n         * Here we unconditionally expire the source cache since the renderer maintains\n         * its own cache.\n         * @param {import(\"../../PluggableMap.js\").default} map Map.\n         * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n         */\n        var postRenderFunction = function (map, frameState) {\n            tileSource.expireCache(tileSource.getProjection(), empty);\n        };\n        frameState.postRenderFunctions.push(postRenderFunction);\n        this.postRender(frameState);\n        return canvas;\n    };\n    /**\n     * Look for tiles covering the provided tile coordinate at an alternate\n     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n     * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n     * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n     * @param {number} altZ The alternate zoom level.\n     * @param {Object<string, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n     * tile textures by zoom level.\n     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n     * @private\n     */\n    WebGLTileLayerRenderer.prototype.findAltTiles_ = function (tileGrid, tileCoord, altZ, tileTexturesByZ) {\n        var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n        if (!tileRange) {\n            return false;\n        }\n        var covered = true;\n        var tileTextureCache = this.tileTextureCache_;\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                var cacheKey = getKeyZXY(altZ, x, y);\n                var loaded = false;\n                if (tileTextureCache.containsKey(cacheKey)) {\n                    var tileTexture = tileTextureCache.get(cacheKey);\n                    if (tileTexture.loaded) {\n                        addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);\n                        loaded = true;\n                    }\n                }\n                if (!loaded) {\n                    covered = false;\n                }\n            }\n        }\n        return covered;\n    };\n    /**\n     * Clean up.\n     */\n    WebGLTileLayerRenderer.prototype.disposeInternal = function () {\n        var helper = this.helper;\n        var gl = helper.getGL();\n        helper.deleteBuffer(this.indices_);\n        delete this.indices_;\n        gl.deleteProgram(this.program_);\n        delete this.program_;\n        var tileTextureCache = this.tileTextureCache_;\n        tileTextureCache.forEach(function (tileTexture) {\n            tileTexture.dispose();\n        });\n        tileTextureCache.clear();\n        delete this.tileTextureCache_;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLTileLayerRenderer;\n}(WebGLLayerRenderer));\n/**\n * @function\n * @return {import(\"../../layer/WebGLTile.js\").default}\n */\nWebGLTileLayerRenderer.prototype.getLayer;\nexport default WebGLTileLayerRenderer;\n//# sourceMappingURL=TileLayer.js.map"]},"metadata":{},"sourceType":"module"}
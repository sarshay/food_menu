{"ast":null,"code":"import _ol_ from '../index.js';\nimport _ol_asserts_ from '../asserts.js';\nimport _ol_TileRange_ from '../tilerange.js';\nimport _ol_array_ from '../array.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_math_ from '../math.js';\nimport _ol_size_ from '../size.js';\nimport _ol_tilecoord_ from '../tilecoord.js';\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n *\n * @constructor\n * @param {olx.tilegrid.TileGridOptions} options Tile grid options.\n * @struct\n * @api\n */\n\nvar _ol_tilegrid_TileGrid_ = function (options) {\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n  /**\n   * @private\n   * @type {!Array.<number>}\n   */\n\n  this.resolutions_ = options.resolutions;\n\n  _ol_asserts_.assert(_ol_array_.isSorted(this.resolutions_, function (a, b) {\n    return b - a;\n  }, true), 17); // `resolutions` must be sorted in descending order\n  // check if we've got a consistent zoom factor and origin\n\n\n  var zoomFactor;\n\n  if (!options.origins) {\n    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n      if (!zoomFactor) {\n        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n      } else {\n        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n          zoomFactor = undefined;\n          break;\n        }\n      }\n    }\n  }\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n\n\n  this.zoomFactor_ = zoomFactor;\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.maxZoom = this.resolutions_.length - 1;\n  /**\n   * @private\n   * @type {ol.Coordinate}\n   */\n\n  this.origin_ = options.origin !== undefined ? options.origin : null;\n  /**\n   * @private\n   * @type {Array.<ol.Coordinate>}\n   */\n\n  this.origins_ = null;\n\n  if (options.origins !== undefined) {\n    this.origins_ = options.origins;\n\n    _ol_asserts_.assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n\n  }\n\n  var extent = options.extent;\n\n  if (extent !== undefined && !this.origin_ && !this.origins_) {\n    this.origin_ = _ol_extent_.getTopLeft(extent);\n  }\n\n  _ol_asserts_.assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both\n\n  /**\n   * @private\n   * @type {Array.<number|ol.Size>}\n   */\n\n\n  this.tileSizes_ = null;\n\n  if (options.tileSizes !== undefined) {\n    this.tileSizes_ = options.tileSizes;\n\n    _ol_asserts_.assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n\n  }\n  /**\n   * @private\n   * @type {number|ol.Size}\n   */\n\n\n  this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _ol_.DEFAULT_TILE_SIZE : null;\n\n  _ol_asserts_.assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both\n\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n\n\n  this.extent_ = extent !== undefined ? extent : null;\n  /**\n   * @private\n   * @type {Array.<ol.TileRange>}\n   */\n\n  this.fullTileRanges_ = null;\n  /**\n   * @private\n   * @type {ol.Size}\n   */\n\n  this.tmpSize_ = [0, 0];\n\n  if (options.sizes !== undefined) {\n    this.fullTileRanges_ = options.sizes.map(function (size, z) {\n      var tileRange = new _ol_TileRange_(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n      return tileRange;\n    }, this);\n  } else if (extent) {\n    this.calculateTileRanges_(extent);\n  }\n};\n/**\n * @private\n * @type {ol.TileCoord}\n */\n\n\n_ol_tilegrid_TileGrid_.tmpTileCoord_ = [0, 0, 0];\n/**\n * Call a function with each tile coordinate for a given extent and zoom level.\n *\n * @param {ol.Extent} extent Extent.\n * @param {number} zoom Integer zoom level.\n * @param {function(ol.TileCoord)} callback Function called with each tile coordinate.\n * @api\n */\n\n_ol_tilegrid_TileGrid_.prototype.forEachTileCoord = function (extent, zoom, callback) {\n  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n\n  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n      callback([zoom, i, j]);\n    }\n  }\n};\n/**\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @param {function(this: T, number, ol.TileRange): boolean} callback Callback.\n * @param {T=} opt_this The object to use as `this` in `callback`.\n * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.\n * @param {ol.Extent=} opt_extent Temporary ol.Extent object.\n * @return {boolean} Callback succeeded.\n * @template T\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {\n  var tileRange, x, y;\n  var tileCoordExtent = null;\n  var z = tileCoord[0] - 1;\n\n  if (this.zoomFactor_ === 2) {\n    x = tileCoord[1];\n    y = tileCoord[2];\n  } else {\n    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n  }\n\n  while (z >= this.minZoom) {\n    if (this.zoomFactor_ === 2) {\n      x = Math.floor(x / 2);\n      y = Math.floor(y / 2);\n      tileRange = _ol_TileRange_.createOrUpdate(x, x, y, y, opt_tileRange);\n    } else {\n      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    }\n\n    if (callback.call(opt_this, z, tileRange)) {\n      return true;\n    }\n\n    --z;\n  }\n\n  return false;\n};\n/**\n * Get the extent for this tile grid, if it was configured.\n * @return {ol.Extent} Extent.\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getExtent = function () {\n  return this.extent_;\n};\n/**\n * Get the maximum zoom level for the grid.\n * @return {number} Max zoom.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getMaxZoom = function () {\n  return this.maxZoom;\n};\n/**\n * Get the minimum zoom level for the grid.\n * @return {number} Min zoom.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getMinZoom = function () {\n  return this.minZoom;\n};\n/**\n * Get the origin for the grid at the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {ol.Coordinate} Origin.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getOrigin = function (z) {\n  if (this.origin_) {\n    return this.origin_;\n  } else {\n    return this.origins_[z];\n  }\n};\n/**\n * Get the resolution for the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {number} Resolution.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getResolution = function (z) {\n  return this.resolutions_[z];\n};\n/**\n * Get the list of resolutions for the tile grid.\n * @return {Array.<number>} Resolutions.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getResolutions = function () {\n  return this.resolutions_;\n};\n/**\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.\n * @param {ol.Extent=} opt_extent Temporary ol.Extent object.\n * @return {ol.TileRange} Tile range.\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {\n  if (tileCoord[0] < this.maxZoom) {\n    if (this.zoomFactor_ === 2) {\n      var minX = tileCoord[1] * 2;\n      var minY = tileCoord[2] * 2;\n      return _ol_TileRange_.createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);\n    }\n\n    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n  }\n\n  return null;\n};\n/**\n * Get the extent for a tile range.\n * @param {number} z Integer zoom level.\n * @param {ol.TileRange} tileRange Tile range.\n * @param {ol.Extent=} opt_extent Temporary ol.Extent object.\n * @return {ol.Extent} Extent.\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n\n  var tileSize = _ol_size_.toSize(this.getTileSize(z), this.tmpSize_);\n\n  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n  return _ol_extent_.createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n/**\n * Get a tile range for the given extent and integer zoom level.\n * @param {ol.Extent} extent Extent.\n * @param {number} z Integer zoom level.\n * @param {ol.TileRange=} opt_tileRange Temporary tile range object.\n * @return {ol.TileRange} Tile range.\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {\n  var tileCoord = _ol_tilegrid_TileGrid_.tmpTileCoord_;\n  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);\n  var minX = tileCoord[1];\n  var minY = tileCoord[2];\n  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);\n  return _ol_TileRange_.createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n};\n/**\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @return {ol.Coordinate} Tile center.\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileCoordCenter = function (tileCoord) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n\n  var tileSize = _ol_size_.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n\n  return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];\n};\n/**\n * Get the extent of a tile coordinate.\n *\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @param {ol.Extent=} opt_extent Temporary extent object.\n * @return {ol.Extent} Extent.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n\n  var tileSize = _ol_size_.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n\n  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;\n  var maxX = minX + tileSize[0] * resolution;\n  var maxY = minY + tileSize[1] * resolution;\n  return _ol_extent_.createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n/**\n * Get the tile coordinate for the given map coordinate and resolution.  This\n * method considers that coordinates that intersect tile boundaries should be\n * assigned the higher tile coordinate.\n *\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {number} resolution Resolution.\n * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.\n * @return {ol.TileCoord} Tile coordinate.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {\n  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n};\n/**\n * Note that this method should not be called for resolutions that correspond\n * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} resolution Resolution (for a non-integer zoom level).\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *     intersections go to the higher tile coordinate, let edge intersections\n *     go to the lower tile coordinate.\n * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.\n * @return {ol.TileCoord} Tile coordinate.\n * @private\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n  var z = this.getZForResolution(resolution);\n  var scale = resolution / this.getResolution(z);\n  var origin = this.getOrigin(z);\n\n  var tileSize = _ol_size_.toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = scale * xFromOrigin / tileSize[0];\n  var tileCoordY = scale * yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return _ol_tilecoord_.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n/**\n * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n * they should have separate implementations.  This method is for integer zoom\n * levels.  The other method should only be called for resolutions corresponding\n * to non-integer zoom levels.\n * @param {number} x Map x coordinate.\n * @param {number} y Map y coordinate.\n * @param {number} z Integer zoom level.\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *     intersections go to the higher tile coordinate, let edge intersections\n *     go to the lower tile coordinate.\n * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.\n * @return {ol.TileCoord} Tile coordinate.\n * @private\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n\n  var tileSize = _ol_size_.toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = xFromOrigin / tileSize[0];\n  var tileCoordY = yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return _ol_tilecoord_.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n/**\n * Get a tile coordinate given a map coordinate and zoom level.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {number} z Zoom level.\n * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.\n * @return {ol.TileCoord} Tile coordinate.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {\n  return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n};\n/**\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @return {number} Tile resolution.\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileCoordResolution = function (tileCoord) {\n  return this.resolutions_[tileCoord[0]];\n};\n/**\n * Get the tile size for a zoom level. The type of the return value matches the\n * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n * get an `ol.Size`, run the result through `ol.size.toSize()`.\n * @param {number} z Z.\n * @return {number|ol.Size} Tile size.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getTileSize = function (z) {\n  if (this.tileSize_) {\n    return this.tileSize_;\n  } else {\n    return this.tileSizes_[z];\n  }\n};\n/**\n * @param {number} z Zoom level.\n * @return {ol.TileRange} Extent tile range for the specified zoom level.\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getFullTileRange = function (z) {\n  if (!this.fullTileRanges_) {\n    return null;\n  } else {\n    return this.fullTileRanges_[z];\n  }\n};\n/**\n * @param {number} resolution Resolution.\n * @param {number=} opt_direction If 0, the nearest resolution will be used.\n *     If 1, the nearest lower resolution will be used. If -1, the nearest\n *     higher resolution will be used. Default is 0.\n * @return {number} Z.\n * @api\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.getZForResolution = function (resolution, opt_direction) {\n  var z = _ol_array_.linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n\n  return _ol_math_.clamp(z, this.minZoom, this.maxZoom);\n};\n/**\n * @param {!ol.Extent} extent Extent for this tile grid.\n * @private\n */\n\n\n_ol_tilegrid_TileGrid_.prototype.calculateTileRanges_ = function (extent) {\n  var length = this.resolutions_.length;\n  var fullTileRanges = new Array(length);\n\n  for (var z = this.minZoom; z < length; ++z) {\n    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n  }\n\n  this.fullTileRanges_ = fullTileRanges;\n};\n\nexport default _ol_tilegrid_TileGrid_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/tilegrid/tilegrid.js"],"names":["_ol_","_ol_asserts_","_ol_TileRange_","_ol_array_","_ol_extent_","_ol_math_","_ol_size_","_ol_tilecoord_","_ol_tilegrid_TileGrid_","options","minZoom","undefined","resolutions_","resolutions","assert","isSorted","a","b","zoomFactor","origins","i","ii","length","zoomFactor_","maxZoom","origin_","origin","origins_","extent","getTopLeft","tileSizes_","tileSizes","tileSize_","tileSize","DEFAULT_TILE_SIZE","extent_","fullTileRanges_","tmpSize_","sizes","map","size","z","tileRange","Math","min","max","calculateTileRanges_","tmpTileCoord_","prototype","forEachTileCoord","zoom","callback","getTileRangeForExtentAndZ","minX","maxX","j","minY","jj","maxY","forEachTileCoordParentTileRange","tileCoord","opt_this","opt_tileRange","opt_extent","x","y","tileCoordExtent","getTileCoordExtent","floor","createOrUpdate","call","getExtent","getMaxZoom","getMinZoom","getOrigin","getResolution","getResolutions","getTileCoordChildTileRange","getTileRangeExtent","resolution","toSize","getTileSize","getTileCoordForXYAndZ_","getTileCoordCenter","getTileCoordForCoordAndResolution","coordinate","opt_tileCoord","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","getZForResolution","scale","adjustX","adjustY","xFromOrigin","yFromOrigin","tileCoordX","tileCoordY","ceil","getTileCoordForCoordAndZ","getTileCoordResolution","getFullTileRange","opt_direction","linearFindNearest","clamp","fullTileRanges","Array"],"mappings":"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","sourcesContent":["import _ol_ from '../index.js';\nimport _ol_asserts_ from '../asserts.js';\nimport _ol_TileRange_ from '../tilerange.js';\nimport _ol_array_ from '../array.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_math_ from '../math.js';\nimport _ol_size_ from '../size.js';\nimport _ol_tilecoord_ from '../tilecoord.js';\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n *\n * @constructor\n * @param {olx.tilegrid.TileGridOptions} options Tile grid options.\n * @struct\n * @api\n */\nvar _ol_tilegrid_TileGrid_ = function(options) {\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n  /**\n   * @private\n   * @type {!Array.<number>}\n   */\n  this.resolutions_ = options.resolutions;\n  _ol_asserts_.assert(_ol_array_.isSorted(this.resolutions_, function(a, b) {\n    return b - a;\n  }, true), 17); // `resolutions` must be sorted in descending order\n\n\n  // check if we've got a consistent zoom factor and origin\n  var zoomFactor;\n  if (!options.origins) {\n    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n      if (!zoomFactor) {\n        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n      } else {\n        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n          zoomFactor = undefined;\n          break;\n        }\n      }\n    }\n  }\n\n\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n  this.zoomFactor_ = zoomFactor;\n\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.maxZoom = this.resolutions_.length - 1;\n\n  /**\n   * @private\n   * @type {ol.Coordinate}\n   */\n  this.origin_ = options.origin !== undefined ? options.origin : null;\n\n  /**\n   * @private\n   * @type {Array.<ol.Coordinate>}\n   */\n  this.origins_ = null;\n  if (options.origins !== undefined) {\n    this.origins_ = options.origins;\n    _ol_asserts_.assert(this.origins_.length == this.resolutions_.length,\n        20); // Number of `origins` and `resolutions` must be equal\n  }\n\n  var extent = options.extent;\n\n  if (extent !== undefined &&\n      !this.origin_ && !this.origins_) {\n    this.origin_ = _ol_extent_.getTopLeft(extent);\n  }\n\n  _ol_asserts_.assert(\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n      18); // Either `origin` or `origins` must be configured, never both\n\n  /**\n   * @private\n   * @type {Array.<number|ol.Size>}\n   */\n  this.tileSizes_ = null;\n  if (options.tileSizes !== undefined) {\n    this.tileSizes_ = options.tileSizes;\n    _ol_asserts_.assert(this.tileSizes_.length == this.resolutions_.length,\n        19); // Number of `tileSizes` and `resolutions` must be equal\n  }\n\n  /**\n   * @private\n   * @type {number|ol.Size}\n   */\n  this.tileSize_ = options.tileSize !== undefined ?\n    options.tileSize :\n    !this.tileSizes_ ? _ol_.DEFAULT_TILE_SIZE : null;\n  _ol_asserts_.assert(\n      (!this.tileSize_ && this.tileSizes_) ||\n      (this.tileSize_ && !this.tileSizes_),\n      22); // Either `tileSize` or `tileSizes` must be configured, never both\n\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n  this.extent_ = extent !== undefined ? extent : null;\n\n\n  /**\n   * @private\n   * @type {Array.<ol.TileRange>}\n   */\n  this.fullTileRanges_ = null;\n\n  /**\n   * @private\n   * @type {ol.Size}\n   */\n  this.tmpSize_ = [0, 0];\n\n  if (options.sizes !== undefined) {\n    this.fullTileRanges_ = options.sizes.map(function(size, z) {\n      var tileRange = new _ol_TileRange_(\n          Math.min(0, size[0]), Math.max(size[0] - 1, -1),\n          Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n      return tileRange;\n    }, this);\n  } else if (extent) {\n    this.calculateTileRanges_(extent);\n  }\n\n};\n\n\n/**\n * @private\n * @type {ol.TileCoord}\n */\n_ol_tilegrid_TileGrid_.tmpTileCoord_ = [0, 0, 0];\n\n\n/**\n * Call a function with each tile coordinate for a given extent and zoom level.\n *\n * @param {ol.Extent} extent Extent.\n * @param {number} zoom Integer zoom level.\n * @param {function(ol.TileCoord)} callback Function called with each tile coordinate.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.forEachTileCoord = function(extent, zoom, callback) {\n  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n      callback([zoom, i, j]);\n    }\n  }\n};\n\n\n/**\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @param {function(this: T, number, ol.TileRange): boolean} callback Callback.\n * @param {T=} opt_this The object to use as `this` in `callback`.\n * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.\n * @param {ol.Extent=} opt_extent Temporary ol.Extent object.\n * @return {boolean} Callback succeeded.\n * @template T\n */\n_ol_tilegrid_TileGrid_.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_this, opt_tileRange, opt_extent) {\n  var tileRange, x, y;\n  var tileCoordExtent = null;\n  var z = tileCoord[0] - 1;\n  if (this.zoomFactor_ === 2) {\n    x = tileCoord[1];\n    y = tileCoord[2];\n  } else {\n    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n  }\n  while (z >= this.minZoom) {\n    if (this.zoomFactor_ === 2) {\n      x = Math.floor(x / 2);\n      y = Math.floor(y / 2);\n      tileRange = _ol_TileRange_.createOrUpdate(x, x, y, y, opt_tileRange);\n    } else {\n      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    }\n    if (callback.call(opt_this, z, tileRange)) {\n      return true;\n    }\n    --z;\n  }\n  return false;\n};\n\n\n/**\n * Get the extent for this tile grid, if it was configured.\n * @return {ol.Extent} Extent.\n */\n_ol_tilegrid_TileGrid_.prototype.getExtent = function() {\n  return this.extent_;\n};\n\n\n/**\n * Get the maximum zoom level for the grid.\n * @return {number} Max zoom.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getMaxZoom = function() {\n  return this.maxZoom;\n};\n\n\n/**\n * Get the minimum zoom level for the grid.\n * @return {number} Min zoom.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getMinZoom = function() {\n  return this.minZoom;\n};\n\n\n/**\n * Get the origin for the grid at the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {ol.Coordinate} Origin.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getOrigin = function(z) {\n  if (this.origin_) {\n    return this.origin_;\n  } else {\n    return this.origins_[z];\n  }\n};\n\n\n/**\n * Get the resolution for the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {number} Resolution.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getResolution = function(z) {\n  return this.resolutions_[z];\n};\n\n\n/**\n * Get the list of resolutions for the tile grid.\n * @return {Array.<number>} Resolutions.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getResolutions = function() {\n  return this.resolutions_;\n};\n\n\n/**\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.\n * @param {ol.Extent=} opt_extent Temporary ol.Extent object.\n * @return {ol.TileRange} Tile range.\n */\n_ol_tilegrid_TileGrid_.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {\n  if (tileCoord[0] < this.maxZoom) {\n    if (this.zoomFactor_ === 2) {\n      var minX = tileCoord[1] * 2;\n      var minY = tileCoord[2] * 2;\n      return _ol_TileRange_.createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);\n    }\n    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    return this.getTileRangeForExtentAndZ(\n        tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n  }\n  return null;\n};\n\n\n/**\n * Get the extent for a tile range.\n * @param {number} z Integer zoom level.\n * @param {ol.TileRange} tileRange Tile range.\n * @param {ol.Extent=} opt_extent Temporary ol.Extent object.\n * @return {ol.Extent} Extent.\n */\n_ol_tilegrid_TileGrid_.prototype.getTileRangeExtent = function(z, tileRange, opt_extent) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = _ol_size_.toSize(this.getTileSize(z), this.tmpSize_);\n  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n  return _ol_extent_.createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n\n\n/**\n * Get a tile range for the given extent and integer zoom level.\n * @param {ol.Extent} extent Extent.\n * @param {number} z Integer zoom level.\n * @param {ol.TileRange=} opt_tileRange Temporary tile range object.\n * @return {ol.TileRange} Tile range.\n */\n_ol_tilegrid_TileGrid_.prototype.getTileRangeForExtentAndZ = function(extent, z, opt_tileRange) {\n  var tileCoord = _ol_tilegrid_TileGrid_.tmpTileCoord_;\n  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);\n  var minX = tileCoord[1];\n  var minY = tileCoord[2];\n  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);\n  return _ol_TileRange_.createOrUpdate(\n      minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n};\n\n\n/**\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @return {ol.Coordinate} Tile center.\n */\n_ol_tilegrid_TileGrid_.prototype.getTileCoordCenter = function(tileCoord) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = _ol_size_.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  return [\n    origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n    origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution\n  ];\n};\n\n\n/**\n * Get the extent of a tile coordinate.\n *\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @param {ol.Extent=} opt_extent Temporary extent object.\n * @return {ol.Extent} Extent.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = _ol_size_.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;\n  var maxX = minX + tileSize[0] * resolution;\n  var maxY = minY + tileSize[1] * resolution;\n  return _ol_extent_.createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n\n\n/**\n * Get the tile coordinate for the given map coordinate and resolution.  This\n * method considers that coordinates that intersect tile boundaries should be\n * assigned the higher tile coordinate.\n *\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {number} resolution Resolution.\n * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.\n * @return {ol.TileCoord} Tile coordinate.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {\n  return this.getTileCoordForXYAndResolution_(\n      coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n};\n\n\n/**\n * Note that this method should not be called for resolutions that correspond\n * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} resolution Resolution (for a non-integer zoom level).\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *     intersections go to the higher tile coordinate, let edge intersections\n *     go to the lower tile coordinate.\n * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.\n * @return {ol.TileCoord} Tile coordinate.\n * @private\n */\n_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndResolution_ = function(\n    x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n  var z = this.getZForResolution(resolution);\n  var scale = resolution / this.getResolution(z);\n  var origin = this.getOrigin(z);\n  var tileSize = _ol_size_.toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = scale * xFromOrigin / tileSize[0];\n  var tileCoordY = scale * yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return _ol_tilecoord_.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n\n\n/**\n * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n * they should have separate implementations.  This method is for integer zoom\n * levels.  The other method should only be called for resolutions corresponding\n * to non-integer zoom levels.\n * @param {number} x Map x coordinate.\n * @param {number} y Map y coordinate.\n * @param {number} z Integer zoom level.\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *     intersections go to the higher tile coordinate, let edge intersections\n *     go to the lower tile coordinate.\n * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.\n * @return {ol.TileCoord} Tile coordinate.\n * @private\n */\n_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndZ_ = function(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = _ol_size_.toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = xFromOrigin / tileSize[0];\n  var tileCoordY = yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return _ol_tilecoord_.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n\n\n/**\n * Get a tile coordinate given a map coordinate and zoom level.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {number} z Zoom level.\n * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.\n * @return {ol.TileCoord} Tile coordinate.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndZ = function(coordinate, z, opt_tileCoord) {\n  return this.getTileCoordForXYAndZ_(\n      coordinate[0], coordinate[1], z, false, opt_tileCoord);\n};\n\n\n/**\n * @param {ol.TileCoord} tileCoord Tile coordinate.\n * @return {number} Tile resolution.\n */\n_ol_tilegrid_TileGrid_.prototype.getTileCoordResolution = function(tileCoord) {\n  return this.resolutions_[tileCoord[0]];\n};\n\n\n/**\n * Get the tile size for a zoom level. The type of the return value matches the\n * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n * get an `ol.Size`, run the result through `ol.size.toSize()`.\n * @param {number} z Z.\n * @return {number|ol.Size} Tile size.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getTileSize = function(z) {\n  if (this.tileSize_) {\n    return this.tileSize_;\n  } else {\n    return this.tileSizes_[z];\n  }\n};\n\n\n/**\n * @param {number} z Zoom level.\n * @return {ol.TileRange} Extent tile range for the specified zoom level.\n */\n_ol_tilegrid_TileGrid_.prototype.getFullTileRange = function(z) {\n  if (!this.fullTileRanges_) {\n    return null;\n  } else {\n    return this.fullTileRanges_[z];\n  }\n};\n\n\n/**\n * @param {number} resolution Resolution.\n * @param {number=} opt_direction If 0, the nearest resolution will be used.\n *     If 1, the nearest lower resolution will be used. If -1, the nearest\n *     higher resolution will be used. Default is 0.\n * @return {number} Z.\n * @api\n */\n_ol_tilegrid_TileGrid_.prototype.getZForResolution = function(\n    resolution, opt_direction) {\n  var z = _ol_array_.linearFindNearest(this.resolutions_, resolution,\n      opt_direction || 0);\n  return _ol_math_.clamp(z, this.minZoom, this.maxZoom);\n};\n\n\n/**\n * @param {!ol.Extent} extent Extent for this tile grid.\n * @private\n */\n_ol_tilegrid_TileGrid_.prototype.calculateTileRanges_ = function(extent) {\n  var length = this.resolutions_.length;\n  var fullTileRanges = new Array(length);\n  for (var z = this.minZoom; z < length; ++z) {\n    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n  }\n  this.fullTileRanges_ = fullTileRanges;\n};\nexport default _ol_tilegrid_TileGrid_;\n"]},"metadata":{},"sourceType":"module"}
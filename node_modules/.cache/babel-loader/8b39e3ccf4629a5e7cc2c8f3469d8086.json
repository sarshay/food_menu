{"ast":null,"code":"import _ol_ from '../index.js';\nimport _ol_ImageState_ from '../imagestate.js';\nimport _ol_Observable_ from '../observable.js';\nimport _ol_TileState_ from '../tilestate.js';\nimport _ol_asserts_ from '../asserts.js';\nimport _ol_events_ from '../events.js';\nimport _ol_events_EventType_ from '../events/eventtype.js';\nimport _ol_functions_ from '../functions.js';\nimport _ol_source_State_ from '../source/state.js';\n/**\n * @constructor\n * @extends {ol.Observable}\n * @param {ol.layer.Layer} layer Layer.\n * @struct\n */\n\nvar _ol_renderer_Layer_ = function (layer) {\n  _ol_Observable_.call(this);\n  /**\n   * @private\n   * @type {ol.layer.Layer}\n   */\n\n\n  this.layer_ = layer;\n};\n\n_ol_.inherits(_ol_renderer_Layer_, _ol_Observable_);\n/**\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {olx.FrameState} frameState Frame state.\n * @param {number} hitTolerance Hit tolerance in pixels.\n * @param {function(this: S, (ol.Feature|ol.render.Feature), ol.layer.Layer): T}\n *     callback Feature callback.\n * @param {S} thisArg Value to use as `this` when executing `callback`.\n * @return {T|undefined} Callback result.\n * @template S,T\n */\n\n\n_ol_renderer_Layer_.prototype.forEachFeatureAtCoordinate = _ol_.nullFunction;\n/**\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {olx.FrameState} frameState Frame state.\n * @return {boolean} Is there a feature at the given coordinate?\n */\n\n_ol_renderer_Layer_.prototype.hasFeatureAtCoordinate = _ol_functions_.FALSE;\n/**\n * Create a function that adds loaded tiles to the tile lookup.\n * @param {ol.source.Tile} source Tile source.\n * @param {ol.proj.Projection} projection Projection of the tiles.\n * @param {Object.<number, Object.<string, ol.Tile>>} tiles Lookup of loaded\n *     tiles by zoom level.\n * @return {function(number, ol.TileRange):boolean} A function that can be\n *     called with a zoom level and a tile range to add loaded tiles to the\n *     lookup.\n * @protected\n */\n\n_ol_renderer_Layer_.prototype.createLoadedTileFinder = function (source, projection, tiles) {\n  return (\n    /**\n     * @param {number} zoom Zoom level.\n     * @param {ol.TileRange} tileRange Tile range.\n     * @return {boolean} The tile range is fully loaded.\n     */\n    function (zoom, tileRange) {\n      function callback(tile) {\n        if (!tiles[zoom]) {\n          tiles[zoom] = {};\n        }\n\n        tiles[zoom][tile.tileCoord.toString()] = tile;\n      }\n\n      return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n    }\n  );\n};\n/**\n * @return {ol.layer.Layer} Layer.\n */\n\n\n_ol_renderer_Layer_.prototype.getLayer = function () {\n  return this.layer_;\n};\n/**\n * Handle changes in image state.\n * @param {ol.events.Event} event Image change event.\n * @private\n */\n\n\n_ol_renderer_Layer_.prototype.handleImageChange_ = function (event) {\n  var image =\n  /** @type {ol.Image} */\n  event.target;\n\n  if (image.getState() === _ol_ImageState_.LOADED) {\n    this.renderIfReadyAndVisible();\n  }\n};\n/**\n * Load the image if not already loaded, and register the image change\n * listener if needed.\n * @param {ol.ImageBase} image Image.\n * @return {boolean} `true` if the image is already loaded, `false`\n *     otherwise.\n * @protected\n */\n\n\n_ol_renderer_Layer_.prototype.loadImage = function (image) {\n  var imageState = image.getState();\n\n  if (imageState != _ol_ImageState_.LOADED && imageState != _ol_ImageState_.ERROR) {\n    _ol_events_.listen(image, _ol_events_EventType_.CHANGE, this.handleImageChange_, this);\n  }\n\n  if (imageState == _ol_ImageState_.IDLE) {\n    image.load();\n    imageState = image.getState();\n  }\n\n  return imageState == _ol_ImageState_.LOADED;\n};\n/**\n * @protected\n */\n\n\n_ol_renderer_Layer_.prototype.renderIfReadyAndVisible = function () {\n  var layer = this.getLayer();\n\n  if (layer.getVisible() && layer.getSourceState() == _ol_source_State_.READY) {\n    this.changed();\n  }\n};\n/**\n * @param {olx.FrameState} frameState Frame state.\n * @param {ol.source.Tile} tileSource Tile source.\n * @protected\n */\n\n\n_ol_renderer_Layer_.prototype.scheduleExpireCache = function (frameState, tileSource) {\n  if (tileSource.canExpireCache()) {\n    /**\n     * @param {ol.source.Tile} tileSource Tile source.\n     * @param {ol.PluggableMap} map Map.\n     * @param {olx.FrameState} frameState Frame state.\n     */\n    var postRenderFunction = function (tileSource, map, frameState) {\n      var tileSourceKey = _ol_.getUid(tileSource).toString();\n\n      if (tileSourceKey in frameState.usedTiles) {\n        tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n      }\n    }.bind(null, tileSource);\n\n    frameState.postRenderFunctions.push(\n    /** @type {ol.PostRenderFunction} */\n    postRenderFunction);\n  }\n};\n/**\n * @param {olx.FrameState} frameState Frame state.\n * @param {ol.source.Source} source Source.\n * @protected\n */\n\n\n_ol_renderer_Layer_.prototype.updateLogos = function (frameState, source) {\n  var logo = source.getLogo();\n\n  if (logo !== undefined) {\n    if (typeof logo === 'string') {\n      frameState.logos[logo] = '';\n    } else if (logo) {\n      _ol_asserts_.assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.\n\n\n      _ol_asserts_.assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.\n\n\n      frameState.logos[logo.src] = logo.href;\n    }\n  }\n};\n/**\n * @param {Object.<string, Object.<string, ol.TileRange>>} usedTiles Used tiles.\n * @param {ol.source.Tile} tileSource Tile source.\n * @param {number} z Z.\n * @param {ol.TileRange} tileRange Tile range.\n * @protected\n */\n\n\n_ol_renderer_Layer_.prototype.updateUsedTiles = function (usedTiles, tileSource, z, tileRange) {\n  // FIXME should we use tilesToDrawByZ instead?\n  var tileSourceKey = _ol_.getUid(tileSource).toString();\n\n  var zKey = z.toString();\n\n  if (tileSourceKey in usedTiles) {\n    if (zKey in usedTiles[tileSourceKey]) {\n      usedTiles[tileSourceKey][zKey].extend(tileRange);\n    } else {\n      usedTiles[tileSourceKey][zKey] = tileRange;\n    }\n  } else {\n    usedTiles[tileSourceKey] = {};\n    usedTiles[tileSourceKey][zKey] = tileRange;\n  }\n};\n/**\n * Manage tile pyramid.\n * This function performs a number of functions related to the tiles at the\n * current zoom and lower zoom levels:\n * - registers idle tiles in frameState.wantedTiles so that they are not\n *   discarded by the tile queue\n * - enqueues missing tiles\n * @param {olx.FrameState} frameState Frame state.\n * @param {ol.source.Tile} tileSource Tile source.\n * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.\n * @param {number} pixelRatio Pixel ratio.\n * @param {ol.proj.Projection} projection Projection.\n * @param {ol.Extent} extent Extent.\n * @param {number} currentZ Current Z.\n * @param {number} preload Load low resolution tiles up to 'preload' levels.\n * @param {function(this: T, ol.Tile)=} opt_tileCallback Tile callback.\n * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n * @protected\n * @template T\n */\n\n\n_ol_renderer_Layer_.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {\n  var tileSourceKey = _ol_.getUid(tileSource).toString();\n\n  if (!(tileSourceKey in frameState.wantedTiles)) {\n    frameState.wantedTiles[tileSourceKey] = {};\n  }\n\n  var wantedTiles = frameState.wantedTiles[tileSourceKey];\n  var tileQueue = frameState.tileQueue;\n  var minZoom = tileGrid.getMinZoom();\n  var tile, tileRange, tileResolution, x, y, z;\n\n  for (z = minZoom; z <= currentZ; ++z) {\n    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n    tileResolution = tileGrid.getResolution(z);\n\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (currentZ - z <= preload) {\n          tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n          if (tile.getState() == _ol_TileState_.IDLE) {\n            wantedTiles[tile.getKey()] = true;\n\n            if (!tileQueue.isKeyQueued(tile.getKey())) {\n              tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n            }\n          }\n\n          if (opt_tileCallback !== undefined) {\n            opt_tileCallback.call(opt_this, tile);\n          }\n        } else {\n          tileSource.useTile(z, x, y, projection);\n        }\n      }\n    }\n  }\n};\n\nexport default _ol_renderer_Layer_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/renderer/layer.js"],"names":["_ol_","_ol_ImageState_","_ol_Observable_","_ol_TileState_","_ol_asserts_","_ol_events_","_ol_events_EventType_","_ol_functions_","_ol_source_State_","_ol_renderer_Layer_","layer","call","layer_","inherits","prototype","forEachFeatureAtCoordinate","nullFunction","hasFeatureAtCoordinate","FALSE","createLoadedTileFinder","source","projection","tiles","zoom","tileRange","callback","tile","tileCoord","toString","forEachLoadedTile","getLayer","handleImageChange_","event","image","target","getState","LOADED","renderIfReadyAndVisible","loadImage","imageState","ERROR","listen","CHANGE","IDLE","load","getVisible","getSourceState","READY","changed","scheduleExpireCache","frameState","tileSource","canExpireCache","postRenderFunction","map","tileSourceKey","getUid","usedTiles","expireCache","viewState","bind","postRenderFunctions","push","updateLogos","logo","getLogo","undefined","logos","assert","href","src","updateUsedTiles","z","zKey","extend","manageTilePyramid","tileGrid","pixelRatio","extent","currentZ","preload","opt_tileCallback","opt_this","wantedTiles","tileQueue","minZoom","getMinZoom","tileResolution","x","y","getTileRangeForExtentAndZ","getResolution","minX","maxX","minY","maxY","getTile","getKey","isKeyQueued","enqueue","getTileCoordCenter","useTile"],"mappings":"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","sourcesContent":["import _ol_ from '../index.js';\nimport _ol_ImageState_ from '../imagestate.js';\nimport _ol_Observable_ from '../observable.js';\nimport _ol_TileState_ from '../tilestate.js';\nimport _ol_asserts_ from '../asserts.js';\nimport _ol_events_ from '../events.js';\nimport _ol_events_EventType_ from '../events/eventtype.js';\nimport _ol_functions_ from '../functions.js';\nimport _ol_source_State_ from '../source/state.js';\n\n/**\n * @constructor\n * @extends {ol.Observable}\n * @param {ol.layer.Layer} layer Layer.\n * @struct\n */\nvar _ol_renderer_Layer_ = function(layer) {\n\n  _ol_Observable_.call(this);\n\n  /**\n   * @private\n   * @type {ol.layer.Layer}\n   */\n  this.layer_ = layer;\n\n\n};\n\n_ol_.inherits(_ol_renderer_Layer_, _ol_Observable_);\n\n\n/**\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {olx.FrameState} frameState Frame state.\n * @param {number} hitTolerance Hit tolerance in pixels.\n * @param {function(this: S, (ol.Feature|ol.render.Feature), ol.layer.Layer): T}\n *     callback Feature callback.\n * @param {S} thisArg Value to use as `this` when executing `callback`.\n * @return {T|undefined} Callback result.\n * @template S,T\n */\n_ol_renderer_Layer_.prototype.forEachFeatureAtCoordinate = _ol_.nullFunction;\n\n\n/**\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {olx.FrameState} frameState Frame state.\n * @return {boolean} Is there a feature at the given coordinate?\n */\n_ol_renderer_Layer_.prototype.hasFeatureAtCoordinate = _ol_functions_.FALSE;\n\n\n/**\n * Create a function that adds loaded tiles to the tile lookup.\n * @param {ol.source.Tile} source Tile source.\n * @param {ol.proj.Projection} projection Projection of the tiles.\n * @param {Object.<number, Object.<string, ol.Tile>>} tiles Lookup of loaded\n *     tiles by zoom level.\n * @return {function(number, ol.TileRange):boolean} A function that can be\n *     called with a zoom level and a tile range to add loaded tiles to the\n *     lookup.\n * @protected\n */\n_ol_renderer_Layer_.prototype.createLoadedTileFinder = function(source, projection, tiles) {\n  return (\n    /**\n     * @param {number} zoom Zoom level.\n     * @param {ol.TileRange} tileRange Tile range.\n     * @return {boolean} The tile range is fully loaded.\n     */\n    function(zoom, tileRange) {\n      function callback(tile) {\n        if (!tiles[zoom]) {\n          tiles[zoom] = {};\n        }\n        tiles[zoom][tile.tileCoord.toString()] = tile;\n      }\n      return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n    });\n};\n\n\n/**\n * @return {ol.layer.Layer} Layer.\n */\n_ol_renderer_Layer_.prototype.getLayer = function() {\n  return this.layer_;\n};\n\n\n/**\n * Handle changes in image state.\n * @param {ol.events.Event} event Image change event.\n * @private\n */\n_ol_renderer_Layer_.prototype.handleImageChange_ = function(event) {\n  var image = /** @type {ol.Image} */ (event.target);\n  if (image.getState() === _ol_ImageState_.LOADED) {\n    this.renderIfReadyAndVisible();\n  }\n};\n\n\n/**\n * Load the image if not already loaded, and register the image change\n * listener if needed.\n * @param {ol.ImageBase} image Image.\n * @return {boolean} `true` if the image is already loaded, `false`\n *     otherwise.\n * @protected\n */\n_ol_renderer_Layer_.prototype.loadImage = function(image) {\n  var imageState = image.getState();\n  if (imageState != _ol_ImageState_.LOADED &&\n      imageState != _ol_ImageState_.ERROR) {\n    _ol_events_.listen(image, _ol_events_EventType_.CHANGE,\n        this.handleImageChange_, this);\n  }\n  if (imageState == _ol_ImageState_.IDLE) {\n    image.load();\n    imageState = image.getState();\n  }\n  return imageState == _ol_ImageState_.LOADED;\n};\n\n\n/**\n * @protected\n */\n_ol_renderer_Layer_.prototype.renderIfReadyAndVisible = function() {\n  var layer = this.getLayer();\n  if (layer.getVisible() && layer.getSourceState() == _ol_source_State_.READY) {\n    this.changed();\n  }\n};\n\n\n/**\n * @param {olx.FrameState} frameState Frame state.\n * @param {ol.source.Tile} tileSource Tile source.\n * @protected\n */\n_ol_renderer_Layer_.prototype.scheduleExpireCache = function(frameState, tileSource) {\n  if (tileSource.canExpireCache()) {\n    /**\n     * @param {ol.source.Tile} tileSource Tile source.\n     * @param {ol.PluggableMap} map Map.\n     * @param {olx.FrameState} frameState Frame state.\n     */\n    var postRenderFunction = function(tileSource, map, frameState) {\n      var tileSourceKey = _ol_.getUid(tileSource).toString();\n      if (tileSourceKey in frameState.usedTiles) {\n        tileSource.expireCache(frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]);\n      }\n    }.bind(null, tileSource);\n\n    frameState.postRenderFunctions.push(\n        /** @type {ol.PostRenderFunction} */ (postRenderFunction)\n    );\n  }\n};\n\n\n/**\n * @param {olx.FrameState} frameState Frame state.\n * @param {ol.source.Source} source Source.\n * @protected\n */\n_ol_renderer_Layer_.prototype.updateLogos = function(frameState, source) {\n  var logo = source.getLogo();\n  if (logo !== undefined) {\n    if (typeof logo === 'string') {\n      frameState.logos[logo] = '';\n    } else if (logo) {\n      _ol_asserts_.assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.\n      _ol_asserts_.assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.\n      frameState.logos[logo.src] = logo.href;\n    }\n  }\n};\n\n\n/**\n * @param {Object.<string, Object.<string, ol.TileRange>>} usedTiles Used tiles.\n * @param {ol.source.Tile} tileSource Tile source.\n * @param {number} z Z.\n * @param {ol.TileRange} tileRange Tile range.\n * @protected\n */\n_ol_renderer_Layer_.prototype.updateUsedTiles = function(usedTiles, tileSource, z, tileRange) {\n  // FIXME should we use tilesToDrawByZ instead?\n  var tileSourceKey = _ol_.getUid(tileSource).toString();\n  var zKey = z.toString();\n  if (tileSourceKey in usedTiles) {\n    if (zKey in usedTiles[tileSourceKey]) {\n      usedTiles[tileSourceKey][zKey].extend(tileRange);\n    } else {\n      usedTiles[tileSourceKey][zKey] = tileRange;\n    }\n  } else {\n    usedTiles[tileSourceKey] = {};\n    usedTiles[tileSourceKey][zKey] = tileRange;\n  }\n};\n\n\n/**\n * Manage tile pyramid.\n * This function performs a number of functions related to the tiles at the\n * current zoom and lower zoom levels:\n * - registers idle tiles in frameState.wantedTiles so that they are not\n *   discarded by the tile queue\n * - enqueues missing tiles\n * @param {olx.FrameState} frameState Frame state.\n * @param {ol.source.Tile} tileSource Tile source.\n * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.\n * @param {number} pixelRatio Pixel ratio.\n * @param {ol.proj.Projection} projection Projection.\n * @param {ol.Extent} extent Extent.\n * @param {number} currentZ Current Z.\n * @param {number} preload Load low resolution tiles up to 'preload' levels.\n * @param {function(this: T, ol.Tile)=} opt_tileCallback Tile callback.\n * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n * @protected\n * @template T\n */\n_ol_renderer_Layer_.prototype.manageTilePyramid = function(\n    frameState, tileSource, tileGrid, pixelRatio, projection, extent,\n    currentZ, preload, opt_tileCallback, opt_this) {\n  var tileSourceKey = _ol_.getUid(tileSource).toString();\n  if (!(tileSourceKey in frameState.wantedTiles)) {\n    frameState.wantedTiles[tileSourceKey] = {};\n  }\n  var wantedTiles = frameState.wantedTiles[tileSourceKey];\n  var tileQueue = frameState.tileQueue;\n  var minZoom = tileGrid.getMinZoom();\n  var tile, tileRange, tileResolution, x, y, z;\n  for (z = minZoom; z <= currentZ; ++z) {\n    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n    tileResolution = tileGrid.getResolution(z);\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (currentZ - z <= preload) {\n          tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n          if (tile.getState() == _ol_TileState_.IDLE) {\n            wantedTiles[tile.getKey()] = true;\n            if (!tileQueue.isKeyQueued(tile.getKey())) {\n              tileQueue.enqueue([tile, tileSourceKey,\n                tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n            }\n          }\n          if (opt_tileCallback !== undefined) {\n            opt_tileCallback.call(opt_this, tile);\n          }\n        } else {\n          tileSource.useTile(z, x, y, projection);\n        }\n      }\n    }\n  }\n};\nexport default _ol_renderer_Layer_;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _ol_ from '../../index.js';\nimport _ol_array_ from '../../array.js';\nimport _ol_colorlike_ from '../../colorlike.js';\nimport _ol_extent_ from '../../extent.js';\nimport _ol_extent_Relationship_ from '../../extent/relationship.js';\nimport _ol_geom_GeometryType_ from '../../geom/geometrytype.js';\nimport _ol_geom_flat_inflate_ from '../../geom/flat/inflate.js';\nimport _ol_geom_flat_length_ from '../../geom/flat/length.js';\nimport _ol_geom_flat_textpath_ from '../../geom/flat/textpath.js';\nimport _ol_geom_flat_transform_ from '../../geom/flat/transform.js';\nimport _ol_has_ from '../../has.js';\nimport _ol_obj_ from '../../obj.js';\nimport _ol_render_VectorContext_ from '../vectorcontext.js';\nimport _ol_render_canvas_ from '../canvas.js';\nimport _ol_render_canvas_Instruction_ from '../canvas/instruction.js';\nimport _ol_render_replay_ from '../replay.js';\nimport _ol_transform_ from '../../transform.js';\n/**\n * @constructor\n * @extends {ol.render.VectorContext}\n * @param {number} tolerance Tolerance.\n * @param {ol.Extent} maxExtent Maximum extent.\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {boolean} overlaps The replay can have overlapping geometries.\n * @param {?} declutterTree Declutter tree.\n * @struct\n */\n\nvar _ol_render_canvas_Replay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n  _ol_render_VectorContext_.call(this);\n  /**\n   * @type {?}\n   */\n\n\n  this.declutterTree = declutterTree;\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n\n  this.tmpExtent_ = _ol_extent_.createEmpty();\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.tolerance = tolerance;\n  /**\n   * @protected\n   * @const\n   * @type {ol.Extent}\n   */\n\n  this.maxExtent = maxExtent;\n  /**\n   * @protected\n   * @type {boolean}\n   */\n\n  this.overlaps = overlaps;\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.pixelRatio = pixelRatio;\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.maxLineWidth = 0;\n  /**\n   * @protected\n   * @const\n   * @type {number}\n   */\n\n  this.resolution = resolution;\n  /**\n   * @private\n   * @type {ol.Coordinate}\n   */\n\n  this.fillOrigin_;\n  /**\n   * @private\n   * @type {Array.<*>}\n   */\n\n  this.beginGeometryInstruction1_ = null;\n  /**\n   * @private\n   * @type {Array.<*>}\n   */\n\n  this.beginGeometryInstruction2_ = null;\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n\n  this.bufferedMaxExtent_ = null;\n  /**\n   * @protected\n   * @type {Array.<*>}\n   */\n\n  this.instructions = [];\n  /**\n   * @protected\n   * @type {Array.<number>}\n   */\n\n  this.coordinates = [];\n  /**\n   * @private\n   * @type {Object.<number,ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>>}\n   */\n\n  this.coordinateCache_ = {};\n  /**\n   * @private\n   * @type {!ol.Transform}\n   */\n\n  this.renderedTransform_ = _ol_transform_.create();\n  /**\n   * @protected\n   * @type {Array.<*>}\n   */\n\n  this.hitDetectionInstructions = [];\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this.pixelCoordinates_ = null;\n  /**\n   * @protected\n   * @type {ol.CanvasFillStrokeState}\n   */\n\n  this.state =\n  /** @type {ol.CanvasFillStrokeState} */\n  {};\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.viewRotation_ = 0;\n  /**\n   * @private\n   * @type {!ol.Transform}\n   */\n\n  this.tmpLocalTransform_ = _ol_transform_.create();\n  /**\n   * @private\n   * @type {!ol.Transform}\n   */\n\n  this.resetTransform_ = _ol_transform_.create();\n};\n\n_ol_.inherits(_ol_render_canvas_Replay_, _ol_render_VectorContext_);\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {ol.Coordinate} p1 1st point of the background box.\n * @param {ol.Coordinate} p2 2nd point of the background box.\n * @param {ol.Coordinate} p3 3rd point of the background box.\n * @param {ol.Coordinate} p4 4th point of the background box.\n * @param {Array.<*>} fillInstruction Fill instruction.\n * @param {Array.<*>} strokeInstruction Stroke instruction.\n */\n\n\n_ol_render_canvas_Replay_.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n  context.beginPath();\n  context.moveTo.apply(context, p1);\n  context.lineTo.apply(context, p2);\n  context.lineTo.apply(context, p3);\n  context.lineTo.apply(context, p4);\n  context.lineTo.apply(context, p1);\n\n  if (fillInstruction) {\n    this.fillOrigin_ =\n    /** @type {Array.<number>} */\n    fillInstruction[2];\n    this.fill_(context);\n  }\n\n  if (strokeInstruction) {\n    this.setStrokeStyle_(context,\n    /** @type {Array.<*>} */\n    strokeInstruction);\n    context.stroke();\n  }\n};\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n * @param {number} anchorX Anchor X.\n * @param {number} anchorY Anchor Y.\n * @param {ol.DeclutterGroup} declutterGroup Declutter group.\n * @param {number} height Height.\n * @param {number} opacity Opacity.\n * @param {number} originX Origin X.\n * @param {number} originY Origin Y.\n * @param {number} rotation Rotation.\n * @param {number} scale Scale.\n * @param {boolean} snapToPixel Snap to pixel.\n * @param {number} width Width.\n * @param {Array.<number>} padding Padding.\n * @param {Array.<*>} fillInstruction Fill instruction.\n * @param {Array.<*>} strokeInstruction Stroke instruction.\n */\n\n\n_ol_render_canvas_Replay_.prototype.replayImage_ = function (context, x, y, image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n  var fillStroke = fillInstruction || strokeInstruction;\n  var localTransform = this.tmpLocalTransform_;\n  anchorX *= scale;\n  anchorY *= scale;\n  x -= anchorX;\n  y -= anchorY;\n\n  if (snapToPixel) {\n    x = Math.round(x);\n    y = Math.round(y);\n  }\n\n  var w = width + originX > image.width ? image.width - originX : width;\n  var h = height + originY > image.height ? image.height - originY : height;\n  var box = this.tmpExtent_;\n  var boxW = padding[3] + w * scale + padding[1];\n  var boxH = padding[0] + h * scale + padding[2];\n  var boxX = x - padding[3];\n  var boxY = y - padding[0];\n  /** @type {ol.Coordinate} */\n\n  var p1;\n  /** @type {ol.Coordinate} */\n\n  var p2;\n  /** @type {ol.Coordinate} */\n\n  var p3;\n  /** @type {ol.Coordinate} */\n\n  var p4;\n\n  if (fillStroke || rotation !== 0) {\n    p1 = [boxX, boxY];\n    p2 = [boxX + boxW, boxY];\n    p3 = [boxX + boxW, boxY + boxH];\n    p4 = [boxX, boxY + boxH];\n  }\n\n  var transform = null;\n\n  if (rotation !== 0) {\n    var centerX = x + anchorX;\n    var centerY = y + anchorY;\n    transform = _ol_transform_.compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n\n    _ol_extent_.createOrUpdateEmpty(box);\n\n    _ol_extent_.extendCoordinate(box, _ol_transform_.apply(localTransform, p1));\n\n    _ol_extent_.extendCoordinate(box, _ol_transform_.apply(localTransform, p2));\n\n    _ol_extent_.extendCoordinate(box, _ol_transform_.apply(localTransform, p3));\n\n    _ol_extent_.extendCoordinate(box, _ol_transform_.apply(localTransform, p4));\n  } else {\n    _ol_extent_.createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, box);\n  }\n\n  var canvas = context.canvas;\n  var intersects = box[0] <= canvas.width && box[2] >= 0 && box[1] <= canvas.height && box[3] >= 0;\n\n  if (declutterGroup) {\n    if (!intersects && declutterGroup[4] == 1) {\n      return;\n    }\n\n    _ol_extent_.extend(declutterGroup, box);\n\n    var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] : null;\n\n    if (declutterArgs && fillStroke) {\n      declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\n    }\n\n    declutterGroup.push(declutterArgs);\n  } else if (intersects) {\n    if (fillStroke) {\n      this.replayTextBackground_(context, p1, p2, p3, p4,\n      /** @type {Array.<*>} */\n      fillInstruction,\n      /** @type {Array.<*>} */\n      strokeInstruction);\n    }\n\n    _ol_render_canvas_.drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\n  }\n};\n/**\n * @protected\n * @param {Array.<number>} dashArray Dash array.\n * @return {Array.<number>} Dash array with pixel ratio applied\n */\n\n\n_ol_render_canvas_Replay_.prototype.applyPixelRatio = function (dashArray) {\n  var pixelRatio = this.pixelRatio;\n  return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n    return dash * pixelRatio;\n  });\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {boolean} closed Last input coordinate equals first.\n * @param {boolean} skipFirst Skip first coordinate.\n * @protected\n * @return {number} My end.\n */\n\n\n_ol_render_canvas_Replay_.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {\n  var myEnd = this.coordinates.length;\n  var extent = this.getBufferedMaxExtent();\n\n  if (skipFirst) {\n    offset += stride;\n  }\n\n  var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n  var nextCoord = [NaN, NaN];\n  var skipped = true;\n  var i, lastRel, nextRel;\n\n  for (i = offset + stride; i < end; i += stride) {\n    nextCoord[0] = flatCoordinates[i];\n    nextCoord[1] = flatCoordinates[i + 1];\n    nextRel = _ol_extent_.coordinateRelationship(extent, nextCoord);\n\n    if (nextRel !== lastRel) {\n      if (skipped) {\n        this.coordinates[myEnd++] = lastCoord[0];\n        this.coordinates[myEnd++] = lastCoord[1];\n      }\n\n      this.coordinates[myEnd++] = nextCoord[0];\n      this.coordinates[myEnd++] = nextCoord[1];\n      skipped = false;\n    } else if (nextRel === _ol_extent_Relationship_.INTERSECTING) {\n      this.coordinates[myEnd++] = nextCoord[0];\n      this.coordinates[myEnd++] = nextCoord[1];\n      skipped = false;\n    } else {\n      skipped = true;\n    }\n\n    lastCoord[0] = nextCoord[0];\n    lastCoord[1] = nextCoord[1];\n    lastRel = nextRel;\n  } // Last coordinate equals first or only one point to append:\n\n\n  if (closed && skipped || i === offset + stride) {\n    this.coordinates[myEnd++] = lastCoord[0];\n    this.coordinates[myEnd++] = lastCoord[1];\n  }\n\n  return myEnd;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array.<number>} replayEnds Replay ends.\n * @return {number} Offset.\n */\n\n\n_ol_render_canvas_Replay_.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, replayEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n    replayEnds.push(replayEnd);\n    offset = end;\n  }\n\n  return offset;\n};\n/**\n * @inheritDoc.\n */\n\n\n_ol_render_canvas_Replay_.prototype.drawCustom = function (geometry, feature, renderer) {\n  this.beginGeometry(geometry, feature);\n  var type = geometry.getType();\n  var stride = geometry.getStride();\n  var replayBegin = this.coordinates.length;\n  var flatCoordinates, replayEnd, replayEnds, replayEndss;\n  var offset;\n\n  if (type == _ol_geom_GeometryType_.MULTI_POLYGON) {\n    geometry =\n    /** @type {ol.geom.MultiPolygon} */\n    geometry;\n    flatCoordinates = geometry.getOrientedFlatCoordinates();\n    replayEndss = [];\n    var endss = geometry.getEndss();\n    offset = 0;\n\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var myEnds = [];\n      offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n      replayEndss.push(myEnds);\n    }\n\n    this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM, replayBegin, replayEndss, geometry, renderer, _ol_geom_flat_inflate_.coordinatesss]);\n  } else if (type == _ol_geom_GeometryType_.POLYGON || type == _ol_geom_GeometryType_.MULTI_LINE_STRING) {\n    replayEnds = [];\n    flatCoordinates = type == _ol_geom_GeometryType_.POLYGON ?\n    /** @type {ol.geom.Polygon} */\n    geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n    offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n    /** @type {ol.geom.Polygon|ol.geom.MultiLineString} */\n    geometry.getEnds(), stride, replayEnds);\n    this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM, replayBegin, replayEnds, geometry, renderer, _ol_geom_flat_inflate_.coordinatess]);\n  } else if (type == _ol_geom_GeometryType_.LINE_STRING || type == _ol_geom_GeometryType_.MULTI_POINT) {\n    flatCoordinates = geometry.getFlatCoordinates();\n    replayEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM, replayBegin, replayEnd, geometry, renderer, _ol_geom_flat_inflate_.coordinates]);\n  } else if (type == _ol_geom_GeometryType_.POINT) {\n    flatCoordinates = geometry.getFlatCoordinates();\n    this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n    replayEnd = this.coordinates.length;\n    this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM, replayBegin, replayEnd, geometry, renderer]);\n  }\n\n  this.endGeometry(geometry, feature);\n};\n/**\n * @protected\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n * @param {ol.Feature|ol.render.Feature} feature Feature.\n */\n\n\n_ol_render_canvas_Replay_.prototype.beginGeometry = function (geometry, feature) {\n  this.beginGeometryInstruction1_ = [_ol_render_canvas_Instruction_.BEGIN_GEOMETRY, feature, 0];\n  this.instructions.push(this.beginGeometryInstruction1_);\n  this.beginGeometryInstruction2_ = [_ol_render_canvas_Instruction_.BEGIN_GEOMETRY, feature, 0];\n  this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n};\n/**\n * @private\n * @param {CanvasRenderingContext2D} context Context.\n */\n\n\n_ol_render_canvas_Replay_.prototype.fill_ = function (context) {\n  if (this.fillOrigin_) {\n    var origin = _ol_transform_.apply(this.renderedTransform_, this.fillOrigin_.slice());\n\n    context.translate(origin[0], origin[1]);\n    context.rotate(this.viewRotation_);\n  }\n\n  context.fill();\n\n  if (this.fillOrigin_) {\n    context.setTransform.apply(context, _ol_render_canvas_.resetTransform_);\n  }\n};\n/**\n * @private\n * @param {CanvasRenderingContext2D} context Context.\n * @param {Array.<*>} instruction Instruction.\n */\n\n\n_ol_render_canvas_Replay_.prototype.setStrokeStyle_ = function (context, instruction) {\n  context.strokeStyle =\n  /** @type {ol.ColorLike} */\n  instruction[1];\n  context.lineWidth =\n  /** @type {number} */\n  instruction[2];\n  context.lineCap =\n  /** @type {string} */\n  instruction[3];\n  context.lineJoin =\n  /** @type {string} */\n  instruction[4];\n  context.miterLimit =\n  /** @type {number} */\n  instruction[5];\n\n  if (_ol_has_.CANVAS_LINE_DASH) {\n    context.lineDashOffset =\n    /** @type {number} */\n    instruction[7];\n    context.setLineDash(\n    /** @type {Array.<number>} */\n    instruction[6]);\n  }\n};\n/**\n * @param {ol.DeclutterGroup} declutterGroup Declutter group.\n * @param {ol.Feature|ol.render.Feature} feature Feature.\n */\n\n\n_ol_render_canvas_Replay_.prototype.renderDeclutter_ = function (declutterGroup, feature) {\n  if (declutterGroup && declutterGroup.length > 5) {\n    var groupCount = declutterGroup[4];\n\n    if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\n      /** @type {ol.RBushEntry} */\n      var box = {\n        minX:\n        /** @type {number} */\n        declutterGroup[0],\n        minY:\n        /** @type {number} */\n        declutterGroup[1],\n        maxX:\n        /** @type {number} */\n        declutterGroup[2],\n        maxY:\n        /** @type {number} */\n        declutterGroup[3],\n        value: feature\n      };\n\n      if (!this.declutterTree.collides(box)) {\n        this.declutterTree.insert(box);\n        var drawImage = _ol_render_canvas_.drawImage;\n\n        for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {\n          var declutterData =\n          /** @type {Array} */\n          declutterGroup[j];\n\n          if (declutterData) {\n            if (declutterData.length > 11) {\n              this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);\n            }\n\n            drawImage.apply(undefined, declutterData);\n          }\n        }\n      }\n\n      declutterGroup.length = 5;\n\n      _ol_extent_.createOrUpdateEmpty(declutterGroup);\n    }\n  }\n};\n/**\n * @private\n * @param {CanvasRenderingContext2D} context Context.\n * @param {ol.Transform} transform Transform.\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n *     to skip.\n * @param {Array.<*>} instructions Instructions array.\n * @param {function((ol.Feature|ol.render.Feature)): T|undefined}\n *     featureCallback Feature callback.\n * @param {ol.Extent=} opt_hitExtent Only check features that intersect this\n *     extent.\n * @return {T|undefined} Callback result.\n * @template T\n */\n\n\n_ol_render_canvas_Replay_.prototype.replay_ = function (context, transform, skippedFeaturesHash, instructions, featureCallback, opt_hitExtent) {\n  /** @type {Array.<number>} */\n  var pixelCoordinates;\n\n  if (this.pixelCoordinates_ && _ol_array_.equals(transform, this.renderedTransform_)) {\n    pixelCoordinates = this.pixelCoordinates_;\n  } else {\n    if (!this.pixelCoordinates_) {\n      this.pixelCoordinates_ = [];\n    }\n\n    pixelCoordinates = _ol_geom_flat_transform_.transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n\n    _ol_transform_.setFromArray(this.renderedTransform_, transform);\n  }\n\n  var skipFeatures = !_ol_obj_.isEmpty(skippedFeaturesHash);\n  var i = 0; // instruction index\n\n  var ii = instructions.length; // end of instructions\n\n  var d = 0; // data index\n\n  var dd; // end of per-instruction data\n\n  var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\n  var pendingFill = 0;\n  var pendingStroke = 0;\n  var lastFillInstruction = null;\n  var lastStrokeInstruction = null;\n  var coordinateCache = this.coordinateCache_;\n  var viewRotation = this.viewRotation_;\n  var state =\n  /** @type {olx.render.State} */\n  {\n    context: context,\n    pixelRatio: this.pixelRatio,\n    resolution: this.resolution,\n    rotation: viewRotation\n  }; // When the batch size gets too big, performance decreases. 200 is a good\n  // balance between batch size and number of fill/stroke instructions.\n\n  var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n\n  while (i < ii) {\n    var instruction = instructions[i];\n    var type =\n    /** @type {ol.render.canvas.Instruction} */\n    instruction[0];\n    var\n    /** @type {ol.Feature|ol.render.Feature} */\n    feature, x, y;\n\n    switch (type) {\n      case _ol_render_canvas_Instruction_.BEGIN_GEOMETRY:\n        feature =\n        /** @type {ol.Feature|ol.render.Feature} */\n        instruction[1];\n\n        if (skipFeatures && skippedFeaturesHash[_ol_.getUid(feature).toString()] || !feature.getGeometry()) {\n          i =\n          /** @type {number} */\n          instruction[2];\n        } else if (opt_hitExtent !== undefined && !_ol_extent_.intersects(opt_hitExtent, feature.getGeometry().getExtent())) {\n          i =\n          /** @type {number} */\n          instruction[2] + 1;\n        } else {\n          ++i;\n        }\n\n        break;\n\n      case _ol_render_canvas_Instruction_.BEGIN_PATH:\n        if (pendingFill > batchSize) {\n          this.fill_(context);\n          pendingFill = 0;\n        }\n\n        if (pendingStroke > batchSize) {\n          context.stroke();\n          pendingStroke = 0;\n        }\n\n        if (!pendingFill && !pendingStroke) {\n          context.beginPath();\n          prevX = prevY = NaN;\n        }\n\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.CIRCLE:\n        d =\n        /** @type {number} */\n        instruction[1];\n        var x1 = pixelCoordinates[d];\n        var y1 = pixelCoordinates[d + 1];\n        var x2 = pixelCoordinates[d + 2];\n        var y2 = pixelCoordinates[d + 3];\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var r = Math.sqrt(dx * dx + dy * dy);\n        context.moveTo(x1 + r, y1);\n        context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.CLOSE_PATH:\n        context.closePath();\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.CUSTOM:\n        d =\n        /** @type {number} */\n        instruction[1];\n        dd = instruction[2];\n        var geometry =\n        /** @type {ol.geom.SimpleGeometry} */\n        instruction[3];\n        var renderer = instruction[4];\n        var fn = instruction.length == 6 ? instruction[5] : undefined;\n        state.geometry = geometry;\n        state.feature = feature;\n\n        if (!(i in coordinateCache)) {\n          coordinateCache[i] = [];\n        }\n\n        var coords = coordinateCache[i];\n\n        if (fn) {\n          fn(pixelCoordinates, d, dd, 2, coords);\n        } else {\n          coords[0] = pixelCoordinates[d];\n          coords[1] = pixelCoordinates[d + 1];\n          coords.length = 2;\n        }\n\n        renderer(coords, state);\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.DRAW_IMAGE:\n        d =\n        /** @type {number} */\n        instruction[1];\n        dd =\n        /** @type {number} */\n        instruction[2];\n        image =\n        /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */\n        instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order\n\n        anchorX =\n        /** @type {number} */\n        instruction[4];\n        anchorY =\n        /** @type {number} */\n        instruction[5];\n        declutterGroup = featureCallback ? null :\n        /** @type {ol.DeclutterGroup} */\n        instruction[6];\n        var height =\n        /** @type {number} */\n        instruction[7];\n        var opacity =\n        /** @type {number} */\n        instruction[8];\n        var originX =\n        /** @type {number} */\n        instruction[9];\n        var originY =\n        /** @type {number} */\n        instruction[10];\n        var rotateWithView =\n        /** @type {boolean} */\n        instruction[11];\n        var rotation =\n        /** @type {number} */\n        instruction[12];\n        var scale =\n        /** @type {number} */\n        instruction[13];\n        var snapToPixel =\n        /** @type {boolean} */\n        instruction[14];\n        var width =\n        /** @type {number} */\n        instruction[15];\n        var padding, backgroundFill, backgroundStroke;\n\n        if (instruction.length > 16) {\n          padding =\n          /** @type {Array.<number>} */\n          instruction[16];\n          backgroundFill =\n          /** @type {boolean} */\n          instruction[17];\n          backgroundStroke =\n          /** @type {boolean} */\n          instruction[18];\n        } else {\n          padding = _ol_render_canvas_.defaultPadding;\n          backgroundFill = backgroundStroke = false;\n        }\n\n        if (rotateWithView) {\n          rotation += viewRotation;\n        }\n\n        for (; d < dd; d += 2) {\n          this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ?\n          /** @type {Array.<*>} */\n          lastFillInstruction : null, backgroundStroke ?\n          /** @type {Array.<*>} */\n          lastStrokeInstruction : null);\n        }\n\n        this.renderDeclutter_(declutterGroup, feature);\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.DRAW_CHARS:\n        var begin =\n        /** @type {number} */\n        instruction[1];\n        var end =\n        /** @type {number} */\n        instruction[2];\n        var baseline =\n        /** @type {number} */\n        instruction[3];\n        declutterGroup = featureCallback ? null :\n        /** @type {ol.DeclutterGroup} */\n        instruction[4];\n        var overflow =\n        /** @type {number} */\n        instruction[5];\n        var fillKey =\n        /** @type {string} */\n        instruction[6];\n        var maxAngle =\n        /** @type {number} */\n        instruction[7];\n        var measure =\n        /** @type {function(string):number} */\n        instruction[8];\n        var offsetY =\n        /** @type {number} */\n        instruction[9];\n        var strokeKey =\n        /** @type {string} */\n        instruction[10];\n        var strokeWidth =\n        /** @type {number} */\n        instruction[11];\n        var text =\n        /** @type {string} */\n        instruction[12];\n        var textKey =\n        /** @type {string} */\n        instruction[13];\n        var textScale =\n        /** @type {number} */\n        instruction[14];\n\n        var pathLength = _ol_geom_flat_length_.lineString(pixelCoordinates, begin, end, 2);\n\n        var textLength = measure(text);\n\n        if (overflow || textLength <= pathLength) {\n          var textAlign =\n          /** @type {ol.render.canvas.TextReplay} */\n          this.textStates[textKey].textAlign;\n          var startM = (pathLength - textLength) * _ol_render_replay_.TEXT_ALIGN[textAlign];\n\n          var parts = _ol_geom_flat_textpath_.lineString(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\n\n          if (parts) {\n            var c, cc, chars, label, part;\n\n            if (strokeKey) {\n              for (c = 0, cc = parts.length; c < cc; ++c) {\n                part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                chars =\n                /** @type {string} */\n                part[4];\n                label =\n                /** @type {ol.render.canvas.TextReplay} */\n                this.getImage(chars, textKey, '', strokeKey);\n                anchorX =\n                /** @type {number} */\n                part[2] + strokeWidth;\n                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\n                this.replayImage_(context,\n                /** @type {number} */\n                part[0],\n                /** @type {number} */\n                part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                /** @type {number} */\n                part[3], textScale, false, label.width, _ol_render_canvas_.defaultPadding, null, null);\n              }\n            }\n\n            if (fillKey) {\n              for (c = 0, cc = parts.length; c < cc; ++c) {\n                part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                chars =\n                /** @type {string} */\n                part[4];\n                label =\n                /** @type {ol.render.canvas.TextReplay} */\n                this.getImage(chars, textKey, fillKey, '');\n                anchorX =\n                /** @type {number} */\n                part[2];\n                anchorY = baseline * label.height - offsetY;\n                this.replayImage_(context,\n                /** @type {number} */\n                part[0],\n                /** @type {number} */\n                part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                /** @type {number} */\n                part[3], textScale, false, label.width, _ol_render_canvas_.defaultPadding, null, null);\n              }\n            }\n          }\n        }\n\n        this.renderDeclutter_(declutterGroup, feature);\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.END_GEOMETRY:\n        if (featureCallback !== undefined) {\n          feature =\n          /** @type {ol.Feature|ol.render.Feature} */\n          instruction[1];\n          var result = featureCallback(feature);\n\n          if (result) {\n            return result;\n          }\n        }\n\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.FILL:\n        if (batchSize) {\n          pendingFill++;\n        } else {\n          this.fill_(context);\n        }\n\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.MOVE_TO_LINE_TO:\n        d =\n        /** @type {number} */\n        instruction[1];\n        dd =\n        /** @type {number} */\n        instruction[2];\n        x = pixelCoordinates[d];\n        y = pixelCoordinates[d + 1];\n        roundX = x + 0.5 | 0;\n        roundY = y + 0.5 | 0;\n\n        if (roundX !== prevX || roundY !== prevY) {\n          context.moveTo(x, y);\n          prevX = roundX;\n          prevY = roundY;\n        }\n\n        for (d += 2; d < dd; d += 2) {\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n\n          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n            context.lineTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n        }\n\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.SET_FILL_STYLE:\n        lastFillInstruction = instruction;\n        this.fillOrigin_ = instruction[2];\n\n        if (pendingFill) {\n          this.fill_(context);\n          pendingFill = 0;\n\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n        }\n\n        context.fillStyle =\n        /** @type {ol.ColorLike} */\n        instruction[1];\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.SET_STROKE_STYLE:\n        lastStrokeInstruction = instruction;\n\n        if (pendingStroke) {\n          context.stroke();\n          pendingStroke = 0;\n        }\n\n        this.setStrokeStyle_(context,\n        /** @type {Array.<*>} */\n        instruction);\n        ++i;\n        break;\n\n      case _ol_render_canvas_Instruction_.STROKE:\n        if (batchSize) {\n          pendingStroke++;\n        } else {\n          context.stroke();\n        }\n\n        ++i;\n        break;\n\n      default:\n        ++i; // consume the instruction anyway, to avoid an infinite loop\n\n        break;\n    }\n  }\n\n  if (pendingFill) {\n    this.fill_(context);\n  }\n\n  if (pendingStroke) {\n    context.stroke();\n  }\n\n  return undefined;\n};\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {ol.Transform} transform Transform.\n * @param {number} viewRotation View rotation.\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n *     to skip.\n */\n\n\n_ol_render_canvas_Replay_.prototype.replay = function (context, transform, viewRotation, skippedFeaturesHash) {\n  this.viewRotation_ = viewRotation;\n  this.replay_(context, transform, skippedFeaturesHash, this.instructions, undefined, undefined);\n};\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {ol.Transform} transform Transform.\n * @param {number} viewRotation View rotation.\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n *     to skip.\n * @param {function((ol.Feature|ol.render.Feature)): T=} opt_featureCallback\n *     Feature callback.\n * @param {ol.Extent=} opt_hitExtent Only check features that intersect this\n *     extent.\n * @return {T|undefined} Callback result.\n * @template T\n */\n\n\n_ol_render_canvas_Replay_.prototype.replayHitDetection = function (context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {\n  this.viewRotation_ = viewRotation;\n  return this.replay_(context, transform, skippedFeaturesHash, this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);\n};\n/**\n * Reverse the hit detection instructions.\n */\n\n\n_ol_render_canvas_Replay_.prototype.reverseHitDetectionInstructions = function () {\n  var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array\n\n  hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks\n\n  var i;\n  var n = hitDetectionInstructions.length;\n  var instruction;\n  var type;\n  var begin = -1;\n\n  for (i = 0; i < n; ++i) {\n    instruction = hitDetectionInstructions[i];\n    type =\n    /** @type {ol.render.canvas.Instruction} */\n    instruction[0];\n\n    if (type == _ol_render_canvas_Instruction_.END_GEOMETRY) {\n      begin = i;\n    } else if (type == _ol_render_canvas_Instruction_.BEGIN_GEOMETRY) {\n      instruction[2] = i;\n\n      _ol_array_.reverseSubArray(this.hitDetectionInstructions, begin, i);\n\n      begin = -1;\n    }\n  }\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_canvas_Replay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {\n  var state = this.state;\n\n  if (fillStyle) {\n    var fillStyleColor = fillStyle.getColor();\n    state.fillStyle = _ol_colorlike_.asColorLike(fillStyleColor ? fillStyleColor : _ol_render_canvas_.defaultFillStyle);\n  } else {\n    state.fillStyle = undefined;\n  }\n\n  if (strokeStyle) {\n    var strokeStyleColor = strokeStyle.getColor();\n    state.strokeStyle = _ol_colorlike_.asColorLike(strokeStyleColor ? strokeStyleColor : _ol_render_canvas_.defaultStrokeStyle);\n    var strokeStyleLineCap = strokeStyle.getLineCap();\n    state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _ol_render_canvas_.defaultLineCap;\n    var strokeStyleLineDash = strokeStyle.getLineDash();\n    state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : _ol_render_canvas_.defaultLineDash;\n    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n    state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _ol_render_canvas_.defaultLineDashOffset;\n    var strokeStyleLineJoin = strokeStyle.getLineJoin();\n    state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _ol_render_canvas_.defaultLineJoin;\n    var strokeStyleWidth = strokeStyle.getWidth();\n    state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _ol_render_canvas_.defaultLineWidth;\n    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n    state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _ol_render_canvas_.defaultMiterLimit;\n\n    if (state.lineWidth > this.maxLineWidth) {\n      this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache\n\n      this.bufferedMaxExtent_ = null;\n    }\n  } else {\n    state.strokeStyle = undefined;\n    state.lineCap = undefined;\n    state.lineDash = null;\n    state.lineDashOffset = undefined;\n    state.lineJoin = undefined;\n    state.lineWidth = undefined;\n    state.miterLimit = undefined;\n  }\n};\n/**\n * @param {ol.CanvasFillStrokeState} state State.\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n */\n\n\n_ol_render_canvas_Replay_.prototype.applyFill = function (state, geometry) {\n  var fillStyle = state.fillStyle;\n  var fillInstruction = [_ol_render_canvas_Instruction_.SET_FILL_STYLE, fillStyle];\n\n  if (typeof fillStyle !== 'string') {\n    var fillExtent = geometry.getExtent();\n    fillInstruction.push([fillExtent[0], fillExtent[3]]);\n  }\n\n  this.instructions.push(fillInstruction);\n};\n/**\n * @param {ol.CanvasFillStrokeState} state State.\n */\n\n\n_ol_render_canvas_Replay_.prototype.applyStroke = function (state) {\n  this.instructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio]);\n};\n/**\n * @param {ol.CanvasFillStrokeState} state State.\n * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState, (ol.geom.Geometry|ol.render.Feature))} applyFill Apply fill.\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n */\n\n\n_ol_render_canvas_Replay_.prototype.updateFillStyle = function (state, applyFill, geometry) {\n  var fillStyle = state.fillStyle;\n\n  if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n    applyFill.call(this, state, geometry);\n    state.currentFillStyle = fillStyle;\n  }\n};\n/**\n * @param {ol.CanvasFillStrokeState} state State.\n * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState)} applyStroke Apply stroke.\n */\n\n\n_ol_render_canvas_Replay_.prototype.updateStrokeStyle = function (state, applyStroke) {\n  var strokeStyle = state.strokeStyle;\n  var lineCap = state.lineCap;\n  var lineDash = state.lineDash;\n  var lineDashOffset = state.lineDashOffset;\n  var lineJoin = state.lineJoin;\n  var lineWidth = state.lineWidth;\n  var miterLimit = state.miterLimit;\n\n  if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !_ol_array_.equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n    applyStroke.call(this, state);\n    state.currentStrokeStyle = strokeStyle;\n    state.currentLineCap = lineCap;\n    state.currentLineDash = lineDash;\n    state.currentLineDashOffset = lineDashOffset;\n    state.currentLineJoin = lineJoin;\n    state.currentLineWidth = lineWidth;\n    state.currentMiterLimit = miterLimit;\n  }\n};\n/**\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n * @param {ol.Feature|ol.render.Feature} feature Feature.\n */\n\n\n_ol_render_canvas_Replay_.prototype.endGeometry = function (geometry, feature) {\n  this.beginGeometryInstruction1_[2] = this.instructions.length;\n  this.beginGeometryInstruction1_ = null;\n  this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n  this.beginGeometryInstruction2_ = null;\n  var endGeometryInstruction = [_ol_render_canvas_Instruction_.END_GEOMETRY, feature];\n  this.instructions.push(endGeometryInstruction);\n  this.hitDetectionInstructions.push(endGeometryInstruction);\n};\n/**\n * FIXME empty description for jsdoc\n */\n\n\n_ol_render_canvas_Replay_.prototype.finish = _ol_.nullFunction;\n/**\n * Get the buffered rendering extent.  Rendering will be clipped to the extent\n * provided to the constructor.  To account for symbolizers that may intersect\n * this extent, we calculate a buffered extent (e.g. based on stroke width).\n * @return {ol.Extent} The buffered rendering extent.\n * @protected\n */\n\n_ol_render_canvas_Replay_.prototype.getBufferedMaxExtent = function () {\n  if (!this.bufferedMaxExtent_) {\n    this.bufferedMaxExtent_ = _ol_extent_.clone(this.maxExtent);\n\n    if (this.maxLineWidth > 0) {\n      var width = this.resolution * (this.maxLineWidth + 1) / 2;\n\n      _ol_extent_.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n    }\n  }\n\n  return this.bufferedMaxExtent_;\n};\n\nexport default _ol_render_canvas_Replay_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/render/canvas/replay.js"],"names":["_ol_","_ol_array_","_ol_colorlike_","_ol_extent_","_ol_extent_Relationship_","_ol_geom_GeometryType_","_ol_geom_flat_inflate_","_ol_geom_flat_length_","_ol_geom_flat_textpath_","_ol_geom_flat_transform_","_ol_has_","_ol_obj_","_ol_render_VectorContext_","_ol_render_canvas_","_ol_render_canvas_Instruction_","_ol_render_replay_","_ol_transform_","_ol_render_canvas_Replay_","tolerance","maxExtent","resolution","pixelRatio","overlaps","declutterTree","call","tmpExtent_","createEmpty","maxLineWidth","fillOrigin_","beginGeometryInstruction1_","beginGeometryInstruction2_","bufferedMaxExtent_","instructions","coordinates","coordinateCache_","renderedTransform_","create","hitDetectionInstructions","pixelCoordinates_","state","viewRotation_","tmpLocalTransform_","resetTransform_","inherits","prototype","replayTextBackground_","context","p1","p2","p3","p4","fillInstruction","strokeInstruction","beginPath","moveTo","apply","lineTo","fill_","setStrokeStyle_","stroke","replayImage_","x","y","image","anchorX","anchorY","declutterGroup","height","opacity","originX","originY","rotation","scale","snapToPixel","width","padding","fillStroke","localTransform","Math","round","w","h","box","boxW","boxH","boxX","boxY","transform","centerX","centerY","compose","createOrUpdateEmpty","extendCoordinate","createOrUpdate","canvas","intersects","extend","declutterArgs","slice","push","drawImage","applyPixelRatio","dashArray","map","dash","appendFlatCoordinates","flatCoordinates","offset","end","stride","closed","skipFirst","myEnd","length","extent","getBufferedMaxExtent","lastCoord","nextCoord","NaN","skipped","i","lastRel","nextRel","coordinateRelationship","INTERSECTING","drawCustomCoordinates_","ends","replayEnds","ii","replayEnd","drawCustom","geometry","feature","renderer","beginGeometry","type","getType","getStride","replayBegin","replayEndss","MULTI_POLYGON","getOrientedFlatCoordinates","endss","getEndss","myEnds","CUSTOM","coordinatesss","POLYGON","MULTI_LINE_STRING","getFlatCoordinates","getEnds","coordinatess","LINE_STRING","MULTI_POINT","POINT","endGeometry","BEGIN_GEOMETRY","origin","translate","rotate","fill","setTransform","instruction","strokeStyle","lineWidth","lineCap","lineJoin","miterLimit","CANVAS_LINE_DASH","lineDashOffset","setLineDash","renderDeclutter_","groupCount","minX","minY","maxX","maxY","value","collides","insert","j","jj","declutterData","undefined","replay_","skippedFeaturesHash","featureCallback","opt_hitExtent","pixelCoordinates","equals","transform2D","setFromArray","skipFeatures","isEmpty","d","dd","prevX","prevY","roundX","roundY","pendingFill","pendingStroke","lastFillInstruction","lastStrokeInstruction","coordinateCache","viewRotation","batchSize","getUid","toString","getGeometry","getExtent","BEGIN_PATH","CIRCLE","x1","y1","x2","y2","dx","dy","r","sqrt","arc","PI","CLOSE_PATH","closePath","fn","coords","DRAW_IMAGE","rotateWithView","backgroundFill","backgroundStroke","defaultPadding","DRAW_CHARS","begin","baseline","overflow","fillKey","maxAngle","measure","offsetY","strokeKey","strokeWidth","text","textKey","textScale","pathLength","lineString","textLength","textAlign","textStates","startM","TEXT_ALIGN","parts","c","cc","chars","label","part","getImage","END_GEOMETRY","result","FILL","MOVE_TO_LINE_TO","SET_FILL_STYLE","fillStyle","SET_STROKE_STYLE","STROKE","replay","replayHitDetection","opt_featureCallback","reverseHitDetectionInstructions","reverse","n","reverseSubArray","setFillStrokeStyle","fillStyleColor","getColor","asColorLike","defaultFillStyle","strokeStyleColor","defaultStrokeStyle","strokeStyleLineCap","getLineCap","defaultLineCap","strokeStyleLineDash","getLineDash","lineDash","defaultLineDash","strokeStyleLineDashOffset","getLineDashOffset","defaultLineDashOffset","strokeStyleLineJoin","getLineJoin","defaultLineJoin","strokeStyleWidth","getWidth","defaultLineWidth","strokeStyleMiterLimit","getMiterLimit","defaultMiterLimit","applyFill","fillExtent","applyStroke","updateFillStyle","currentFillStyle","updateStrokeStyle","currentStrokeStyle","currentLineCap","currentLineDash","currentLineDashOffset","currentLineJoin","currentLineWidth","currentMiterLimit","endGeometryInstruction","finish","nullFunction","clone","buffer"],"mappings":"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","sourcesContent":["import _ol_ from '../../index.js';\nimport _ol_array_ from '../../array.js';\nimport _ol_colorlike_ from '../../colorlike.js';\nimport _ol_extent_ from '../../extent.js';\nimport _ol_extent_Relationship_ from '../../extent/relationship.js';\nimport _ol_geom_GeometryType_ from '../../geom/geometrytype.js';\nimport _ol_geom_flat_inflate_ from '../../geom/flat/inflate.js';\nimport _ol_geom_flat_length_ from '../../geom/flat/length.js';\nimport _ol_geom_flat_textpath_ from '../../geom/flat/textpath.js';\nimport _ol_geom_flat_transform_ from '../../geom/flat/transform.js';\nimport _ol_has_ from '../../has.js';\nimport _ol_obj_ from '../../obj.js';\nimport _ol_render_VectorContext_ from '../vectorcontext.js';\nimport _ol_render_canvas_ from '../canvas.js';\nimport _ol_render_canvas_Instruction_ from '../canvas/instruction.js';\nimport _ol_render_replay_ from '../replay.js';\nimport _ol_transform_ from '../../transform.js';\n\n/**\n * @constructor\n * @extends {ol.render.VectorContext}\n * @param {number} tolerance Tolerance.\n * @param {ol.Extent} maxExtent Maximum extent.\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {boolean} overlaps The replay can have overlapping geometries.\n * @param {?} declutterTree Declutter tree.\n * @struct\n */\nvar _ol_render_canvas_Replay_ = function(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n  _ol_render_VectorContext_.call(this);\n\n  /**\n   * @type {?}\n   */\n  this.declutterTree = declutterTree;\n\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n  this.tmpExtent_ = _ol_extent_.createEmpty();\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.tolerance = tolerance;\n\n  /**\n   * @protected\n   * @const\n   * @type {ol.Extent}\n   */\n  this.maxExtent = maxExtent;\n\n  /**\n   * @protected\n   * @type {boolean}\n   */\n  this.overlaps = overlaps;\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.pixelRatio = pixelRatio;\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.maxLineWidth = 0;\n\n  /**\n   * @protected\n   * @const\n   * @type {number}\n   */\n  this.resolution = resolution;\n\n  /**\n   * @private\n   * @type {ol.Coordinate}\n   */\n  this.fillOrigin_;\n\n  /**\n   * @private\n   * @type {Array.<*>}\n   */\n  this.beginGeometryInstruction1_ = null;\n\n  /**\n   * @private\n   * @type {Array.<*>}\n   */\n  this.beginGeometryInstruction2_ = null;\n\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n  this.bufferedMaxExtent_ = null;\n\n  /**\n   * @protected\n   * @type {Array.<*>}\n   */\n  this.instructions = [];\n\n  /**\n   * @protected\n   * @type {Array.<number>}\n   */\n  this.coordinates = [];\n\n  /**\n   * @private\n   * @type {Object.<number,ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>>}\n   */\n  this.coordinateCache_ = {};\n\n  /**\n   * @private\n   * @type {!ol.Transform}\n   */\n  this.renderedTransform_ = _ol_transform_.create();\n\n  /**\n   * @protected\n   * @type {Array.<*>}\n   */\n  this.hitDetectionInstructions = [];\n\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n  this.pixelCoordinates_ = null;\n\n  /**\n   * @protected\n   * @type {ol.CanvasFillStrokeState}\n   */\n  this.state = /** @type {ol.CanvasFillStrokeState} */ ({});\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.viewRotation_ = 0;\n\n  /**\n   * @private\n   * @type {!ol.Transform}\n   */\n  this.tmpLocalTransform_ = _ol_transform_.create();\n\n  /**\n   * @private\n   * @type {!ol.Transform}\n   */\n  this.resetTransform_ = _ol_transform_.create();\n};\n\n_ol_.inherits(_ol_render_canvas_Replay_, _ol_render_VectorContext_);\n\n\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {ol.Coordinate} p1 1st point of the background box.\n * @param {ol.Coordinate} p2 2nd point of the background box.\n * @param {ol.Coordinate} p3 3rd point of the background box.\n * @param {ol.Coordinate} p4 4th point of the background box.\n * @param {Array.<*>} fillInstruction Fill instruction.\n * @param {Array.<*>} strokeInstruction Stroke instruction.\n */\n_ol_render_canvas_Replay_.prototype.replayTextBackground_ = function(context, p1, p2, p3, p4,\n    fillInstruction, strokeInstruction) {\n  context.beginPath();\n  context.moveTo.apply(context, p1);\n  context.lineTo.apply(context, p2);\n  context.lineTo.apply(context, p3);\n  context.lineTo.apply(context, p4);\n  context.lineTo.apply(context, p1);\n  if (fillInstruction) {\n    this.fillOrigin_ = /** @type {Array.<number>} */ (fillInstruction[2]);\n    this.fill_(context);\n  }\n  if (strokeInstruction) {\n    this.setStrokeStyle_(context, /** @type {Array.<*>} */ (strokeInstruction));\n    context.stroke();\n  }\n};\n\n\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n * @param {number} anchorX Anchor X.\n * @param {number} anchorY Anchor Y.\n * @param {ol.DeclutterGroup} declutterGroup Declutter group.\n * @param {number} height Height.\n * @param {number} opacity Opacity.\n * @param {number} originX Origin X.\n * @param {number} originY Origin Y.\n * @param {number} rotation Rotation.\n * @param {number} scale Scale.\n * @param {boolean} snapToPixel Snap to pixel.\n * @param {number} width Width.\n * @param {Array.<number>} padding Padding.\n * @param {Array.<*>} fillInstruction Fill instruction.\n * @param {Array.<*>} strokeInstruction Stroke instruction.\n */\n_ol_render_canvas_Replay_.prototype.replayImage_ = function(context, x, y, image,\n    anchorX, anchorY, declutterGroup, height, opacity, originX, originY,\n    rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n  var fillStroke = fillInstruction || strokeInstruction;\n  var localTransform = this.tmpLocalTransform_;\n  anchorX *= scale;\n  anchorY *= scale;\n  x -= anchorX;\n  y -= anchorY;\n  if (snapToPixel) {\n    x = Math.round(x);\n    y = Math.round(y);\n  }\n\n  var w = (width + originX > image.width) ? image.width - originX : width;\n  var h = (height + originY > image.height) ? image.height - originY : height;\n  var box = this.tmpExtent_;\n  var boxW = padding[3] + w * scale + padding[1];\n  var boxH = padding[0] + h * scale + padding[2];\n  var boxX = x - padding[3];\n  var boxY = y - padding[0];\n\n  /** @type {ol.Coordinate} */\n  var p1;\n  /** @type {ol.Coordinate} */\n  var p2;\n  /** @type {ol.Coordinate} */\n  var p3;\n  /** @type {ol.Coordinate} */\n  var p4;\n  if (fillStroke || rotation !== 0) {\n    p1 = [boxX, boxY];\n    p2 = [boxX + boxW, boxY];\n    p3 = [boxX + boxW, boxY + boxH];\n    p4 = [boxX, boxY + boxH];\n  }\n\n  var transform = null;\n  if (rotation !== 0) {\n    var centerX = x + anchorX;\n    var centerY = y + anchorY;\n    transform = _ol_transform_.compose(localTransform,\n        centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n\n    _ol_extent_.createOrUpdateEmpty(box);\n    _ol_extent_.extendCoordinate(box, _ol_transform_.apply(localTransform, p1));\n    _ol_extent_.extendCoordinate(box, _ol_transform_.apply(localTransform, p2));\n    _ol_extent_.extendCoordinate(box, _ol_transform_.apply(localTransform, p3));\n    _ol_extent_.extendCoordinate(box, _ol_transform_.apply(localTransform, p4));\n  } else {\n    _ol_extent_.createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, box);\n  }\n  var canvas = context.canvas;\n  var intersects = box[0] <= canvas.width && box[2] >= 0 && box[1] <= canvas.height && box[3] >= 0;\n  if (declutterGroup) {\n    if (!intersects && declutterGroup[4] == 1) {\n      return;\n    }\n    _ol_extent_.extend(declutterGroup, box);\n    var declutterArgs = intersects ?\n      [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] :\n      null;\n    if (declutterArgs && fillStroke) {\n      declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\n    }\n    declutterGroup.push(declutterArgs);\n  } else if (intersects) {\n    if (fillStroke) {\n      this.replayTextBackground_(context, p1, p2, p3, p4,\n          /** @type {Array.<*>} */ (fillInstruction),\n          /** @type {Array.<*>} */ (strokeInstruction));\n    }\n    _ol_render_canvas_.drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\n  }\n};\n\n\n/**\n * @protected\n * @param {Array.<number>} dashArray Dash array.\n * @return {Array.<number>} Dash array with pixel ratio applied\n */\n_ol_render_canvas_Replay_.prototype.applyPixelRatio = function(dashArray) {\n  var pixelRatio = this.pixelRatio;\n  return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {\n    return dash * pixelRatio;\n  });\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {boolean} closed Last input coordinate equals first.\n * @param {boolean} skipFirst Skip first coordinate.\n * @protected\n * @return {number} My end.\n */\n_ol_render_canvas_Replay_.prototype.appendFlatCoordinates = function(flatCoordinates, offset, end, stride, closed, skipFirst) {\n\n  var myEnd = this.coordinates.length;\n  var extent = this.getBufferedMaxExtent();\n  if (skipFirst) {\n    offset += stride;\n  }\n  var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n  var nextCoord = [NaN, NaN];\n  var skipped = true;\n\n  var i, lastRel, nextRel;\n  for (i = offset + stride; i < end; i += stride) {\n    nextCoord[0] = flatCoordinates[i];\n    nextCoord[1] = flatCoordinates[i + 1];\n    nextRel = _ol_extent_.coordinateRelationship(extent, nextCoord);\n    if (nextRel !== lastRel) {\n      if (skipped) {\n        this.coordinates[myEnd++] = lastCoord[0];\n        this.coordinates[myEnd++] = lastCoord[1];\n      }\n      this.coordinates[myEnd++] = nextCoord[0];\n      this.coordinates[myEnd++] = nextCoord[1];\n      skipped = false;\n    } else if (nextRel === _ol_extent_Relationship_.INTERSECTING) {\n      this.coordinates[myEnd++] = nextCoord[0];\n      this.coordinates[myEnd++] = nextCoord[1];\n      skipped = false;\n    } else {\n      skipped = true;\n    }\n    lastCoord[0] = nextCoord[0];\n    lastCoord[1] = nextCoord[1];\n    lastRel = nextRel;\n  }\n\n  // Last coordinate equals first or only one point to append:\n  if ((closed && skipped) || i === offset + stride) {\n    this.coordinates[myEnd++] = lastCoord[0];\n    this.coordinates[myEnd++] = lastCoord[1];\n  }\n  return myEnd;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array.<number>} replayEnds Replay ends.\n * @return {number} Offset.\n */\n_ol_render_canvas_Replay_.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset, ends, stride, replayEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n    replayEnds.push(replayEnd);\n    offset = end;\n  }\n  return offset;\n};\n\n\n/**\n * @inheritDoc.\n */\n_ol_render_canvas_Replay_.prototype.drawCustom = function(geometry, feature, renderer) {\n  this.beginGeometry(geometry, feature);\n  var type = geometry.getType();\n  var stride = geometry.getStride();\n  var replayBegin = this.coordinates.length;\n  var flatCoordinates, replayEnd, replayEnds, replayEndss;\n  var offset;\n  if (type == _ol_geom_GeometryType_.MULTI_POLYGON) {\n    geometry = /** @type {ol.geom.MultiPolygon} */ (geometry);\n    flatCoordinates = geometry.getOrientedFlatCoordinates();\n    replayEndss = [];\n    var endss = geometry.getEndss();\n    offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var myEnds = [];\n      offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n      replayEndss.push(myEnds);\n    }\n    this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM,\n      replayBegin, replayEndss, geometry, renderer, _ol_geom_flat_inflate_.coordinatesss]);\n  } else if (type == _ol_geom_GeometryType_.POLYGON || type == _ol_geom_GeometryType_.MULTI_LINE_STRING) {\n    replayEnds = [];\n    flatCoordinates = (type == _ol_geom_GeometryType_.POLYGON) ?\n      /** @type {ol.geom.Polygon} */ (geometry).getOrientedFlatCoordinates() :\n      geometry.getFlatCoordinates();\n    offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n        /** @type {ol.geom.Polygon|ol.geom.MultiLineString} */ (geometry).getEnds(),\n        stride, replayEnds);\n    this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM,\n      replayBegin, replayEnds, geometry, renderer, _ol_geom_flat_inflate_.coordinatess]);\n  } else if (type == _ol_geom_GeometryType_.LINE_STRING || type == _ol_geom_GeometryType_.MULTI_POINT) {\n    flatCoordinates = geometry.getFlatCoordinates();\n    replayEnd = this.appendFlatCoordinates(\n        flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM,\n      replayBegin, replayEnd, geometry, renderer, _ol_geom_flat_inflate_.coordinates]);\n  } else if (type == _ol_geom_GeometryType_.POINT) {\n    flatCoordinates = geometry.getFlatCoordinates();\n    this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n    replayEnd = this.coordinates.length;\n    this.instructions.push([_ol_render_canvas_Instruction_.CUSTOM,\n      replayBegin, replayEnd, geometry, renderer]);\n  }\n  this.endGeometry(geometry, feature);\n};\n\n\n/**\n * @protected\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n * @param {ol.Feature|ol.render.Feature} feature Feature.\n */\n_ol_render_canvas_Replay_.prototype.beginGeometry = function(geometry, feature) {\n  this.beginGeometryInstruction1_ =\n      [_ol_render_canvas_Instruction_.BEGIN_GEOMETRY, feature, 0];\n  this.instructions.push(this.beginGeometryInstruction1_);\n  this.beginGeometryInstruction2_ =\n      [_ol_render_canvas_Instruction_.BEGIN_GEOMETRY, feature, 0];\n  this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n};\n\n\n/**\n * @private\n * @param {CanvasRenderingContext2D} context Context.\n */\n_ol_render_canvas_Replay_.prototype.fill_ = function(context) {\n  if (this.fillOrigin_) {\n    var origin = _ol_transform_.apply(this.renderedTransform_, this.fillOrigin_.slice());\n    context.translate(origin[0], origin[1]);\n    context.rotate(this.viewRotation_);\n  }\n  context.fill();\n  if (this.fillOrigin_) {\n    context.setTransform.apply(context, _ol_render_canvas_.resetTransform_);\n  }\n};\n\n\n/**\n * @private\n * @param {CanvasRenderingContext2D} context Context.\n * @param {Array.<*>} instruction Instruction.\n */\n_ol_render_canvas_Replay_.prototype.setStrokeStyle_ = function(context, instruction) {\n  context.strokeStyle = /** @type {ol.ColorLike} */ (instruction[1]);\n  context.lineWidth = /** @type {number} */ (instruction[2]);\n  context.lineCap = /** @type {string} */ (instruction[3]);\n  context.lineJoin = /** @type {string} */ (instruction[4]);\n  context.miterLimit = /** @type {number} */ (instruction[5]);\n  if (_ol_has_.CANVAS_LINE_DASH) {\n    context.lineDashOffset = /** @type {number} */ (instruction[7]);\n    context.setLineDash(/** @type {Array.<number>} */ (instruction[6]));\n  }\n};\n\n\n/**\n * @param {ol.DeclutterGroup} declutterGroup Declutter group.\n * @param {ol.Feature|ol.render.Feature} feature Feature.\n */\n_ol_render_canvas_Replay_.prototype.renderDeclutter_ = function(declutterGroup, feature) {\n  if (declutterGroup && declutterGroup.length > 5) {\n    var groupCount = declutterGroup[4];\n    if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\n      /** @type {ol.RBushEntry} */\n      var box = {\n        minX: /** @type {number} */ (declutterGroup[0]),\n        minY: /** @type {number} */ (declutterGroup[1]),\n        maxX: /** @type {number} */ (declutterGroup[2]),\n        maxY: /** @type {number} */ (declutterGroup[3]),\n        value: feature\n      };\n      if (!this.declutterTree.collides(box)) {\n        this.declutterTree.insert(box);\n        var drawImage = _ol_render_canvas_.drawImage;\n        for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {\n          var declutterData = /** @type {Array} */ (declutterGroup[j]);\n          if (declutterData) {\n            if (declutterData.length > 11) {\n              this.replayTextBackground_(declutterData[0],\n                  declutterData[13], declutterData[14], declutterData[15], declutterData[16],\n                  declutterData[11], declutterData[12]);\n            }\n            drawImage.apply(undefined, declutterData);\n          }\n        }\n      }\n      declutterGroup.length = 5;\n      _ol_extent_.createOrUpdateEmpty(declutterGroup);\n    }\n  }\n};\n\n\n/**\n * @private\n * @param {CanvasRenderingContext2D} context Context.\n * @param {ol.Transform} transform Transform.\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n *     to skip.\n * @param {Array.<*>} instructions Instructions array.\n * @param {function((ol.Feature|ol.render.Feature)): T|undefined}\n *     featureCallback Feature callback.\n * @param {ol.Extent=} opt_hitExtent Only check features that intersect this\n *     extent.\n * @return {T|undefined} Callback result.\n * @template T\n */\n_ol_render_canvas_Replay_.prototype.replay_ = function(\n    context, transform, skippedFeaturesHash,\n    instructions, featureCallback, opt_hitExtent) {\n  /** @type {Array.<number>} */\n  var pixelCoordinates;\n  if (this.pixelCoordinates_ && _ol_array_.equals(transform, this.renderedTransform_)) {\n    pixelCoordinates = this.pixelCoordinates_;\n  } else {\n    if (!this.pixelCoordinates_) {\n      this.pixelCoordinates_ = [];\n    }\n    pixelCoordinates = _ol_geom_flat_transform_.transform2D(\n        this.coordinates, 0, this.coordinates.length, 2,\n        transform, this.pixelCoordinates_);\n    _ol_transform_.setFromArray(this.renderedTransform_, transform);\n  }\n  var skipFeatures = !_ol_obj_.isEmpty(skippedFeaturesHash);\n  var i = 0; // instruction index\n  var ii = instructions.length; // end of instructions\n  var d = 0; // data index\n  var dd; // end of per-instruction data\n  var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\n  var pendingFill = 0;\n  var pendingStroke = 0;\n  var lastFillInstruction = null;\n  var lastStrokeInstruction = null;\n  var coordinateCache = this.coordinateCache_;\n  var viewRotation = this.viewRotation_;\n\n  var state = /** @type {olx.render.State} */ ({\n    context: context,\n    pixelRatio: this.pixelRatio,\n    resolution: this.resolution,\n    rotation: viewRotation\n  });\n\n  // When the batch size gets too big, performance decreases. 200 is a good\n  // balance between batch size and number of fill/stroke instructions.\n  var batchSize =\n      this.instructions != instructions || this.overlaps ? 0 : 200;\n  while (i < ii) {\n    var instruction = instructions[i];\n    var type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);\n    var /** @type {ol.Feature|ol.render.Feature} */ feature, x, y;\n    switch (type) {\n      case _ol_render_canvas_Instruction_.BEGIN_GEOMETRY:\n        feature = /** @type {ol.Feature|ol.render.Feature} */ (instruction[1]);\n        if ((skipFeatures &&\n            skippedFeaturesHash[_ol_.getUid(feature).toString()]) ||\n            !feature.getGeometry()) {\n          i = /** @type {number} */ (instruction[2]);\n        } else if (opt_hitExtent !== undefined && !_ol_extent_.intersects(\n            opt_hitExtent, feature.getGeometry().getExtent())) {\n          i = /** @type {number} */ (instruction[2]) + 1;\n        } else {\n          ++i;\n        }\n        break;\n      case _ol_render_canvas_Instruction_.BEGIN_PATH:\n        if (pendingFill > batchSize) {\n          this.fill_(context);\n          pendingFill = 0;\n        }\n        if (pendingStroke > batchSize) {\n          context.stroke();\n          pendingStroke = 0;\n        }\n        if (!pendingFill && !pendingStroke) {\n          context.beginPath();\n          prevX = prevY = NaN;\n        }\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.CIRCLE:\n        d = /** @type {number} */ (instruction[1]);\n        var x1 = pixelCoordinates[d];\n        var y1 = pixelCoordinates[d + 1];\n        var x2 = pixelCoordinates[d + 2];\n        var y2 = pixelCoordinates[d + 3];\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var r = Math.sqrt(dx * dx + dy * dy);\n        context.moveTo(x1 + r, y1);\n        context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.CLOSE_PATH:\n        context.closePath();\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.CUSTOM:\n        d = /** @type {number} */ (instruction[1]);\n        dd = instruction[2];\n        var geometry = /** @type {ol.geom.SimpleGeometry} */ (instruction[3]);\n        var renderer = instruction[4];\n        var fn = instruction.length == 6 ? instruction[5] : undefined;\n        state.geometry = geometry;\n        state.feature = feature;\n        if (!(i in coordinateCache)) {\n          coordinateCache[i] = [];\n        }\n        var coords = coordinateCache[i];\n        if (fn) {\n          fn(pixelCoordinates, d, dd, 2, coords);\n        } else {\n          coords[0] = pixelCoordinates[d];\n          coords[1] = pixelCoordinates[d + 1];\n          coords.length = 2;\n        }\n        renderer(coords, state);\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.DRAW_IMAGE:\n        d = /** @type {number} */ (instruction[1]);\n        dd = /** @type {number} */ (instruction[2]);\n        image =  /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */\n            (instruction[3]);\n        // Remaining arguments in DRAW_IMAGE are in alphabetical order\n        anchorX = /** @type {number} */ (instruction[4]);\n        anchorY = /** @type {number} */ (instruction[5]);\n        declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */ (instruction[6]);\n        var height = /** @type {number} */ (instruction[7]);\n        var opacity = /** @type {number} */ (instruction[8]);\n        var originX = /** @type {number} */ (instruction[9]);\n        var originY = /** @type {number} */ (instruction[10]);\n        var rotateWithView = /** @type {boolean} */ (instruction[11]);\n        var rotation = /** @type {number} */ (instruction[12]);\n        var scale = /** @type {number} */ (instruction[13]);\n        var snapToPixel = /** @type {boolean} */ (instruction[14]);\n        var width = /** @type {number} */ (instruction[15]);\n\n        var padding, backgroundFill, backgroundStroke;\n        if (instruction.length > 16) {\n          padding = /** @type {Array.<number>} */ (instruction[16]);\n          backgroundFill = /** @type {boolean} */ (instruction[17]);\n          backgroundStroke = /** @type {boolean} */ (instruction[18]);\n        } else {\n          padding = _ol_render_canvas_.defaultPadding;\n          backgroundFill = backgroundStroke = false;\n        }\n\n        if (rotateWithView) {\n          rotation += viewRotation;\n        }\n        for (; d < dd; d += 2) {\n          this.replayImage_(context,\n              pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY,\n              declutterGroup, height, opacity, originX, originY, rotation, scale,\n              snapToPixel, width, padding,\n              backgroundFill ? /** @type {Array.<*>} */ (lastFillInstruction) : null,\n              backgroundStroke ? /** @type {Array.<*>} */ (lastStrokeInstruction) : null);\n        }\n        this.renderDeclutter_(declutterGroup, feature);\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.DRAW_CHARS:\n        var begin = /** @type {number} */ (instruction[1]);\n        var end = /** @type {number} */ (instruction[2]);\n        var baseline = /** @type {number} */ (instruction[3]);\n        declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */ (instruction[4]);\n        var overflow = /** @type {number} */ (instruction[5]);\n        var fillKey = /** @type {string} */ (instruction[6]);\n        var maxAngle = /** @type {number} */ (instruction[7]);\n        var measure = /** @type {function(string):number} */ (instruction[8]);\n        var offsetY = /** @type {number} */ (instruction[9]);\n        var strokeKey = /** @type {string} */ (instruction[10]);\n        var strokeWidth =  /** @type {number} */ (instruction[11]);\n        var text = /** @type {string} */ (instruction[12]);\n        var textKey = /** @type {string} */ (instruction[13]);\n        var textScale = /** @type {number} */ (instruction[14]);\n\n        var pathLength = _ol_geom_flat_length_.lineString(pixelCoordinates, begin, end, 2);\n        var textLength = measure(text);\n        if (overflow || textLength <= pathLength) {\n          var textAlign = /** @type {ol.render.canvas.TextReplay} */ (this).textStates[textKey].textAlign;\n          var startM = (pathLength - textLength) * _ol_render_replay_.TEXT_ALIGN[textAlign];\n          var parts = _ol_geom_flat_textpath_.lineString(\n              pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\n          if (parts) {\n            var c, cc, chars, label, part;\n            if (strokeKey) {\n              for (c = 0, cc = parts.length; c < cc; ++c) {\n                part = parts[c]; // x, y, anchorX, rotation, chunk\n                chars = /** @type {string} */ (part[4]);\n                label = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, '', strokeKey);\n                anchorX = /** @type {number} */ (part[2]) + strokeWidth;\n                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\n                this.replayImage_(context,\n                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\n                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                    /** @type {number} */ (part[3]), textScale, false, label.width,\n                    _ol_render_canvas_.defaultPadding, null, null);\n              }\n            }\n            if (fillKey) {\n              for (c = 0, cc = parts.length; c < cc; ++c) {\n                part = parts[c]; // x, y, anchorX, rotation, chunk\n                chars = /** @type {string} */ (part[4]);\n                label = /** @type {ol.render.canvas.TextReplay} */ (this).getImage(chars, textKey, fillKey, '');\n                anchorX = /** @type {number} */ (part[2]);\n                anchorY = baseline * label.height - offsetY;\n                this.replayImage_(context,\n                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\n                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                    /** @type {number} */ (part[3]), textScale, false, label.width,\n                    _ol_render_canvas_.defaultPadding, null, null);\n              }\n            }\n          }\n        }\n        this.renderDeclutter_(declutterGroup, feature);\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.END_GEOMETRY:\n        if (featureCallback !== undefined) {\n          feature = /** @type {ol.Feature|ol.render.Feature} */ (instruction[1]);\n          var result = featureCallback(feature);\n          if (result) {\n            return result;\n          }\n        }\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.FILL:\n        if (batchSize) {\n          pendingFill++;\n        } else {\n          this.fill_(context);\n        }\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.MOVE_TO_LINE_TO:\n        d = /** @type {number} */ (instruction[1]);\n        dd = /** @type {number} */ (instruction[2]);\n        x = pixelCoordinates[d];\n        y = pixelCoordinates[d + 1];\n        roundX = (x + 0.5) | 0;\n        roundY = (y + 0.5) | 0;\n        if (roundX !== prevX || roundY !== prevY) {\n          context.moveTo(x, y);\n          prevX = roundX;\n          prevY = roundY;\n        }\n        for (d += 2; d < dd; d += 2) {\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = (x + 0.5) | 0;\n          roundY = (y + 0.5) | 0;\n          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n            context.lineTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n        }\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.SET_FILL_STYLE:\n        lastFillInstruction = instruction;\n        this.fillOrigin_ = instruction[2];\n\n        if (pendingFill) {\n          this.fill_(context);\n          pendingFill = 0;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n        }\n\n        context.fillStyle = /** @type {ol.ColorLike} */ (instruction[1]);\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.SET_STROKE_STYLE:\n        lastStrokeInstruction = instruction;\n        if (pendingStroke) {\n          context.stroke();\n          pendingStroke = 0;\n        }\n        this.setStrokeStyle_(context, /** @type {Array.<*>} */ (instruction));\n        ++i;\n        break;\n      case _ol_render_canvas_Instruction_.STROKE:\n        if (batchSize) {\n          pendingStroke++;\n        } else {\n          context.stroke();\n        }\n        ++i;\n        break;\n      default:\n        ++i; // consume the instruction anyway, to avoid an infinite loop\n        break;\n    }\n  }\n  if (pendingFill) {\n    this.fill_(context);\n  }\n  if (pendingStroke) {\n    context.stroke();\n  }\n  return undefined;\n};\n\n\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {ol.Transform} transform Transform.\n * @param {number} viewRotation View rotation.\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n *     to skip.\n */\n_ol_render_canvas_Replay_.prototype.replay = function(\n    context, transform, viewRotation, skippedFeaturesHash) {\n  this.viewRotation_ = viewRotation;\n  this.replay_(context, transform,\n      skippedFeaturesHash, this.instructions, undefined, undefined);\n};\n\n\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {ol.Transform} transform Transform.\n * @param {number} viewRotation View rotation.\n * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features\n *     to skip.\n * @param {function((ol.Feature|ol.render.Feature)): T=} opt_featureCallback\n *     Feature callback.\n * @param {ol.Extent=} opt_hitExtent Only check features that intersect this\n *     extent.\n * @return {T|undefined} Callback result.\n * @template T\n */\n_ol_render_canvas_Replay_.prototype.replayHitDetection = function(\n    context, transform, viewRotation, skippedFeaturesHash,\n    opt_featureCallback, opt_hitExtent) {\n  this.viewRotation_ = viewRotation;\n  return this.replay_(context, transform, skippedFeaturesHash,\n      this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);\n};\n\n\n/**\n * Reverse the hit detection instructions.\n */\n_ol_render_canvas_Replay_.prototype.reverseHitDetectionInstructions = function() {\n  var hitDetectionInstructions = this.hitDetectionInstructions;\n  // step 1 - reverse array\n  hitDetectionInstructions.reverse();\n  // step 2 - reverse instructions within geometry blocks\n  var i;\n  var n = hitDetectionInstructions.length;\n  var instruction;\n  var type;\n  var begin = -1;\n  for (i = 0; i < n; ++i) {\n    instruction = hitDetectionInstructions[i];\n    type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);\n    if (type == _ol_render_canvas_Instruction_.END_GEOMETRY) {\n      begin = i;\n    } else if (type == _ol_render_canvas_Instruction_.BEGIN_GEOMETRY) {\n      instruction[2] = i;\n      _ol_array_.reverseSubArray(this.hitDetectionInstructions, begin, i);\n      begin = -1;\n    }\n  }\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_canvas_Replay_.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {\n  var state = this.state;\n  if (fillStyle) {\n    var fillStyleColor = fillStyle.getColor();\n    state.fillStyle = _ol_colorlike_.asColorLike(fillStyleColor ?\n      fillStyleColor : _ol_render_canvas_.defaultFillStyle);\n  } else {\n    state.fillStyle = undefined;\n  }\n  if (strokeStyle) {\n    var strokeStyleColor = strokeStyle.getColor();\n    state.strokeStyle = _ol_colorlike_.asColorLike(strokeStyleColor ?\n      strokeStyleColor : _ol_render_canvas_.defaultStrokeStyle);\n    var strokeStyleLineCap = strokeStyle.getLineCap();\n    state.lineCap = strokeStyleLineCap !== undefined ?\n      strokeStyleLineCap : _ol_render_canvas_.defaultLineCap;\n    var strokeStyleLineDash = strokeStyle.getLineDash();\n    state.lineDash = strokeStyleLineDash ?\n      strokeStyleLineDash.slice() : _ol_render_canvas_.defaultLineDash;\n    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n    state.lineDashOffset = strokeStyleLineDashOffset ?\n      strokeStyleLineDashOffset : _ol_render_canvas_.defaultLineDashOffset;\n    var strokeStyleLineJoin = strokeStyle.getLineJoin();\n    state.lineJoin = strokeStyleLineJoin !== undefined ?\n      strokeStyleLineJoin : _ol_render_canvas_.defaultLineJoin;\n    var strokeStyleWidth = strokeStyle.getWidth();\n    state.lineWidth = strokeStyleWidth !== undefined ?\n      strokeStyleWidth : _ol_render_canvas_.defaultLineWidth;\n    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n    state.miterLimit = strokeStyleMiterLimit !== undefined ?\n      strokeStyleMiterLimit : _ol_render_canvas_.defaultMiterLimit;\n\n    if (state.lineWidth > this.maxLineWidth) {\n      this.maxLineWidth = state.lineWidth;\n      // invalidate the buffered max extent cache\n      this.bufferedMaxExtent_ = null;\n    }\n  } else {\n    state.strokeStyle = undefined;\n    state.lineCap = undefined;\n    state.lineDash = null;\n    state.lineDashOffset = undefined;\n    state.lineJoin = undefined;\n    state.lineWidth = undefined;\n    state.miterLimit = undefined;\n  }\n};\n\n\n/**\n * @param {ol.CanvasFillStrokeState} state State.\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n */\n_ol_render_canvas_Replay_.prototype.applyFill = function(state, geometry) {\n  var fillStyle = state.fillStyle;\n  var fillInstruction = [_ol_render_canvas_Instruction_.SET_FILL_STYLE, fillStyle];\n  if (typeof fillStyle !== 'string') {\n    var fillExtent = geometry.getExtent();\n    fillInstruction.push([fillExtent[0], fillExtent[3]]);\n  }\n  this.instructions.push(fillInstruction);\n};\n\n\n/**\n * @param {ol.CanvasFillStrokeState} state State.\n */\n_ol_render_canvas_Replay_.prototype.applyStroke = function(state) {\n  this.instructions.push([\n    _ol_render_canvas_Instruction_.SET_STROKE_STYLE,\n    state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,\n    state.lineJoin, state.miterLimit,\n    this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio\n  ]);\n};\n\n\n/**\n * @param {ol.CanvasFillStrokeState} state State.\n * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState, (ol.geom.Geometry|ol.render.Feature))} applyFill Apply fill.\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n */\n_ol_render_canvas_Replay_.prototype.updateFillStyle = function(state, applyFill, geometry) {\n  var fillStyle = state.fillStyle;\n  if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n    applyFill.call(this, state, geometry);\n    state.currentFillStyle = fillStyle;\n  }\n};\n\n\n/**\n * @param {ol.CanvasFillStrokeState} state State.\n * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState)} applyStroke Apply stroke.\n */\n_ol_render_canvas_Replay_.prototype.updateStrokeStyle = function(state, applyStroke) {\n  var strokeStyle = state.strokeStyle;\n  var lineCap = state.lineCap;\n  var lineDash = state.lineDash;\n  var lineDashOffset = state.lineDashOffset;\n  var lineJoin = state.lineJoin;\n  var lineWidth = state.lineWidth;\n  var miterLimit = state.miterLimit;\n  if (state.currentStrokeStyle != strokeStyle ||\n      state.currentLineCap != lineCap ||\n      (lineDash != state.currentLineDash && !_ol_array_.equals(state.currentLineDash, lineDash)) ||\n      state.currentLineDashOffset != lineDashOffset ||\n      state.currentLineJoin != lineJoin ||\n      state.currentLineWidth != lineWidth ||\n      state.currentMiterLimit != miterLimit) {\n    applyStroke.call(this, state);\n    state.currentStrokeStyle = strokeStyle;\n    state.currentLineCap = lineCap;\n    state.currentLineDash = lineDash;\n    state.currentLineDashOffset = lineDashOffset;\n    state.currentLineJoin = lineJoin;\n    state.currentLineWidth = lineWidth;\n    state.currentMiterLimit = miterLimit;\n  }\n};\n\n\n/**\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n * @param {ol.Feature|ol.render.Feature} feature Feature.\n */\n_ol_render_canvas_Replay_.prototype.endGeometry = function(geometry, feature) {\n  this.beginGeometryInstruction1_[2] = this.instructions.length;\n  this.beginGeometryInstruction1_ = null;\n  this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n  this.beginGeometryInstruction2_ = null;\n  var endGeometryInstruction =\n      [_ol_render_canvas_Instruction_.END_GEOMETRY, feature];\n  this.instructions.push(endGeometryInstruction);\n  this.hitDetectionInstructions.push(endGeometryInstruction);\n};\n\n\n/**\n * FIXME empty description for jsdoc\n */\n_ol_render_canvas_Replay_.prototype.finish = _ol_.nullFunction;\n\n\n/**\n * Get the buffered rendering extent.  Rendering will be clipped to the extent\n * provided to the constructor.  To account for symbolizers that may intersect\n * this extent, we calculate a buffered extent (e.g. based on stroke width).\n * @return {ol.Extent} The buffered rendering extent.\n * @protected\n */\n_ol_render_canvas_Replay_.prototype.getBufferedMaxExtent = function() {\n  if (!this.bufferedMaxExtent_) {\n    this.bufferedMaxExtent_ = _ol_extent_.clone(this.maxExtent);\n    if (this.maxLineWidth > 0) {\n      var width = this.resolution * (this.maxLineWidth + 1) / 2;\n      _ol_extent_.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n    }\n  }\n  return this.bufferedMaxExtent_;\n};\nexport default _ol_render_canvas_Replay_;\n"]},"metadata":{},"sourceType":"module"}
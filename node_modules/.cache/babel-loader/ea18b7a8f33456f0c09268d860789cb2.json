{"ast":null,"code":"import _ol_ from '../index.js';\nimport _ol_asserts_ from '../asserts.js';\nimport _ol_events_EventTarget_ from '../events/eventtarget.js';\nimport _ol_events_EventType_ from '../events/eventtype.js';\n/**\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n * @constructor\n * @extends {ol.events.EventTarget}\n * @fires ol.events.Event\n * @struct\n * @template T\n * @param {number=} opt_highWaterMark High water mark.\n */\n\nvar _ol_structs_LRUCache_ = function (opt_highWaterMark) {\n  _ol_events_EventTarget_.call(this);\n  /**\n   * @type {number}\n   */\n\n\n  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.count_ = 0;\n  /**\n   * @private\n   * @type {!Object.<string, ol.LRUCacheEntry>}\n   */\n\n  this.entries_ = {};\n  /**\n   * @private\n   * @type {?ol.LRUCacheEntry}\n   */\n\n  this.oldest_ = null;\n  /**\n   * @private\n   * @type {?ol.LRUCacheEntry}\n   */\n\n  this.newest_ = null;\n};\n\n_ol_.inherits(_ol_structs_LRUCache_, _ol_events_EventTarget_);\n/**\n * @return {boolean} Can expire cache.\n */\n\n\n_ol_structs_LRUCache_.prototype.canExpireCache = function () {\n  return this.getCount() > this.highWaterMark;\n};\n/**\n * FIXME empty description for jsdoc\n */\n\n\n_ol_structs_LRUCache_.prototype.clear = function () {\n  this.count_ = 0;\n  this.entries_ = {};\n  this.oldest_ = null;\n  this.newest_ = null;\n  this.dispatchEvent(_ol_events_EventType_.CLEAR);\n};\n/**\n * @param {string} key Key.\n * @return {boolean} Contains key.\n */\n\n\n_ol_structs_LRUCache_.prototype.containsKey = function (key) {\n  return this.entries_.hasOwnProperty(key);\n};\n/**\n * @param {function(this: S, T, string, ol.structs.LRUCache): ?} f The function\n *     to call for every entry from the oldest to the newer. This function takes\n *     3 arguments (the entry value, the entry key and the LRUCache object).\n *     The return value is ignored.\n * @param {S=} opt_this The object to use as `this` in `f`.\n * @template S\n */\n\n\n_ol_structs_LRUCache_.prototype.forEach = function (f, opt_this) {\n  var entry = this.oldest_;\n\n  while (entry) {\n    f.call(opt_this, entry.value_, entry.key_, this);\n    entry = entry.newer;\n  }\n};\n/**\n * @param {string} key Key.\n * @return {T} Value.\n */\n\n\n_ol_structs_LRUCache_.prototype.get = function (key) {\n  var entry = this.entries_[key];\n\n  _ol_asserts_.assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n\n  if (entry === this.newest_) {\n    return entry.value_;\n  } else if (entry === this.oldest_) {\n    this.oldest_ =\n    /** @type {ol.LRUCacheEntry} */\n    this.oldest_.newer;\n    this.oldest_.older = null;\n  } else {\n    entry.newer.older = entry.older;\n    entry.older.newer = entry.newer;\n  }\n\n  entry.newer = null;\n  entry.older = this.newest_;\n  this.newest_.newer = entry;\n  this.newest_ = entry;\n  return entry.value_;\n};\n/**\n * Remove an entry from the cache.\n * @param {string} key The entry key.\n * @return {T} The removed entry.\n */\n\n\n_ol_structs_LRUCache_.prototype.remove = function (key) {\n  var entry = this.entries_[key];\n\n  _ol_asserts_.assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n\n  if (entry === this.newest_) {\n    this.newest_ =\n    /** @type {ol.LRUCacheEntry} */\n    entry.older;\n\n    if (this.newest_) {\n      this.newest_.newer = null;\n    }\n  } else if (entry === this.oldest_) {\n    this.oldest_ =\n    /** @type {ol.LRUCacheEntry} */\n    entry.newer;\n\n    if (this.oldest_) {\n      this.oldest_.older = null;\n    }\n  } else {\n    entry.newer.older = entry.older;\n    entry.older.newer = entry.newer;\n  }\n\n  delete this.entries_[key];\n  --this.count_;\n  return entry.value_;\n};\n/**\n * @return {number} Count.\n */\n\n\n_ol_structs_LRUCache_.prototype.getCount = function () {\n  return this.count_;\n};\n/**\n * @return {Array.<string>} Keys.\n */\n\n\n_ol_structs_LRUCache_.prototype.getKeys = function () {\n  var keys = new Array(this.count_);\n  var i = 0;\n  var entry;\n\n  for (entry = this.newest_; entry; entry = entry.older) {\n    keys[i++] = entry.key_;\n  }\n\n  return keys;\n};\n/**\n * @return {Array.<T>} Values.\n */\n\n\n_ol_structs_LRUCache_.prototype.getValues = function () {\n  var values = new Array(this.count_);\n  var i = 0;\n  var entry;\n\n  for (entry = this.newest_; entry; entry = entry.older) {\n    values[i++] = entry.value_;\n  }\n\n  return values;\n};\n/**\n * @return {T} Last value.\n */\n\n\n_ol_structs_LRUCache_.prototype.peekLast = function () {\n  return this.oldest_.value_;\n};\n/**\n * @return {string} Last key.\n */\n\n\n_ol_structs_LRUCache_.prototype.peekLastKey = function () {\n  return this.oldest_.key_;\n};\n/**\n * Get the key of the newest item in the cache.  Throws if the cache is empty.\n * @return {string} The newest key.\n */\n\n\n_ol_structs_LRUCache_.prototype.peekFirstKey = function () {\n  return this.newest_.key_;\n};\n/**\n * @return {T} value Value.\n */\n\n\n_ol_structs_LRUCache_.prototype.pop = function () {\n  var entry = this.oldest_;\n  delete this.entries_[entry.key_];\n\n  if (entry.newer) {\n    entry.newer.older = null;\n  }\n\n  this.oldest_ =\n  /** @type {ol.LRUCacheEntry} */\n  entry.newer;\n\n  if (!this.oldest_) {\n    this.newest_ = null;\n  }\n\n  --this.count_;\n  return entry.value_;\n};\n/**\n * @param {string} key Key.\n * @param {T} value Value.\n */\n\n\n_ol_structs_LRUCache_.prototype.replace = function (key, value) {\n  this.get(key); // update `newest_`\n\n  this.entries_[key].value_ = value;\n};\n/**\n * @param {string} key Key.\n * @param {T} value Value.\n */\n\n\n_ol_structs_LRUCache_.prototype.set = function (key, value) {\n  _ol_asserts_.assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n\n\n  var entry =\n  /** @type {ol.LRUCacheEntry} */\n  {\n    key_: key,\n    newer: null,\n    older: this.newest_,\n    value_: value\n  };\n\n  if (!this.newest_) {\n    this.oldest_ = entry;\n  } else {\n    this.newest_.newer = entry;\n  }\n\n  this.newest_ = entry;\n  this.entries_[key] = entry;\n  ++this.count_;\n};\n/**\n * Prune the cache.\n */\n\n\n_ol_structs_LRUCache_.prototype.prune = function () {\n  while (this.canExpireCache()) {\n    this.pop();\n  }\n};\n\nexport default _ol_structs_LRUCache_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/structs/lrucache.js"],"names":["_ol_","_ol_asserts_","_ol_events_EventTarget_","_ol_events_EventType_","_ol_structs_LRUCache_","opt_highWaterMark","call","highWaterMark","undefined","count_","entries_","oldest_","newest_","inherits","prototype","canExpireCache","getCount","clear","dispatchEvent","CLEAR","containsKey","key","hasOwnProperty","forEach","f","opt_this","entry","value_","key_","newer","get","assert","older","remove","getKeys","keys","Array","i","getValues","values","peekLast","peekLastKey","peekFirstKey","pop","replace","value","set","prune"],"mappings":"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","sourcesContent":["import _ol_ from '../index.js';\nimport _ol_asserts_ from '../asserts.js';\nimport _ol_events_EventTarget_ from '../events/eventtarget.js';\nimport _ol_events_EventType_ from '../events/eventtype.js';\n\n/**\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n * @constructor\n * @extends {ol.events.EventTarget}\n * @fires ol.events.Event\n * @struct\n * @template T\n * @param {number=} opt_highWaterMark High water mark.\n */\nvar _ol_structs_LRUCache_ = function(opt_highWaterMark) {\n\n  _ol_events_EventTarget_.call(this);\n\n  /**\n   * @type {number}\n   */\n  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.count_ = 0;\n\n  /**\n   * @private\n   * @type {!Object.<string, ol.LRUCacheEntry>}\n   */\n  this.entries_ = {};\n\n  /**\n   * @private\n   * @type {?ol.LRUCacheEntry}\n   */\n  this.oldest_ = null;\n\n  /**\n   * @private\n   * @type {?ol.LRUCacheEntry}\n   */\n  this.newest_ = null;\n\n};\n\n_ol_.inherits(_ol_structs_LRUCache_, _ol_events_EventTarget_);\n\n\n/**\n * @return {boolean} Can expire cache.\n */\n_ol_structs_LRUCache_.prototype.canExpireCache = function() {\n  return this.getCount() > this.highWaterMark;\n};\n\n\n/**\n * FIXME empty description for jsdoc\n */\n_ol_structs_LRUCache_.prototype.clear = function() {\n  this.count_ = 0;\n  this.entries_ = {};\n  this.oldest_ = null;\n  this.newest_ = null;\n  this.dispatchEvent(_ol_events_EventType_.CLEAR);\n};\n\n\n/**\n * @param {string} key Key.\n * @return {boolean} Contains key.\n */\n_ol_structs_LRUCache_.prototype.containsKey = function(key) {\n  return this.entries_.hasOwnProperty(key);\n};\n\n\n/**\n * @param {function(this: S, T, string, ol.structs.LRUCache): ?} f The function\n *     to call for every entry from the oldest to the newer. This function takes\n *     3 arguments (the entry value, the entry key and the LRUCache object).\n *     The return value is ignored.\n * @param {S=} opt_this The object to use as `this` in `f`.\n * @template S\n */\n_ol_structs_LRUCache_.prototype.forEach = function(f, opt_this) {\n  var entry = this.oldest_;\n  while (entry) {\n    f.call(opt_this, entry.value_, entry.key_, this);\n    entry = entry.newer;\n  }\n};\n\n\n/**\n * @param {string} key Key.\n * @return {T} Value.\n */\n_ol_structs_LRUCache_.prototype.get = function(key) {\n  var entry = this.entries_[key];\n  _ol_asserts_.assert(entry !== undefined,\n      15); // Tried to get a value for a key that does not exist in the cache\n  if (entry === this.newest_) {\n    return entry.value_;\n  } else if (entry === this.oldest_) {\n    this.oldest_ = /** @type {ol.LRUCacheEntry} */ (this.oldest_.newer);\n    this.oldest_.older = null;\n  } else {\n    entry.newer.older = entry.older;\n    entry.older.newer = entry.newer;\n  }\n  entry.newer = null;\n  entry.older = this.newest_;\n  this.newest_.newer = entry;\n  this.newest_ = entry;\n  return entry.value_;\n};\n\n\n/**\n * Remove an entry from the cache.\n * @param {string} key The entry key.\n * @return {T} The removed entry.\n */\n_ol_structs_LRUCache_.prototype.remove = function(key) {\n  var entry = this.entries_[key];\n  _ol_asserts_.assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n  if (entry === this.newest_) {\n    this.newest_ = /** @type {ol.LRUCacheEntry} */ (entry.older);\n    if (this.newest_) {\n      this.newest_.newer = null;\n    }\n  } else if (entry === this.oldest_) {\n    this.oldest_ = /** @type {ol.LRUCacheEntry} */ (entry.newer);\n    if (this.oldest_) {\n      this.oldest_.older = null;\n    }\n  } else {\n    entry.newer.older = entry.older;\n    entry.older.newer = entry.newer;\n  }\n  delete this.entries_[key];\n  --this.count_;\n  return entry.value_;\n};\n\n\n/**\n * @return {number} Count.\n */\n_ol_structs_LRUCache_.prototype.getCount = function() {\n  return this.count_;\n};\n\n\n/**\n * @return {Array.<string>} Keys.\n */\n_ol_structs_LRUCache_.prototype.getKeys = function() {\n  var keys = new Array(this.count_);\n  var i = 0;\n  var entry;\n  for (entry = this.newest_; entry; entry = entry.older) {\n    keys[i++] = entry.key_;\n  }\n  return keys;\n};\n\n\n/**\n * @return {Array.<T>} Values.\n */\n_ol_structs_LRUCache_.prototype.getValues = function() {\n  var values = new Array(this.count_);\n  var i = 0;\n  var entry;\n  for (entry = this.newest_; entry; entry = entry.older) {\n    values[i++] = entry.value_;\n  }\n  return values;\n};\n\n\n/**\n * @return {T} Last value.\n */\n_ol_structs_LRUCache_.prototype.peekLast = function() {\n  return this.oldest_.value_;\n};\n\n\n/**\n * @return {string} Last key.\n */\n_ol_structs_LRUCache_.prototype.peekLastKey = function() {\n  return this.oldest_.key_;\n};\n\n\n/**\n * Get the key of the newest item in the cache.  Throws if the cache is empty.\n * @return {string} The newest key.\n */\n_ol_structs_LRUCache_.prototype.peekFirstKey = function() {\n  return this.newest_.key_;\n};\n\n\n/**\n * @return {T} value Value.\n */\n_ol_structs_LRUCache_.prototype.pop = function() {\n  var entry = this.oldest_;\n  delete this.entries_[entry.key_];\n  if (entry.newer) {\n    entry.newer.older = null;\n  }\n  this.oldest_ = /** @type {ol.LRUCacheEntry} */ (entry.newer);\n  if (!this.oldest_) {\n    this.newest_ = null;\n  }\n  --this.count_;\n  return entry.value_;\n};\n\n\n/**\n * @param {string} key Key.\n * @param {T} value Value.\n */\n_ol_structs_LRUCache_.prototype.replace = function(key, value) {\n  this.get(key);  // update `newest_`\n  this.entries_[key].value_ = value;\n};\n\n\n/**\n * @param {string} key Key.\n * @param {T} value Value.\n */\n_ol_structs_LRUCache_.prototype.set = function(key, value) {\n  _ol_asserts_.assert(!(key in this.entries_),\n      16); // Tried to set a value for a key that is used already\n  var entry = /** @type {ol.LRUCacheEntry} */ ({\n    key_: key,\n    newer: null,\n    older: this.newest_,\n    value_: value\n  });\n  if (!this.newest_) {\n    this.oldest_ = entry;\n  } else {\n    this.newest_.newer = entry;\n  }\n  this.newest_ = entry;\n  this.entries_[key] = entry;\n  ++this.count_;\n};\n\n\n/**\n * Prune the cache.\n */\n_ol_structs_LRUCache_.prototype.prune = function() {\n  while (this.canExpireCache()) {\n    this.pop();\n  }\n};\nexport default _ol_structs_LRUCache_;\n"]},"metadata":{},"sourceType":"module"}
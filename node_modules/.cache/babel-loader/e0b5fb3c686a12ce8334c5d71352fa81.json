{"ast":null,"code":"import _ol_dom_ from '../dom.js';\n/**\n * This class facilitates the creation of image atlases.\n *\n * Images added to an atlas will be rendered onto a single\n * atlas canvas. The distribution of images on the canvas is\n * managed with the bin packing algorithm described in:\n * http://www.blackpawn.com/texts/lightmaps/\n *\n * @constructor\n * @struct\n * @param {number} size The size in pixels of the sprite image.\n * @param {number} space The space in pixels between images.\n *    Because texture coordinates are float values, the edges of\n *    images might not be completely correct (in a way that the\n *    edges overlap when being rendered). To avoid this we add a\n *    padding around each image.\n */\n\nvar _ol_style_Atlas_ = function (size, space) {\n  /**\n   * @private\n   * @type {number}\n   */\n  this.space_ = space;\n  /**\n   * @private\n   * @type {Array.<ol.AtlasBlock>}\n   */\n\n  this.emptyBlocks_ = [{\n    x: 0,\n    y: 0,\n    width: size,\n    height: size\n  }];\n  /**\n   * @private\n   * @type {Object.<string, ol.AtlasInfo>}\n   */\n\n  this.entries_ = {};\n  /**\n   * @private\n   * @type {CanvasRenderingContext2D}\n   */\n\n  this.context_ = _ol_dom_.createCanvasContext2D(size, size);\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n\n  this.canvas_ = this.context_.canvas;\n};\n/**\n * @param {string} id The identifier of the entry to check.\n * @return {?ol.AtlasInfo} The atlas info.\n */\n\n\n_ol_style_Atlas_.prototype.get = function (id) {\n  return this.entries_[id] || null;\n};\n/**\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *    Called to render the new image onto an atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *    `renderCallback`.\n * @return {?ol.AtlasInfo} The position and atlas image for the entry.\n */\n\n\n_ol_style_Atlas_.prototype.add = function (id, width, height, renderCallback, opt_this) {\n  var block, i, ii;\n\n  for (i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {\n    block = this.emptyBlocks_[i];\n\n    if (block.width >= width + this.space_ && block.height >= height + this.space_) {\n      // we found a block that is big enough for our entry\n      var entry = {\n        offsetX: block.x + this.space_,\n        offsetY: block.y + this.space_,\n        image: this.canvas_\n      };\n      this.entries_[id] = entry; // render the image on the atlas image\n\n      renderCallback.call(opt_this, this.context_, block.x + this.space_, block.y + this.space_); // split the block after the insertion, either horizontally or vertically\n\n      this.split_(i, block, width + this.space_, height + this.space_);\n      return entry;\n    }\n  } // there is no space for the new entry in this atlas\n\n\n  return null;\n};\n/**\n * @private\n * @param {number} index The index of the block.\n * @param {ol.AtlasBlock} block The block to split.\n * @param {number} width The width of the entry to insert.\n * @param {number} height The height of the entry to insert.\n */\n\n\n_ol_style_Atlas_.prototype.split_ = function (index, block, width, height) {\n  var deltaWidth = block.width - width;\n  var deltaHeight = block.height - height;\n  /** @type {ol.AtlasBlock} */\n\n  var newBlock1;\n  /** @type {ol.AtlasBlock} */\n\n  var newBlock2;\n\n  if (deltaWidth > deltaHeight) {\n    // split vertically\n    // block right of the inserted entry\n    newBlock1 = {\n      x: block.x + width,\n      y: block.y,\n      width: block.width - width,\n      height: block.height\n    }; // block below the inserted entry\n\n    newBlock2 = {\n      x: block.x,\n      y: block.y + height,\n      width: width,\n      height: block.height - height\n    };\n    this.updateBlocks_(index, newBlock1, newBlock2);\n  } else {\n    // split horizontally\n    // block right of the inserted entry\n    newBlock1 = {\n      x: block.x + width,\n      y: block.y,\n      width: block.width - width,\n      height: height\n    }; // block below the inserted entry\n\n    newBlock2 = {\n      x: block.x,\n      y: block.y + height,\n      width: block.width,\n      height: block.height - height\n    };\n    this.updateBlocks_(index, newBlock1, newBlock2);\n  }\n};\n/**\n * Remove the old block and insert new blocks at the same array position.\n * The new blocks are inserted at the same position, so that splitted\n * blocks (that are potentially smaller) are filled first.\n * @private\n * @param {number} index The index of the block to remove.\n * @param {ol.AtlasBlock} newBlock1 The 1st block to add.\n * @param {ol.AtlasBlock} newBlock2 The 2nd block to add.\n */\n\n\n_ol_style_Atlas_.prototype.updateBlocks_ = function (index, newBlock1, newBlock2) {\n  var args = [index, 1];\n\n  if (newBlock1.width > 0 && newBlock1.height > 0) {\n    args.push(newBlock1);\n  }\n\n  if (newBlock2.width > 0 && newBlock2.height > 0) {\n    args.push(newBlock2);\n  }\n\n  this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);\n};\n\nexport default _ol_style_Atlas_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/style/atlas.js"],"names":["_ol_dom_","_ol_style_Atlas_","size","space","space_","emptyBlocks_","x","y","width","height","entries_","context_","createCanvasContext2D","canvas_","canvas","prototype","get","id","add","renderCallback","opt_this","block","i","ii","length","entry","offsetX","offsetY","image","call","split_","index","deltaWidth","deltaHeight","newBlock1","newBlock2","updateBlocks_","args","push","splice","apply"],"mappings":"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","sourcesContent":["import _ol_dom_ from '../dom.js';\n\n/**\n * This class facilitates the creation of image atlases.\n *\n * Images added to an atlas will be rendered onto a single\n * atlas canvas. The distribution of images on the canvas is\n * managed with the bin packing algorithm described in:\n * http://www.blackpawn.com/texts/lightmaps/\n *\n * @constructor\n * @struct\n * @param {number} size The size in pixels of the sprite image.\n * @param {number} space The space in pixels between images.\n *    Because texture coordinates are float values, the edges of\n *    images might not be completely correct (in a way that the\n *    edges overlap when being rendered). To avoid this we add a\n *    padding around each image.\n */\nvar _ol_style_Atlas_ = function(size, space) {\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.space_ = space;\n\n  /**\n   * @private\n   * @type {Array.<ol.AtlasBlock>}\n   */\n  this.emptyBlocks_ = [{x: 0, y: 0, width: size, height: size}];\n\n  /**\n   * @private\n   * @type {Object.<string, ol.AtlasInfo>}\n   */\n  this.entries_ = {};\n\n  /**\n   * @private\n   * @type {CanvasRenderingContext2D}\n   */\n  this.context_ = _ol_dom_.createCanvasContext2D(size, size);\n\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n  this.canvas_ = this.context_.canvas;\n};\n\n\n/**\n * @param {string} id The identifier of the entry to check.\n * @return {?ol.AtlasInfo} The atlas info.\n */\n_ol_style_Atlas_.prototype.get = function(id) {\n  return this.entries_[id] || null;\n};\n\n\n/**\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *    Called to render the new image onto an atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *    `renderCallback`.\n * @return {?ol.AtlasInfo} The position and atlas image for the entry.\n */\n_ol_style_Atlas_.prototype.add = function(id, width, height, renderCallback, opt_this) {\n  var block, i, ii;\n  for (i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {\n    block = this.emptyBlocks_[i];\n    if (block.width >= width + this.space_ &&\n        block.height >= height + this.space_) {\n      // we found a block that is big enough for our entry\n      var entry = {\n        offsetX: block.x + this.space_,\n        offsetY: block.y + this.space_,\n        image: this.canvas_\n      };\n      this.entries_[id] = entry;\n\n      // render the image on the atlas image\n      renderCallback.call(opt_this, this.context_,\n          block.x + this.space_, block.y + this.space_);\n\n      // split the block after the insertion, either horizontally or vertically\n      this.split_(i, block, width + this.space_, height + this.space_);\n\n      return entry;\n    }\n  }\n\n  // there is no space for the new entry in this atlas\n  return null;\n};\n\n\n/**\n * @private\n * @param {number} index The index of the block.\n * @param {ol.AtlasBlock} block The block to split.\n * @param {number} width The width of the entry to insert.\n * @param {number} height The height of the entry to insert.\n */\n_ol_style_Atlas_.prototype.split_ = function(index, block, width, height) {\n  var deltaWidth = block.width - width;\n  var deltaHeight = block.height - height;\n\n  /** @type {ol.AtlasBlock} */\n  var newBlock1;\n  /** @type {ol.AtlasBlock} */\n  var newBlock2;\n\n  if (deltaWidth > deltaHeight) {\n    // split vertically\n    // block right of the inserted entry\n    newBlock1 = {\n      x: block.x + width,\n      y: block.y,\n      width: block.width - width,\n      height: block.height\n    };\n\n    // block below the inserted entry\n    newBlock2 = {\n      x: block.x,\n      y: block.y + height,\n      width: width,\n      height: block.height - height\n    };\n    this.updateBlocks_(index, newBlock1, newBlock2);\n  } else {\n    // split horizontally\n    // block right of the inserted entry\n    newBlock1 = {\n      x: block.x + width,\n      y: block.y,\n      width: block.width - width,\n      height: height\n    };\n\n    // block below the inserted entry\n    newBlock2 = {\n      x: block.x,\n      y: block.y + height,\n      width: block.width,\n      height: block.height - height\n    };\n    this.updateBlocks_(index, newBlock1, newBlock2);\n  }\n};\n\n\n/**\n * Remove the old block and insert new blocks at the same array position.\n * The new blocks are inserted at the same position, so that splitted\n * blocks (that are potentially smaller) are filled first.\n * @private\n * @param {number} index The index of the block to remove.\n * @param {ol.AtlasBlock} newBlock1 The 1st block to add.\n * @param {ol.AtlasBlock} newBlock2 The 2nd block to add.\n */\n_ol_style_Atlas_.prototype.updateBlocks_ = function(index, newBlock1, newBlock2) {\n  var args = [index, 1];\n  if (newBlock1.width > 0 && newBlock1.height > 0) {\n    args.push(newBlock1);\n  }\n  if (newBlock2.width > 0 && newBlock2.height > 0) {\n    args.push(newBlock2);\n  }\n  this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);\n};\nexport default _ol_style_Atlas_;\n"]},"metadata":{},"sourceType":"module"}
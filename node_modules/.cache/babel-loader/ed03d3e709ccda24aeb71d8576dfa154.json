{"ast":null,"code":"import _ol_ from '../../index.js';\nimport _ol_LayerType_ from '../../layertype.js';\nimport _ol_ViewHint_ from '../../viewhint.js';\nimport _ol_dom_ from '../../dom.js';\nimport _ol_extent_ from '../../extent.js';\nimport _ol_functions_ from '../../functions.js';\nimport _ol_renderer_Type_ from '../type.js';\nimport _ol_renderer_webgl_Layer_ from '../webgl/layer.js';\nimport _ol_transform_ from '../../transform.js';\nimport _ol_webgl_ from '../../webgl.js';\nimport _ol_webgl_Context_ from '../../webgl/context.js';\n/**\n * @constructor\n * @extends {ol.renderer.webgl.Layer}\n * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.\n * @param {ol.layer.Image} imageLayer Tile layer.\n * @api\n */\n\nvar _ol_renderer_webgl_ImageLayer_ = function (mapRenderer, imageLayer) {\n  _ol_renderer_webgl_Layer_.call(this, mapRenderer, imageLayer);\n  /**\n   * The last rendered image.\n   * @private\n   * @type {?ol.ImageBase}\n   */\n\n\n  this.image_ = null;\n  /**\n   * @private\n   * @type {CanvasRenderingContext2D}\n   */\n\n  this.hitCanvasContext_ = null;\n  /**\n   * @private\n   * @type {?ol.Transform}\n   */\n\n  this.hitTransformationMatrix_ = null;\n};\n\n_ol_.inherits(_ol_renderer_webgl_ImageLayer_, _ol_renderer_webgl_Layer_);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {ol.renderer.Type} type The renderer type.\n * @param {ol.layer.Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\n_ol_renderer_webgl_ImageLayer_['handles'] = function (type, layer) {\n  return type === _ol_renderer_Type_.WEBGL && layer.getType() === _ol_LayerType_.IMAGE;\n};\n/**\n * Create a layer renderer.\n * @param {ol.renderer.Map} mapRenderer The map renderer.\n * @param {ol.layer.Layer} layer The layer to be rendererd.\n * @return {ol.renderer.webgl.ImageLayer} The layer renderer.\n */\n\n\n_ol_renderer_webgl_ImageLayer_['create'] = function (mapRenderer, layer) {\n  return new _ol_renderer_webgl_ImageLayer_(\n  /** @type {ol.renderer.webgl.Map} */\n  mapRenderer,\n  /** @type {ol.layer.Image} */\n  layer);\n};\n/**\n * @param {ol.ImageBase} image Image.\n * @private\n * @return {WebGLTexture} Texture.\n */\n\n\n_ol_renderer_webgl_ImageLayer_.prototype.createTexture_ = function (image) {\n  // We meet the conditions to work with non-power of two textures.\n  // http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support\n  // http://learningwebgl.com/blog/?p=2101\n  var imageElement = image.getImage();\n  var gl = this.mapRenderer.getGL();\n  return _ol_webgl_Context_.createTexture(gl, imageElement, _ol_webgl_.CLAMP_TO_EDGE, _ol_webgl_.CLAMP_TO_EDGE);\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_renderer_webgl_ImageLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {\n  var layer = this.getLayer();\n  var source = layer.getSource();\n  var resolution = frameState.viewState.resolution;\n  var rotation = frameState.viewState.rotation;\n  var skippedFeatureUids = frameState.skippedFeatureUids;\n  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,\n  /**\n   * @param {ol.Feature|ol.render.Feature} feature Feature.\n   * @return {?} Callback result.\n   */\n  function (feature) {\n    return callback.call(thisArg, feature, layer);\n  });\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_renderer_webgl_ImageLayer_.prototype.prepareFrame = function (frameState, layerState, context) {\n  var gl = this.mapRenderer.getGL();\n  var pixelRatio = frameState.pixelRatio;\n  var viewState = frameState.viewState;\n  var viewCenter = viewState.center;\n  var viewResolution = viewState.resolution;\n  var viewRotation = viewState.rotation;\n  var image = this.image_;\n  var texture = this.texture;\n  var imageLayer =\n  /** @type {ol.layer.Image} */\n  this.getLayer();\n  var imageSource = imageLayer.getSource();\n  var hints = frameState.viewHints;\n  var renderedExtent = frameState.extent;\n\n  if (layerState.extent !== undefined) {\n    renderedExtent = _ol_extent_.getIntersection(renderedExtent, layerState.extent);\n  }\n\n  if (!hints[_ol_ViewHint_.ANIMATING] && !hints[_ol_ViewHint_.INTERACTING] && !_ol_extent_.isEmpty(renderedExtent)) {\n    var projection = viewState.projection;\n\n    if (!_ol_.ENABLE_RASTER_REPROJECTION) {\n      var sourceProjection = imageSource.getProjection();\n\n      if (sourceProjection) {\n        projection = sourceProjection;\n      }\n    }\n\n    var image_ = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);\n\n    if (image_) {\n      var loaded = this.loadImage(image_);\n\n      if (loaded) {\n        image = image_;\n        texture = this.createTexture_(image_);\n\n        if (this.texture) {\n          /**\n           * @param {WebGLRenderingContext} gl GL.\n           * @param {WebGLTexture} texture Texture.\n           */\n          var postRenderFunction = function (gl, texture) {\n            if (!gl.isContextLost()) {\n              gl.deleteTexture(texture);\n            }\n          }.bind(null, gl, this.texture);\n\n          frameState.postRenderFunctions.push(\n          /** @type {ol.PostRenderFunction} */\n          postRenderFunction);\n        }\n      }\n    }\n  }\n\n  if (image) {\n    var canvas = this.mapRenderer.getContext().getCanvas();\n    this.updateProjectionMatrix_(canvas.width, canvas.height, pixelRatio, viewCenter, viewResolution, viewRotation, image.getExtent());\n    this.hitTransformationMatrix_ = null; // Translate and scale to flip the Y coord.\n\n    var texCoordMatrix = this.texCoordMatrix;\n\n    _ol_transform_.reset(texCoordMatrix);\n\n    _ol_transform_.scale(texCoordMatrix, 1, -1);\n\n    _ol_transform_.translate(texCoordMatrix, 0, -1);\n\n    this.image_ = image;\n    this.texture = texture;\n    this.updateLogos(frameState, imageSource);\n  }\n\n  return !!image;\n};\n/**\n * @param {number} canvasWidth Canvas width.\n * @param {number} canvasHeight Canvas height.\n * @param {number} pixelRatio Pixel ratio.\n * @param {ol.Coordinate} viewCenter View center.\n * @param {number} viewResolution View resolution.\n * @param {number} viewRotation View rotation.\n * @param {ol.Extent} imageExtent Image extent.\n * @private\n */\n\n\n_ol_renderer_webgl_ImageLayer_.prototype.updateProjectionMatrix_ = function (canvasWidth, canvasHeight, pixelRatio, viewCenter, viewResolution, viewRotation, imageExtent) {\n  var canvasExtentWidth = canvasWidth * viewResolution;\n  var canvasExtentHeight = canvasHeight * viewResolution;\n  var projectionMatrix = this.projectionMatrix;\n\n  _ol_transform_.reset(projectionMatrix);\n\n  _ol_transform_.scale(projectionMatrix, pixelRatio * 2 / canvasExtentWidth, pixelRatio * 2 / canvasExtentHeight);\n\n  _ol_transform_.rotate(projectionMatrix, -viewRotation);\n\n  _ol_transform_.translate(projectionMatrix, imageExtent[0] - viewCenter[0], imageExtent[1] - viewCenter[1]);\n\n  _ol_transform_.scale(projectionMatrix, (imageExtent[2] - imageExtent[0]) / 2, (imageExtent[3] - imageExtent[1]) / 2);\n\n  _ol_transform_.translate(projectionMatrix, 1, 1);\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_renderer_webgl_ImageLayer_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState) {\n  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, _ol_functions_.TRUE, this);\n  return hasFeature !== undefined;\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_renderer_webgl_ImageLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {\n  if (!this.image_ || !this.image_.getImage()) {\n    return undefined;\n  }\n\n  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== _ol_.nullFunction) {\n    // for ImageCanvas sources use the original hit-detection logic,\n    // so that for example also transparent polygons are detected\n    var coordinate = _ol_transform_.apply(frameState.pixelToCoordinateTransform, pixel.slice());\n\n    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, _ol_functions_.TRUE, this);\n\n    if (hasFeature) {\n      return callback.call(thisArg, this.getLayer(), null);\n    } else {\n      return undefined;\n    }\n  } else {\n    var imageSize = [this.image_.getImage().width, this.image_.getImage().height];\n\n    if (!this.hitTransformationMatrix_) {\n      this.hitTransformationMatrix_ = this.getHitTransformationMatrix_(frameState.size, imageSize);\n    }\n\n    var pixelOnFrameBuffer = _ol_transform_.apply(this.hitTransformationMatrix_, pixel.slice());\n\n    if (pixelOnFrameBuffer[0] < 0 || pixelOnFrameBuffer[0] > imageSize[0] || pixelOnFrameBuffer[1] < 0 || pixelOnFrameBuffer[1] > imageSize[1]) {\n      // outside the image, no need to check\n      return undefined;\n    }\n\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = _ol_dom_.createCanvasContext2D(1, 1);\n    }\n\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.image_.getImage(), pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, 0, 0, 1, 1);\n    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  }\n};\n/**\n * The transformation matrix to get the pixel on the image for a\n * pixel on the map.\n * @param {ol.Size} mapSize The map size.\n * @param {ol.Size} imageSize The image size.\n * @return {ol.Transform} The transformation matrix.\n * @private\n */\n\n\n_ol_renderer_webgl_ImageLayer_.prototype.getHitTransformationMatrix_ = function (mapSize, imageSize) {\n  // the first matrix takes a map pixel, flips the y-axis and scales to\n  // a range between -1 ... 1\n  var mapCoordTransform = _ol_transform_.create();\n\n  _ol_transform_.translate(mapCoordTransform, -1, -1);\n\n  _ol_transform_.scale(mapCoordTransform, 2 / mapSize[0], 2 / mapSize[1]);\n\n  _ol_transform_.translate(mapCoordTransform, 0, mapSize[1]);\n\n  _ol_transform_.scale(mapCoordTransform, 1, -1); // the second matrix is the inverse of the projection matrix used in the\n  // shader for drawing\n\n\n  var projectionMatrixInv = _ol_transform_.invert(this.projectionMatrix.slice()); // the third matrix scales to the image dimensions and flips the y-axis again\n\n\n  var transform = _ol_transform_.create();\n\n  _ol_transform_.translate(transform, 0, imageSize[1]);\n\n  _ol_transform_.scale(transform, 1, -1);\n\n  _ol_transform_.scale(transform, imageSize[0] / 2, imageSize[1] / 2);\n\n  _ol_transform_.translate(transform, 1, 1);\n\n  _ol_transform_.multiply(transform, projectionMatrixInv);\n\n  _ol_transform_.multiply(transform, mapCoordTransform);\n\n  return transform;\n};\n\nexport default _ol_renderer_webgl_ImageLayer_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/renderer/webgl/imagelayer.js"],"names":["_ol_","_ol_LayerType_","_ol_ViewHint_","_ol_dom_","_ol_extent_","_ol_functions_","_ol_renderer_Type_","_ol_renderer_webgl_Layer_","_ol_transform_","_ol_webgl_","_ol_webgl_Context_","_ol_renderer_webgl_ImageLayer_","mapRenderer","imageLayer","call","image_","hitCanvasContext_","hitTransformationMatrix_","inherits","type","layer","WEBGL","getType","IMAGE","prototype","createTexture_","image","imageElement","getImage","gl","getGL","createTexture","CLAMP_TO_EDGE","forEachFeatureAtCoordinate","coordinate","frameState","hitTolerance","callback","thisArg","getLayer","source","getSource","resolution","viewState","rotation","skippedFeatureUids","feature","prepareFrame","layerState","context","pixelRatio","viewCenter","center","viewResolution","viewRotation","texture","imageSource","hints","viewHints","renderedExtent","extent","undefined","getIntersection","ANIMATING","INTERACTING","isEmpty","projection","ENABLE_RASTER_REPROJECTION","sourceProjection","getProjection","loaded","loadImage","postRenderFunction","isContextLost","deleteTexture","bind","postRenderFunctions","push","canvas","getContext","getCanvas","updateProjectionMatrix_","width","height","getExtent","texCoordMatrix","reset","scale","translate","updateLogos","canvasWidth","canvasHeight","imageExtent","canvasExtentWidth","canvasExtentHeight","projectionMatrix","rotate","hasFeatureAtCoordinate","hasFeature","TRUE","forEachLayerAtPixel","pixel","nullFunction","apply","pixelToCoordinateTransform","slice","imageSize","getHitTransformationMatrix_","size","pixelOnFrameBuffer","createCanvasContext2D","clearRect","drawImage","imageData","getImageData","data","mapSize","mapCoordTransform","create","projectionMatrixInv","invert","transform","multiply"],"mappings":"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","sourcesContent":["import _ol_ from '../../index.js';\nimport _ol_LayerType_ from '../../layertype.js';\nimport _ol_ViewHint_ from '../../viewhint.js';\nimport _ol_dom_ from '../../dom.js';\nimport _ol_extent_ from '../../extent.js';\nimport _ol_functions_ from '../../functions.js';\nimport _ol_renderer_Type_ from '../type.js';\nimport _ol_renderer_webgl_Layer_ from '../webgl/layer.js';\nimport _ol_transform_ from '../../transform.js';\nimport _ol_webgl_ from '../../webgl.js';\nimport _ol_webgl_Context_ from '../../webgl/context.js';\n\n/**\n * @constructor\n * @extends {ol.renderer.webgl.Layer}\n * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.\n * @param {ol.layer.Image} imageLayer Tile layer.\n * @api\n */\nvar _ol_renderer_webgl_ImageLayer_ = function(mapRenderer, imageLayer) {\n\n  _ol_renderer_webgl_Layer_.call(this, mapRenderer, imageLayer);\n\n  /**\n   * The last rendered image.\n   * @private\n   * @type {?ol.ImageBase}\n   */\n  this.image_ = null;\n\n  /**\n   * @private\n   * @type {CanvasRenderingContext2D}\n   */\n  this.hitCanvasContext_ = null;\n\n  /**\n   * @private\n   * @type {?ol.Transform}\n   */\n  this.hitTransformationMatrix_ = null;\n\n};\n\n_ol_.inherits(_ol_renderer_webgl_ImageLayer_, _ol_renderer_webgl_Layer_);\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {ol.renderer.Type} type The renderer type.\n * @param {ol.layer.Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n_ol_renderer_webgl_ImageLayer_['handles'] = function(type, layer) {\n  return type === _ol_renderer_Type_.WEBGL && layer.getType() === _ol_LayerType_.IMAGE;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {ol.renderer.Map} mapRenderer The map renderer.\n * @param {ol.layer.Layer} layer The layer to be rendererd.\n * @return {ol.renderer.webgl.ImageLayer} The layer renderer.\n */\n_ol_renderer_webgl_ImageLayer_['create'] = function(mapRenderer, layer) {\n  return new _ol_renderer_webgl_ImageLayer_(\n      /** @type {ol.renderer.webgl.Map} */ (mapRenderer),\n      /** @type {ol.layer.Image} */ (layer)\n  );\n};\n\n\n/**\n * @param {ol.ImageBase} image Image.\n * @private\n * @return {WebGLTexture} Texture.\n */\n_ol_renderer_webgl_ImageLayer_.prototype.createTexture_ = function(image) {\n\n  // We meet the conditions to work with non-power of two textures.\n  // http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support\n  // http://learningwebgl.com/blog/?p=2101\n\n  var imageElement = image.getImage();\n  var gl = this.mapRenderer.getGL();\n\n  return _ol_webgl_Context_.createTexture(\n      gl, imageElement, _ol_webgl_.CLAMP_TO_EDGE, _ol_webgl_.CLAMP_TO_EDGE);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_renderer_webgl_ImageLayer_.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {\n  var layer = this.getLayer();\n  var source = layer.getSource();\n  var resolution = frameState.viewState.resolution;\n  var rotation = frameState.viewState.rotation;\n  var skippedFeatureUids = frameState.skippedFeatureUids;\n  return source.forEachFeatureAtCoordinate(\n      coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,\n\n      /**\n       * @param {ol.Feature|ol.render.Feature} feature Feature.\n       * @return {?} Callback result.\n       */\n      function(feature) {\n        return callback.call(thisArg, feature, layer);\n      });\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_renderer_webgl_ImageLayer_.prototype.prepareFrame = function(frameState, layerState, context) {\n\n  var gl = this.mapRenderer.getGL();\n\n  var pixelRatio = frameState.pixelRatio;\n  var viewState = frameState.viewState;\n  var viewCenter = viewState.center;\n  var viewResolution = viewState.resolution;\n  var viewRotation = viewState.rotation;\n\n  var image = this.image_;\n  var texture = this.texture;\n  var imageLayer = /** @type {ol.layer.Image} */ (this.getLayer());\n  var imageSource = imageLayer.getSource();\n\n  var hints = frameState.viewHints;\n\n  var renderedExtent = frameState.extent;\n  if (layerState.extent !== undefined) {\n    renderedExtent = _ol_extent_.getIntersection(\n        renderedExtent, layerState.extent);\n  }\n  if (!hints[_ol_ViewHint_.ANIMATING] && !hints[_ol_ViewHint_.INTERACTING] &&\n      !_ol_extent_.isEmpty(renderedExtent)) {\n    var projection = viewState.projection;\n    if (!_ol_.ENABLE_RASTER_REPROJECTION) {\n      var sourceProjection = imageSource.getProjection();\n      if (sourceProjection) {\n        projection = sourceProjection;\n      }\n    }\n    var image_ = imageSource.getImage(renderedExtent, viewResolution,\n        pixelRatio, projection);\n    if (image_) {\n      var loaded = this.loadImage(image_);\n      if (loaded) {\n        image = image_;\n        texture = this.createTexture_(image_);\n        if (this.texture) {\n          /**\n           * @param {WebGLRenderingContext} gl GL.\n           * @param {WebGLTexture} texture Texture.\n           */\n          var postRenderFunction = function(gl, texture) {\n            if (!gl.isContextLost()) {\n              gl.deleteTexture(texture);\n            }\n          }.bind(null, gl, this.texture);\n          frameState.postRenderFunctions.push(\n              /** @type {ol.PostRenderFunction} */ (postRenderFunction)\n          );\n        }\n      }\n    }\n  }\n\n  if (image) {\n    var canvas = this.mapRenderer.getContext().getCanvas();\n\n    this.updateProjectionMatrix_(canvas.width, canvas.height,\n        pixelRatio, viewCenter, viewResolution, viewRotation,\n        image.getExtent());\n    this.hitTransformationMatrix_ = null;\n\n    // Translate and scale to flip the Y coord.\n    var texCoordMatrix = this.texCoordMatrix;\n    _ol_transform_.reset(texCoordMatrix);\n    _ol_transform_.scale(texCoordMatrix, 1, -1);\n    _ol_transform_.translate(texCoordMatrix, 0, -1);\n\n    this.image_ = image;\n    this.texture = texture;\n\n    this.updateLogos(frameState, imageSource);\n  }\n\n  return !!image;\n};\n\n\n/**\n * @param {number} canvasWidth Canvas width.\n * @param {number} canvasHeight Canvas height.\n * @param {number} pixelRatio Pixel ratio.\n * @param {ol.Coordinate} viewCenter View center.\n * @param {number} viewResolution View resolution.\n * @param {number} viewRotation View rotation.\n * @param {ol.Extent} imageExtent Image extent.\n * @private\n */\n_ol_renderer_webgl_ImageLayer_.prototype.updateProjectionMatrix_ = function(canvasWidth, canvasHeight, pixelRatio,\n    viewCenter, viewResolution, viewRotation, imageExtent) {\n\n  var canvasExtentWidth = canvasWidth * viewResolution;\n  var canvasExtentHeight = canvasHeight * viewResolution;\n\n  var projectionMatrix = this.projectionMatrix;\n  _ol_transform_.reset(projectionMatrix);\n  _ol_transform_.scale(projectionMatrix,\n      pixelRatio * 2 / canvasExtentWidth,\n      pixelRatio * 2 / canvasExtentHeight);\n  _ol_transform_.rotate(projectionMatrix, -viewRotation);\n  _ol_transform_.translate(projectionMatrix,\n      imageExtent[0] - viewCenter[0],\n      imageExtent[1] - viewCenter[1]);\n  _ol_transform_.scale(projectionMatrix,\n      (imageExtent[2] - imageExtent[0]) / 2,\n      (imageExtent[3] - imageExtent[1]) / 2);\n  _ol_transform_.translate(projectionMatrix, 1, 1);\n\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_renderer_webgl_ImageLayer_.prototype.hasFeatureAtCoordinate = function(coordinate, frameState) {\n  var hasFeature = this.forEachFeatureAtCoordinate(\n      coordinate, frameState, 0, _ol_functions_.TRUE, this);\n  return hasFeature !== undefined;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_renderer_webgl_ImageLayer_.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg) {\n  if (!this.image_ || !this.image_.getImage()) {\n    return undefined;\n  }\n\n  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== _ol_.nullFunction) {\n    // for ImageCanvas sources use the original hit-detection logic,\n    // so that for example also transparent polygons are detected\n    var coordinate = _ol_transform_.apply(\n        frameState.pixelToCoordinateTransform, pixel.slice());\n    var hasFeature = this.forEachFeatureAtCoordinate(\n        coordinate, frameState, 0, _ol_functions_.TRUE, this);\n\n    if (hasFeature) {\n      return callback.call(thisArg, this.getLayer(), null);\n    } else {\n      return undefined;\n    }\n  } else {\n    var imageSize =\n        [this.image_.getImage().width, this.image_.getImage().height];\n\n    if (!this.hitTransformationMatrix_) {\n      this.hitTransformationMatrix_ = this.getHitTransformationMatrix_(\n          frameState.size, imageSize);\n    }\n\n    var pixelOnFrameBuffer = _ol_transform_.apply(\n        this.hitTransformationMatrix_, pixel.slice());\n\n    if (pixelOnFrameBuffer[0] < 0 || pixelOnFrameBuffer[0] > imageSize[0] ||\n        pixelOnFrameBuffer[1] < 0 || pixelOnFrameBuffer[1] > imageSize[1]) {\n      // outside the image, no need to check\n      return undefined;\n    }\n\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = _ol_dom_.createCanvasContext2D(1, 1);\n    }\n\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.image_.getImage(),\n        pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, 0, 0, 1, 1);\n\n    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(),  imageData);\n    } else {\n      return undefined;\n    }\n  }\n};\n\n\n/**\n * The transformation matrix to get the pixel on the image for a\n * pixel on the map.\n * @param {ol.Size} mapSize The map size.\n * @param {ol.Size} imageSize The image size.\n * @return {ol.Transform} The transformation matrix.\n * @private\n */\n_ol_renderer_webgl_ImageLayer_.prototype.getHitTransformationMatrix_ = function(mapSize, imageSize) {\n  // the first matrix takes a map pixel, flips the y-axis and scales to\n  // a range between -1 ... 1\n  var mapCoordTransform = _ol_transform_.create();\n  _ol_transform_.translate(mapCoordTransform, -1, -1);\n  _ol_transform_.scale(mapCoordTransform, 2 / mapSize[0], 2 / mapSize[1]);\n  _ol_transform_.translate(mapCoordTransform, 0, mapSize[1]);\n  _ol_transform_.scale(mapCoordTransform, 1, -1);\n\n  // the second matrix is the inverse of the projection matrix used in the\n  // shader for drawing\n  var projectionMatrixInv = _ol_transform_.invert(this.projectionMatrix.slice());\n\n  // the third matrix scales to the image dimensions and flips the y-axis again\n  var transform = _ol_transform_.create();\n  _ol_transform_.translate(transform, 0, imageSize[1]);\n  _ol_transform_.scale(transform, 1, -1);\n  _ol_transform_.scale(transform, imageSize[0] / 2, imageSize[1] / 2);\n  _ol_transform_.translate(transform, 1, 1);\n\n  _ol_transform_.multiply(transform, projectionMatrixInv);\n  _ol_transform_.multiply(transform, mapCoordTransform);\n\n  return transform;\n};\nexport default _ol_renderer_webgl_ImageLayer_;\n"]},"metadata":{},"sourceType":"module"}
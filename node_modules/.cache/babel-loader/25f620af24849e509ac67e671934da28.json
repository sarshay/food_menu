{"ast":null,"code":"// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nimport _ol_math_ from '../../math.js';\nvar _ol_geom_flat_simplify_ = {};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array.<number>} Simplified line string.\n */\n\n_ol_geom_flat_simplify_.lineString = function (flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];\n\n  if (!highQuality) {\n    end = _ol_geom_flat_simplify_.radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\n\n_ol_geom_flat_simplify_.douglasPeucker = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n = (end - offset) / stride;\n\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n  /** @type {Array.<number>} */\n\n\n  var markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array.<number>} */\n\n  var stack = [offset, end - stride];\n  var index = 0;\n  var i;\n\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n\n    for (i = first + stride; i < last; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n\n      var squaredDistance = _ol_math_.squaredSegmentDistance(x, y, x1, y1, x2, y2);\n\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n\n  for (i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];\n    }\n  }\n\n  return simplifiedOffset;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\n\n_ol_geom_flat_simplify_.douglasPeuckers = function (flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  var i, ii;\n\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\n\n_ol_geom_flat_simplify_.douglasPeuckerss = function (flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  var i, ii;\n\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeuckers(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\n\n_ol_geom_flat_simplify_.radialDistance = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1]; // copy first point\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2 = x1;\n  var y2 = y1;\n\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n\n    if (_ol_math_.squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n\n  return simplifiedOffset;\n};\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\n\n\n_ol_geom_flat_simplify_.snap = function (value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n};\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\n\n_ol_geom_flat_simplify_.quantize = function (flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  } // snap the first coordinate (P1)\n\n\n  var x1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);\n\n  var y1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);\n\n  offset += stride; // add the first coordinate to the output\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n\n  var x2, y2;\n\n  do {\n    x2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);\n    y2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n\n  while (offset < end) {\n    var x3, y3; // snap the next coordinate (P3)\n\n    x3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);\n    y3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride; // skip P3 if it is equal to P2\n\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    } // calculate the delta between P1 and P2\n\n\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1; // calculate the delta between P3 and P1\n\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n\n    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n\n\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  } // add the last point (P2)\n\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\n\n_ol_geom_flat_simplify_.quantizes = function (flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  var i, ii;\n\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = _ol_geom_flat_simplify_.quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n};\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\n\n_ol_geom_flat_simplify_.quantizess = function (flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  var i, ii;\n\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = _ol_geom_flat_simplify_.quantizes(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n};\n\nexport default _ol_geom_flat_simplify_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/geom/flat/simplify.js"],"names":["_ol_math_","_ol_geom_flat_simplify_","lineString","flatCoordinates","offset","end","stride","squaredTolerance","highQuality","opt_simplifiedFlatCoordinates","simplifiedFlatCoordinates","undefined","radialDistance","length","douglasPeucker","simplifiedOffset","n","markers","Array","stack","index","i","last","pop","first","maxSquaredDistance","x1","y1","x2","y2","x","y","squaredDistance","squaredSegmentDistance","push","douglasPeuckers","ends","simplifiedEnds","ii","douglasPeuckerss","endss","simplifiedEndss","snap","value","tolerance","Math","round","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizes","quantizess"],"mappings":"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","sourcesContent":["// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport _ol_math_ from '../../math.js';\nvar _ol_geom_flat_simplify_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array.<number>} Simplified line string.\n */\n_ol_geom_flat_simplify_.lineString = function(flatCoordinates, offset, end,\n    stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?\n    opt_simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = _ol_geom_flat_simplify_.radialDistance(flatCoordinates, offset, end,\n        stride, squaredTolerance,\n        simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeucker(\n      flatCoordinates, offset, end, stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.douglasPeucker = function(flatCoordinates, offset, end,\n    stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array.<number>} */\n  var markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array.<number>} */\n  var stack = [offset, end - stride];\n  var index = 0;\n  var i;\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n    for (i = first + stride; i < last; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      var squaredDistance = _ol_math_.squaredSegmentDistance(\n          x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.douglasPeuckers = function(flatCoordinates, offset,\n    ends, stride, squaredTolerance, simplifiedFlatCoordinates,\n    simplifiedOffset, simplifiedEnds) {\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeucker(\n        flatCoordinates, offset, end, stride, squaredTolerance,\n        simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.douglasPeuckerss = function(\n    flatCoordinates, offset, endss, stride, squaredTolerance,\n    simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeuckers(\n        flatCoordinates, offset, ends, stride, squaredTolerance,\n        simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.radialDistance = function(flatCoordinates, offset, end,\n    stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2 = x1;\n  var y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (_ol_math_.squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\n_ol_geom_flat_simplify_.snap = function(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n};\n\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.quantize = function(flatCoordinates, offset, end, stride,\n    tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  var x1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);\n  var y1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  var x2, y2;\n  do {\n    x2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);\n    y2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    var x3, y3;\n    // snap the next coordinate (P3)\n    x3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);\n    y3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if ((dx1 * dy2 == dy1 * dx2) &&\n        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.quantizes = function(\n    flatCoordinates, offset, ends, stride,\n    tolerance,\n    simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  var i, ii;\n  for (i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = _ol_geom_flat_simplify_.quantize(\n        flatCoordinates, offset, end, stride,\n        tolerance,\n        simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<Array.<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n_ol_geom_flat_simplify_.quantizess = function(\n    flatCoordinates, offset, endss, stride,\n    tolerance,\n    simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = _ol_geom_flat_simplify_.quantizes(\n        flatCoordinates, offset, ends, stride,\n        tolerance,\n        simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n};\nexport default _ol_geom_flat_simplify_;\n"]},"metadata":{},"sourceType":"module"}
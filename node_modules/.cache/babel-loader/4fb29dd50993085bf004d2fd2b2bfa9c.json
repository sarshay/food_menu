{"ast":null,"code":"import _ol_ from '../index.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_math_ from '../math.js';\nimport _ol_proj_ from '../proj.js';\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n *\n * @param {ol.proj.Projection} sourceProj Source projection.\n * @param {ol.proj.Projection} targetProj Target projection.\n * @param {ol.Extent} targetExtent Target extent to triangulate.\n * @param {ol.Extent} maxSourceExtent Maximal source extent that can be used.\n * @param {number} errorThreshold Acceptable error (in source units).\n * @constructor\n */\n\nvar _ol_reproj_Triangulation_ = function (sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {\n  /**\n   * @type {ol.proj.Projection}\n   * @private\n   */\n  this.sourceProj_ = sourceProj;\n  /**\n   * @type {ol.proj.Projection}\n   * @private\n   */\n\n  this.targetProj_ = targetProj;\n  /** @type {!Object.<string, ol.Coordinate>} */\n\n  var transformInvCache = {};\n\n  var transformInv = _ol_proj_.getTransform(this.targetProj_, this.sourceProj_);\n  /**\n   * @param {ol.Coordinate} c A coordinate.\n   * @return {ol.Coordinate} Transformed coordinate.\n   * @private\n   */\n\n\n  this.transformInv_ = function (c) {\n    var key = c[0] + '/' + c[1];\n\n    if (!transformInvCache[key]) {\n      transformInvCache[key] = transformInv(c);\n    }\n\n    return transformInvCache[key];\n  };\n  /**\n   * @type {ol.Extent}\n   * @private\n   */\n\n\n  this.maxSourceExtent_ = maxSourceExtent;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n  /**\n   * @type {Array.<ol.ReprojTriangle>}\n   * @private\n   */\n\n  this.triangles_ = [];\n  /**\n   * Indicates that the triangulation crosses edge of the source projection.\n   * @type {boolean}\n   * @private\n   */\n\n  this.wrapsXInSource_ = false;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && _ol_extent_.getWidth(maxSourceExtent) == _ol_extent_.getWidth(this.sourceProj_.getExtent());\n  /**\n   * @type {?number}\n   * @private\n   */\n\n  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? _ol_extent_.getWidth(this.sourceProj_.getExtent()) : null;\n  /**\n   * @type {?number}\n   * @private\n   */\n\n  this.targetWorldWidth_ = this.targetProj_.getExtent() ? _ol_extent_.getWidth(this.targetProj_.getExtent()) : null;\n\n  var destinationTopLeft = _ol_extent_.getTopLeft(targetExtent);\n\n  var destinationTopRight = _ol_extent_.getTopRight(targetExtent);\n\n  var destinationBottomRight = _ol_extent_.getBottomRight(targetExtent);\n\n  var destinationBottomLeft = _ol_extent_.getBottomLeft(targetExtent);\n\n  var sourceTopLeft = this.transformInv_(destinationTopLeft);\n  var sourceTopRight = this.transformInv_(destinationTopRight);\n  var sourceBottomRight = this.transformInv_(destinationBottomRight);\n  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, _ol_.RASTER_REPROJECTION_MAX_SUBDIVISION);\n\n  if (this.wrapsXInSource_) {\n    var leftBound = Infinity;\n    this.triangles_.forEach(function (triangle, i, arr) {\n      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n    }); // Shift triangles to be as close to `leftBound` as possible\n    // (if the distance is more than `worldWidth / 2` it can be closer.\n\n    this.triangles_.forEach(function (triangle) {\n      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n\n        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n          newTriangle[0][0] -= this.sourceWorldWidth_;\n        }\n\n        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n          newTriangle[1][0] -= this.sourceWorldWidth_;\n        }\n\n        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n          newTriangle[2][0] -= this.sourceWorldWidth_;\n        } // Rarely (if the extent contains both the dateline and prime meridian)\n        // the shift can in turn break some triangles.\n        // Detect this here and don't shift in such cases.\n\n\n        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n\n        if (maxX - minX < this.sourceWorldWidth_ / 2) {\n          triangle.source = newTriangle;\n        }\n      }\n    }, this);\n  }\n\n  transformInvCache = {};\n};\n/**\n * Adds triangle to the triangulation.\n * @param {ol.Coordinate} a The target a coordinate.\n * @param {ol.Coordinate} b The target b coordinate.\n * @param {ol.Coordinate} c The target c coordinate.\n * @param {ol.Coordinate} aSrc The source a coordinate.\n * @param {ol.Coordinate} bSrc The source b coordinate.\n * @param {ol.Coordinate} cSrc The source c coordinate.\n * @private\n */\n\n\n_ol_reproj_Triangulation_.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {\n  this.triangles_.push({\n    source: [aSrc, bSrc, cSrc],\n    target: [a, b, c]\n  });\n};\n/**\n * Adds quad (points in clock-wise order) to the triangulation\n * (and reprojects the vertices) if valid.\n * Performs quad subdivision if needed to increase precision.\n *\n * @param {ol.Coordinate} a The target a coordinate.\n * @param {ol.Coordinate} b The target b coordinate.\n * @param {ol.Coordinate} c The target c coordinate.\n * @param {ol.Coordinate} d The target d coordinate.\n * @param {ol.Coordinate} aSrc The source a coordinate.\n * @param {ol.Coordinate} bSrc The source b coordinate.\n * @param {ol.Coordinate} cSrc The source c coordinate.\n * @param {ol.Coordinate} dSrc The source d coordinate.\n * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n * @private\n */\n\n\n_ol_reproj_Triangulation_.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n  var sourceQuadExtent = _ol_extent_.boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n\n  var sourceCoverageX = this.sourceWorldWidth_ ? _ol_extent_.getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n  var sourceWorldWidth =\n  /** @type {number} */\n  this.sourceWorldWidth_; // when the quad is wrapped in the source projection\n  // it covers most of the projection extent, but not fully\n\n  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n  var needsSubdivision = false;\n\n  if (maxSubdivision > 0) {\n    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n      var targetQuadExtent = _ol_extent_.boundingExtent([a, b, c, d]);\n\n      var targetCoverageX = _ol_extent_.getWidth(targetQuadExtent) / this.targetWorldWidth_;\n      needsSubdivision |= targetCoverageX > _ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;\n    }\n\n    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n      needsSubdivision |= sourceCoverageX > _ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;\n    }\n  }\n\n  if (!needsSubdivision && this.maxSourceExtent_) {\n    if (!_ol_extent_.intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n      // whole quad outside source projection extent -> ignore\n      return;\n    }\n  }\n\n  if (!needsSubdivision) {\n    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n      if (maxSubdivision > 0) {\n        needsSubdivision = true;\n      } else {\n        return;\n      }\n    }\n  }\n\n  if (maxSubdivision > 0) {\n    if (!needsSubdivision) {\n      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n      var centerSrc = this.transformInv_(center);\n      var dx;\n\n      if (wrapsX) {\n        var centerSrcEstimX = (_ol_math_.modulo(aSrc[0], sourceWorldWidth) + _ol_math_.modulo(cSrc[0], sourceWorldWidth)) / 2;\n        dx = centerSrcEstimX - _ol_math_.modulo(centerSrc[0], sourceWorldWidth);\n      } else {\n        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n      }\n\n      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n      var centerSrcErrorSquared = dx * dx + dy * dy;\n      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n    }\n\n    if (needsSubdivision) {\n      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n        // split horizontally (top & bottom)\n        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n        var bcSrc = this.transformInv_(bc);\n        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n        var daSrc = this.transformInv_(da);\n        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n      } else {\n        // split vertically (left & right)\n        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n        var abSrc = this.transformInv_(ab);\n        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n        var cdSrc = this.transformInv_(cd);\n        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n      }\n\n      return;\n    }\n  }\n\n  if (wrapsX) {\n    if (!this.canWrapXInSource_) {\n      return;\n    }\n\n    this.wrapsXInSource_ = true;\n  }\n\n  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n};\n/**\n * Calculates extent of the 'source' coordinates from all the triangles.\n *\n * @return {ol.Extent} Calculated extent.\n */\n\n\n_ol_reproj_Triangulation_.prototype.calculateSourceExtent = function () {\n  var extent = _ol_extent_.createEmpty();\n\n  this.triangles_.forEach(function (triangle, i, arr) {\n    var src = triangle.source;\n\n    _ol_extent_.extendCoordinate(extent, src[0]);\n\n    _ol_extent_.extendCoordinate(extent, src[1]);\n\n    _ol_extent_.extendCoordinate(extent, src[2]);\n  });\n  return extent;\n};\n/**\n * @return {Array.<ol.ReprojTriangle>} Array of the calculated triangles.\n */\n\n\n_ol_reproj_Triangulation_.prototype.getTriangles = function () {\n  return this.triangles_;\n};\n\nexport default _ol_reproj_Triangulation_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/reproj/triangulation.js"],"names":["_ol_","_ol_extent_","_ol_math_","_ol_proj_","_ol_reproj_Triangulation_","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","sourceProj_","targetProj_","transformInvCache","transformInv","getTransform","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","getExtent","getWidth","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","getTopLeft","destinationTopRight","getTopRight","destinationBottomRight","getBottomRight","destinationBottomLeft","getBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","addQuad_","RASTER_REPROJECTION_MAX_SUBDIVISION","leftBound","Infinity","forEach","triangle","i","arr","Math","min","source","max","newTriangle","minX","maxX","prototype","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","maxSubdivision","sourceQuadExtent","boundingExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH","intersects","isFinite","center","centerSrc","dx","centerSrcEstimX","modulo","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","extent","createEmpty","src","extendCoordinate","getTriangles"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,aAAjB;AACA,OAAOC,WAAP,MAAwB,cAAxB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,yBAAyB,GAAG,UAASC,UAAT,EAAqBC,UAArB,EAAiCC,YAAjC,EAC5BC,eAD4B,EACXC,cADW,EACK;AAEnC;AACF;AACA;AACA;AACE,OAAKC,WAAL,GAAmBL,UAAnB;AAEA;AACF;AACA;AACA;;AACE,OAAKM,WAAL,GAAmBL,UAAnB;AAEA;;AACA,MAAIM,iBAAiB,GAAG,EAAxB;;AACA,MAAIC,YAAY,GAAGV,SAAS,CAACW,YAAV,CAAuB,KAAKH,WAA5B,EAAyC,KAAKD,WAA9C,CAAnB;AAEA;AACF;AACA;AACA;AACA;;;AACE,OAAKK,aAAL,GAAqB,UAASC,CAAT,EAAY;AAC/B,QAAIC,GAAG,GAAGD,CAAC,CAAC,CAAD,CAAD,GAAO,GAAP,GAAaA,CAAC,CAAC,CAAD,CAAxB;;AACA,QAAI,CAACJ,iBAAiB,CAACK,GAAD,CAAtB,EAA6B;AAC3BL,MAAAA,iBAAiB,CAACK,GAAD,CAAjB,GAAyBJ,YAAY,CAACG,CAAD,CAArC;AACD;;AACD,WAAOJ,iBAAiB,CAACK,GAAD,CAAxB;AACD,GAND;AAQA;AACF;AACA;AACA;;;AACE,OAAKC,gBAAL,GAAwBV,eAAxB;AAEA;AACF;AACA;AACA;;AACE,OAAKW,sBAAL,GAA8BV,cAAc,GAAGA,cAA/C;AAEA;AACF;AACA;AACA;;AACE,OAAKW,UAAL,GAAkB,EAAlB;AAEA;AACF;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuB,KAAvB;AAEA;AACF;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyB,KAAKZ,WAAL,CAAiBa,QAAjB,MACrB,CAAC,CAACf,eADmB,IAErB,CAAC,CAAC,KAAKE,WAAL,CAAiBc,SAAjB,EAFmB,IAGpBvB,WAAW,CAACwB,QAAZ,CAAqBjB,eAArB,KACAP,WAAW,CAACwB,QAAZ,CAAqB,KAAKf,WAAL,CAAiBc,SAAjB,EAArB,CAJL;AAMA;AACF;AACA;AACA;;AACE,OAAKE,iBAAL,GAAyB,KAAKhB,WAAL,CAAiBc,SAAjB,KACvBvB,WAAW,CAACwB,QAAZ,CAAqB,KAAKf,WAAL,CAAiBc,SAAjB,EAArB,CADuB,GAC8B,IADvD;AAGA;AACF;AACA;AACA;;AACE,OAAKG,iBAAL,GAAyB,KAAKhB,WAAL,CAAiBa,SAAjB,KACvBvB,WAAW,CAACwB,QAAZ,CAAqB,KAAKd,WAAL,CAAiBa,SAAjB,EAArB,CADuB,GAC8B,IADvD;;AAGA,MAAII,kBAAkB,GAAG3B,WAAW,CAAC4B,UAAZ,CAAuBtB,YAAvB,CAAzB;;AACA,MAAIuB,mBAAmB,GAAG7B,WAAW,CAAC8B,WAAZ,CAAwBxB,YAAxB,CAA1B;;AACA,MAAIyB,sBAAsB,GAAG/B,WAAW,CAACgC,cAAZ,CAA2B1B,YAA3B,CAA7B;;AACA,MAAI2B,qBAAqB,GAAGjC,WAAW,CAACkC,aAAZ,CAA0B5B,YAA1B,CAA5B;;AACA,MAAI6B,aAAa,GAAG,KAAKrB,aAAL,CAAmBa,kBAAnB,CAApB;AACA,MAAIS,cAAc,GAAG,KAAKtB,aAAL,CAAmBe,mBAAnB,CAArB;AACA,MAAIQ,iBAAiB,GAAG,KAAKvB,aAAL,CAAmBiB,sBAAnB,CAAxB;AACA,MAAIO,gBAAgB,GAAG,KAAKxB,aAAL,CAAmBmB,qBAAnB,CAAvB;AAEA,OAAKM,QAAL,CACIZ,kBADJ,EACwBE,mBADxB,EAEIE,sBAFJ,EAE4BE,qBAF5B,EAGIE,aAHJ,EAGmBC,cAHnB,EAGmCC,iBAHnC,EAGsDC,gBAHtD,EAIIvC,IAAI,CAACyC,mCAJT;;AAMA,MAAI,KAAKpB,eAAT,EAA0B;AACxB,QAAIqB,SAAS,GAAGC,QAAhB;AACA,SAAKvB,UAAL,CAAgBwB,OAAhB,CAAwB,UAASC,QAAT,EAAmBC,CAAnB,EAAsBC,GAAtB,EAA2B;AACjDL,MAAAA,SAAS,GAAGM,IAAI,CAACC,GAAL,CAASP,SAAT,EACRG,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CADQ,EACeL,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CADf,EACsCL,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CADtC,CAAZ;AAED,KAHD,EAFwB,CAOxB;AACA;;AACA,SAAK9B,UAAL,CAAgBwB,OAAhB,CAAwB,UAASC,QAAT,EAAmB;AACzC,UAAIG,IAAI,CAACG,GAAL,CAASN,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAT,EAAgCL,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAhC,EACAL,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CADA,IACyBR,SADzB,GACqC,KAAKhB,iBAAL,GAAyB,CADlE,EACqE;AACnE,YAAI0B,WAAW,GAAG,CAAC,CAACP,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAD,EAAwBL,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAxB,CAAD,EAChB,CAACL,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAD,EAAwBL,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAxB,CADgB,EAEhB,CAACL,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAD,EAAwBL,QAAQ,CAACK,MAAT,CAAgB,CAAhB,EAAmB,CAAnB,CAAxB,CAFgB,CAAlB;;AAGA,YAAKE,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,IAAoBV,SAArB,GAAkC,KAAKhB,iBAAL,GAAyB,CAA/D,EAAkE;AAChE0B,UAAAA,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,KAAqB,KAAK1B,iBAA1B;AACD;;AACD,YAAK0B,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,IAAoBV,SAArB,GAAkC,KAAKhB,iBAAL,GAAyB,CAA/D,EAAkE;AAChE0B,UAAAA,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,KAAqB,KAAK1B,iBAA1B;AACD;;AACD,YAAK0B,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,IAAoBV,SAArB,GAAkC,KAAKhB,iBAAL,GAAyB,CAA/D,EAAkE;AAChE0B,UAAAA,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,KAAqB,KAAK1B,iBAA1B;AACD,SAZkE,CAcnE;AACA;AACA;;;AACA,YAAI2B,IAAI,GAAGL,IAAI,CAACC,GAAL,CACPG,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,CADO,EACYA,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,CADZ,EAC+BA,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,CAD/B,CAAX;AAEA,YAAIE,IAAI,GAAGN,IAAI,CAACG,GAAL,CACPC,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,CADO,EACYA,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,CADZ,EAC+BA,WAAW,CAAC,CAAD,CAAX,CAAe,CAAf,CAD/B,CAAX;;AAEA,YAAKE,IAAI,GAAGD,IAAR,GAAgB,KAAK3B,iBAAL,GAAyB,CAA7C,EAAgD;AAC9CmB,UAAAA,QAAQ,CAACK,MAAT,GAAkBE,WAAlB;AACD;AACF;AACF,KA3BD,EA2BG,IA3BH;AA4BD;;AAEDxC,EAAAA,iBAAiB,GAAG,EAApB;AACD,CAxID;AA2IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAR,yBAAyB,CAACmD,SAA1B,CAAoCC,YAApC,GAAmD,UAASC,CAAT,EAAYC,CAAZ,EAAe1C,CAAf,EAC/C2C,IAD+C,EACzCC,IADyC,EACnCC,IADmC,EAC7B;AACpB,OAAKzC,UAAL,CAAgB0C,IAAhB,CAAqB;AACnBZ,IAAAA,MAAM,EAAE,CAACS,IAAD,EAAOC,IAAP,EAAaC,IAAb,CADW;AAEnBE,IAAAA,MAAM,EAAE,CAACN,CAAD,EAAIC,CAAJ,EAAO1C,CAAP;AAFW,GAArB;AAID,CAND;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAZ,yBAAyB,CAACmD,SAA1B,CAAoCf,QAApC,GAA+C,UAASiB,CAAT,EAAYC,CAAZ,EAAe1C,CAAf,EAAkBgD,CAAlB,EAC3CL,IAD2C,EACrCC,IADqC,EAC/BC,IAD+B,EACzBI,IADyB,EACnBC,cADmB,EACH;AAE1C,MAAIC,gBAAgB,GAAGlE,WAAW,CAACmE,cAAZ,CAA2B,CAACT,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmBI,IAAnB,CAA3B,CAAvB;;AACA,MAAII,eAAe,GAAG,KAAK3C,iBAAL,GACpBzB,WAAW,CAACwB,QAAZ,CAAqB0C,gBAArB,IAAyC,KAAKzC,iBAD1B,GAC8C,IADpE;AAEA,MAAI4C,gBAAgB;AAAG;AAAuB,OAAK5C,iBAAnD,CAL0C,CAO1C;AACA;;AACA,MAAI6C,MAAM,GAAG,KAAK7D,WAAL,CAAiBa,QAAjB,MACA8C,eAAe,GAAG,GADlB,IACyBA,eAAe,GAAG,CADxD;AAGA,MAAIG,gBAAgB,GAAG,KAAvB;;AAEA,MAAIN,cAAc,GAAG,CAArB,EAAwB;AACtB,QAAI,KAAKvD,WAAL,CAAiB8D,QAAjB,MAA+B,KAAK9C,iBAAxC,EAA2D;AACzD,UAAI+C,gBAAgB,GAAGzE,WAAW,CAACmE,cAAZ,CAA2B,CAACX,CAAD,EAAIC,CAAJ,EAAO1C,CAAP,EAAUgD,CAAV,CAA3B,CAAvB;;AACA,UAAIW,eAAe,GACf1E,WAAW,CAACwB,QAAZ,CAAqBiD,gBAArB,IAAyC,KAAK/C,iBADlD;AAEA6C,MAAAA,gBAAgB,IACZG,eAAe,GAAG3E,IAAI,CAAC4E,sCAD3B;AAED;;AACD,QAAI,CAACL,MAAD,IAAW,KAAK7D,WAAL,CAAiB+D,QAAjB,EAAX,IAA0CJ,eAA9C,EAA+D;AAC7DG,MAAAA,gBAAgB,IACZH,eAAe,GAAGrE,IAAI,CAAC4E,sCAD3B;AAED;AACF;;AAED,MAAI,CAACJ,gBAAD,IAAqB,KAAKtD,gBAA9B,EAAgD;AAC9C,QAAI,CAACjB,WAAW,CAAC4E,UAAZ,CAAuBV,gBAAvB,EAAyC,KAAKjD,gBAA9C,CAAL,EAAsE;AACpE;AACA;AACD;AACF;;AAED,MAAI,CAACsD,gBAAL,EAAuB;AACrB,QAAI,CAACM,QAAQ,CAACnB,IAAI,CAAC,CAAD,CAAL,CAAT,IAAsB,CAACmB,QAAQ,CAACnB,IAAI,CAAC,CAAD,CAAL,CAA/B,IACA,CAACmB,QAAQ,CAAClB,IAAI,CAAC,CAAD,CAAL,CADT,IACsB,CAACkB,QAAQ,CAAClB,IAAI,CAAC,CAAD,CAAL,CAD/B,IAEA,CAACkB,QAAQ,CAACjB,IAAI,CAAC,CAAD,CAAL,CAFT,IAEsB,CAACiB,QAAQ,CAACjB,IAAI,CAAC,CAAD,CAAL,CAF/B,IAGA,CAACiB,QAAQ,CAACb,IAAI,CAAC,CAAD,CAAL,CAHT,IAGsB,CAACa,QAAQ,CAACb,IAAI,CAAC,CAAD,CAAL,CAHnC,EAG8C;AAC5C,UAAIC,cAAc,GAAG,CAArB,EAAwB;AACtBM,QAAAA,gBAAgB,GAAG,IAAnB;AACD,OAFD,MAEO;AACL;AACD;AACF;AACF;;AAED,MAAIN,cAAc,GAAG,CAArB,EAAwB;AACtB,QAAI,CAACM,gBAAL,EAAuB;AACrB,UAAIO,MAAM,GAAG,CAAC,CAACtB,CAAC,CAAC,CAAD,CAAD,GAAOzC,CAAC,CAAC,CAAD,CAAT,IAAgB,CAAjB,EAAoB,CAACyC,CAAC,CAAC,CAAD,CAAD,GAAOzC,CAAC,CAAC,CAAD,CAAT,IAAgB,CAApC,CAAb;AACA,UAAIgE,SAAS,GAAG,KAAKjE,aAAL,CAAmBgE,MAAnB,CAAhB;AAEA,UAAIE,EAAJ;;AACA,UAAIV,MAAJ,EAAY;AACV,YAAIW,eAAe,GACf,CAAChF,SAAS,CAACiF,MAAV,CAAiBxB,IAAI,CAAC,CAAD,CAArB,EAA0BW,gBAA1B,IACApE,SAAS,CAACiF,MAAV,CAAiBtB,IAAI,CAAC,CAAD,CAArB,EAA0BS,gBAA1B,CADD,IACgD,CAFpD;AAGAW,QAAAA,EAAE,GAAGC,eAAe,GAChBhF,SAAS,CAACiF,MAAV,CAAiBH,SAAS,CAAC,CAAD,CAA1B,EAA+BV,gBAA/B,CADJ;AAED,OAND,MAMO;AACLW,QAAAA,EAAE,GAAG,CAACtB,IAAI,CAAC,CAAD,CAAJ,GAAUE,IAAI,CAAC,CAAD,CAAf,IAAsB,CAAtB,GAA0BmB,SAAS,CAAC,CAAD,CAAxC;AACD;;AACD,UAAII,EAAE,GAAG,CAACzB,IAAI,CAAC,CAAD,CAAJ,GAAUE,IAAI,CAAC,CAAD,CAAf,IAAsB,CAAtB,GAA0BmB,SAAS,CAAC,CAAD,CAA5C;AACA,UAAIK,qBAAqB,GAAGJ,EAAE,GAAGA,EAAL,GAAUG,EAAE,GAAGA,EAA3C;AACAZ,MAAAA,gBAAgB,GAAGa,qBAAqB,GAAG,KAAKlE,sBAAhD;AACD;;AACD,QAAIqD,gBAAJ,EAAsB;AACpB,UAAIxB,IAAI,CAACsC,GAAL,CAAS7B,CAAC,CAAC,CAAD,CAAD,GAAOzC,CAAC,CAAC,CAAD,CAAjB,KAAyBgC,IAAI,CAACsC,GAAL,CAAS7B,CAAC,CAAC,CAAD,CAAD,GAAOzC,CAAC,CAAC,CAAD,CAAjB,CAA7B,EAAoD;AAClD;AACA,YAAIuE,EAAE,GAAG,CAAC,CAAC7B,CAAC,CAAC,CAAD,CAAD,GAAO1C,CAAC,CAAC,CAAD,CAAT,IAAgB,CAAjB,EAAoB,CAAC0C,CAAC,CAAC,CAAD,CAAD,GAAO1C,CAAC,CAAC,CAAD,CAAT,IAAgB,CAApC,CAAT;AACA,YAAIwE,KAAK,GAAG,KAAKzE,aAAL,CAAmBwE,EAAnB,CAAZ;AACA,YAAIE,EAAE,GAAG,CAAC,CAACzB,CAAC,CAAC,CAAD,CAAD,GAAOP,CAAC,CAAC,CAAD,CAAT,IAAgB,CAAjB,EAAoB,CAACO,CAAC,CAAC,CAAD,CAAD,GAAOP,CAAC,CAAC,CAAD,CAAT,IAAgB,CAApC,CAAT;AACA,YAAIiC,KAAK,GAAG,KAAK3E,aAAL,CAAmB0E,EAAnB,CAAZ;AAEA,aAAKjD,QAAL,CACIiB,CADJ,EACOC,CADP,EACU6B,EADV,EACcE,EADd,EACkB9B,IADlB,EACwBC,IADxB,EAC8B4B,KAD9B,EACqCE,KADrC,EAC4CxB,cAAc,GAAG,CAD7D;AAEA,aAAK1B,QAAL,CACIiD,EADJ,EACQF,EADR,EACYvE,CADZ,EACegD,CADf,EACkB0B,KADlB,EACyBF,KADzB,EACgC3B,IADhC,EACsCI,IADtC,EAC4CC,cAAc,GAAG,CAD7D;AAED,OAXD,MAWO;AACL;AACA,YAAIyB,EAAE,GAAG,CAAC,CAAClC,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAT,IAAgB,CAAjB,EAAoB,CAACD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAT,IAAgB,CAApC,CAAT;AACA,YAAIkC,KAAK,GAAG,KAAK7E,aAAL,CAAmB4E,EAAnB,CAAZ;AACA,YAAIE,EAAE,GAAG,CAAC,CAAC7E,CAAC,CAAC,CAAD,CAAD,GAAOgD,CAAC,CAAC,CAAD,CAAT,IAAgB,CAAjB,EAAoB,CAAChD,CAAC,CAAC,CAAD,CAAD,GAAOgD,CAAC,CAAC,CAAD,CAAT,IAAgB,CAApC,CAAT;AACA,YAAI8B,KAAK,GAAG,KAAK/E,aAAL,CAAmB8E,EAAnB,CAAZ;AAEA,aAAKrD,QAAL,CACIiB,CADJ,EACOkC,EADP,EACWE,EADX,EACe7B,CADf,EACkBL,IADlB,EACwBiC,KADxB,EAC+BE,KAD/B,EACsC7B,IADtC,EAC4CC,cAAc,GAAG,CAD7D;AAEA,aAAK1B,QAAL,CACImD,EADJ,EACQjC,CADR,EACW1C,CADX,EACc6E,EADd,EACkBD,KADlB,EACyBhC,IADzB,EAC+BC,IAD/B,EACqCiC,KADrC,EAC4C5B,cAAc,GAAG,CAD7D;AAED;;AACD;AACD;AACF;;AAED,MAAIK,MAAJ,EAAY;AACV,QAAI,CAAC,KAAKjD,iBAAV,EAA6B;AAC3B;AACD;;AACD,SAAKD,eAAL,GAAuB,IAAvB;AACD;;AAED,OAAKmC,YAAL,CAAkBC,CAAlB,EAAqBzC,CAArB,EAAwBgD,CAAxB,EAA2BL,IAA3B,EAAiCE,IAAjC,EAAuCI,IAAvC;AACA,OAAKT,YAAL,CAAkBC,CAAlB,EAAqBC,CAArB,EAAwB1C,CAAxB,EAA2B2C,IAA3B,EAAiCC,IAAjC,EAAuCC,IAAvC;AACD,CAzGD;AA4GA;AACA;AACA;AACA;AACA;;;AACAzD,yBAAyB,CAACmD,SAA1B,CAAoCwC,qBAApC,GAA4D,YAAW;AACrE,MAAIC,MAAM,GAAG/F,WAAW,CAACgG,WAAZ,EAAb;;AAEA,OAAK7E,UAAL,CAAgBwB,OAAhB,CAAwB,UAASC,QAAT,EAAmBC,CAAnB,EAAsBC,GAAtB,EAA2B;AACjD,QAAImD,GAAG,GAAGrD,QAAQ,CAACK,MAAnB;;AACAjD,IAAAA,WAAW,CAACkG,gBAAZ,CAA6BH,MAA7B,EAAqCE,GAAG,CAAC,CAAD,CAAxC;;AACAjG,IAAAA,WAAW,CAACkG,gBAAZ,CAA6BH,MAA7B,EAAqCE,GAAG,CAAC,CAAD,CAAxC;;AACAjG,IAAAA,WAAW,CAACkG,gBAAZ,CAA6BH,MAA7B,EAAqCE,GAAG,CAAC,CAAD,CAAxC;AACD,GALD;AAOA,SAAOF,MAAP;AACD,CAXD;AAcA;AACA;AACA;;;AACA5F,yBAAyB,CAACmD,SAA1B,CAAoC6C,YAApC,GAAmD,YAAW;AAC5D,SAAO,KAAKhF,UAAZ;AACD,CAFD;;AAGA,eAAehB,yBAAf","sourcesContent":["import _ol_ from '../index.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_math_ from '../math.js';\nimport _ol_proj_ from '../proj.js';\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n *\n * @param {ol.proj.Projection} sourceProj Source projection.\n * @param {ol.proj.Projection} targetProj Target projection.\n * @param {ol.Extent} targetExtent Target extent to triangulate.\n * @param {ol.Extent} maxSourceExtent Maximal source extent that can be used.\n * @param {number} errorThreshold Acceptable error (in source units).\n * @constructor\n */\nvar _ol_reproj_Triangulation_ = function(sourceProj, targetProj, targetExtent,\n    maxSourceExtent, errorThreshold) {\n\n  /**\n   * @type {ol.proj.Projection}\n   * @private\n   */\n  this.sourceProj_ = sourceProj;\n\n  /**\n   * @type {ol.proj.Projection}\n   * @private\n   */\n  this.targetProj_ = targetProj;\n\n  /** @type {!Object.<string, ol.Coordinate>} */\n  var transformInvCache = {};\n  var transformInv = _ol_proj_.getTransform(this.targetProj_, this.sourceProj_);\n\n  /**\n   * @param {ol.Coordinate} c A coordinate.\n   * @return {ol.Coordinate} Transformed coordinate.\n   * @private\n   */\n  this.transformInv_ = function(c) {\n    var key = c[0] + '/' + c[1];\n    if (!transformInvCache[key]) {\n      transformInvCache[key] = transformInv(c);\n    }\n    return transformInvCache[key];\n  };\n\n  /**\n   * @type {ol.Extent}\n   * @private\n   */\n  this.maxSourceExtent_ = maxSourceExtent;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n  /**\n   * @type {Array.<ol.ReprojTriangle>}\n   * @private\n   */\n  this.triangles_ = [];\n\n  /**\n   * Indicates that the triangulation crosses edge of the source projection.\n   * @type {boolean}\n   * @private\n   */\n  this.wrapsXInSource_ = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      (_ol_extent_.getWidth(maxSourceExtent) ==\n       _ol_extent_.getWidth(this.sourceProj_.getExtent()));\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?\n    _ol_extent_.getWidth(this.sourceProj_.getExtent()) : null;\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.targetWorldWidth_ = this.targetProj_.getExtent() ?\n    _ol_extent_.getWidth(this.targetProj_.getExtent()) : null;\n\n  var destinationTopLeft = _ol_extent_.getTopLeft(targetExtent);\n  var destinationTopRight = _ol_extent_.getTopRight(targetExtent);\n  var destinationBottomRight = _ol_extent_.getBottomRight(targetExtent);\n  var destinationBottomLeft = _ol_extent_.getBottomLeft(targetExtent);\n  var sourceTopLeft = this.transformInv_(destinationTopLeft);\n  var sourceTopRight = this.transformInv_(destinationTopRight);\n  var sourceBottomRight = this.transformInv_(destinationBottomRight);\n  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n  this.addQuad_(\n      destinationTopLeft, destinationTopRight,\n      destinationBottomRight, destinationBottomLeft,\n      sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,\n      _ol_.RASTER_REPROJECTION_MAX_SUBDIVISION);\n\n  if (this.wrapsXInSource_) {\n    var leftBound = Infinity;\n    this.triangles_.forEach(function(triangle, i, arr) {\n      leftBound = Math.min(leftBound,\n          triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n    });\n\n    // Shift triangles to be as close to `leftBound` as possible\n    // (if the distance is more than `worldWidth / 2` it can be closer.\n    this.triangles_.forEach(function(triangle) {\n      if (Math.max(triangle.source[0][0], triangle.source[1][0],\n          triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],\n          [triangle.source[1][0], triangle.source[1][1]],\n          [triangle.source[2][0], triangle.source[2][1]]];\n        if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[0][0] -= this.sourceWorldWidth_;\n        }\n        if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[1][0] -= this.sourceWorldWidth_;\n        }\n        if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[2][0] -= this.sourceWorldWidth_;\n        }\n\n        // Rarely (if the extent contains both the dateline and prime meridian)\n        // the shift can in turn break some triangles.\n        // Detect this here and don't shift in such cases.\n        var minX = Math.min(\n            newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        var maxX = Math.max(\n            newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        if ((maxX - minX) < this.sourceWorldWidth_ / 2) {\n          triangle.source = newTriangle;\n        }\n      }\n    }, this);\n  }\n\n  transformInvCache = {};\n};\n\n\n/**\n * Adds triangle to the triangulation.\n * @param {ol.Coordinate} a The target a coordinate.\n * @param {ol.Coordinate} b The target b coordinate.\n * @param {ol.Coordinate} c The target c coordinate.\n * @param {ol.Coordinate} aSrc The source a coordinate.\n * @param {ol.Coordinate} bSrc The source b coordinate.\n * @param {ol.Coordinate} cSrc The source c coordinate.\n * @private\n */\n_ol_reproj_Triangulation_.prototype.addTriangle_ = function(a, b, c,\n    aSrc, bSrc, cSrc) {\n  this.triangles_.push({\n    source: [aSrc, bSrc, cSrc],\n    target: [a, b, c]\n  });\n};\n\n\n/**\n * Adds quad (points in clock-wise order) to the triangulation\n * (and reprojects the vertices) if valid.\n * Performs quad subdivision if needed to increase precision.\n *\n * @param {ol.Coordinate} a The target a coordinate.\n * @param {ol.Coordinate} b The target b coordinate.\n * @param {ol.Coordinate} c The target c coordinate.\n * @param {ol.Coordinate} d The target d coordinate.\n * @param {ol.Coordinate} aSrc The source a coordinate.\n * @param {ol.Coordinate} bSrc The source b coordinate.\n * @param {ol.Coordinate} cSrc The source c coordinate.\n * @param {ol.Coordinate} dSrc The source d coordinate.\n * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n * @private\n */\n_ol_reproj_Triangulation_.prototype.addQuad_ = function(a, b, c, d,\n    aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n\n  var sourceQuadExtent = _ol_extent_.boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n  var sourceCoverageX = this.sourceWorldWidth_ ?\n    _ol_extent_.getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n  var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n  // when the quad is wrapped in the source projection\n  // it covers most of the projection extent, but not fully\n  var wrapsX = this.sourceProj_.canWrapX() &&\n               sourceCoverageX > 0.5 && sourceCoverageX < 1;\n\n  var needsSubdivision = false;\n\n  if (maxSubdivision > 0) {\n    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n      var targetQuadExtent = _ol_extent_.boundingExtent([a, b, c, d]);\n      var targetCoverageX =\n          _ol_extent_.getWidth(targetQuadExtent) / this.targetWorldWidth_;\n      needsSubdivision |=\n          targetCoverageX > _ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;\n    }\n    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n      needsSubdivision |=\n          sourceCoverageX > _ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;\n    }\n  }\n\n  if (!needsSubdivision && this.maxSourceExtent_) {\n    if (!_ol_extent_.intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n      // whole quad outside source projection extent -> ignore\n      return;\n    }\n  }\n\n  if (!needsSubdivision) {\n    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n      if (maxSubdivision > 0) {\n        needsSubdivision = true;\n      } else {\n        return;\n      }\n    }\n  }\n\n  if (maxSubdivision > 0) {\n    if (!needsSubdivision) {\n      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n      var centerSrc = this.transformInv_(center);\n\n      var dx;\n      if (wrapsX) {\n        var centerSrcEstimX =\n            (_ol_math_.modulo(aSrc[0], sourceWorldWidth) +\n             _ol_math_.modulo(cSrc[0], sourceWorldWidth)) / 2;\n        dx = centerSrcEstimX -\n            _ol_math_.modulo(centerSrc[0], sourceWorldWidth);\n      } else {\n        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n      }\n      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n      var centerSrcErrorSquared = dx * dx + dy * dy;\n      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n    }\n    if (needsSubdivision) {\n      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n        // split horizontally (top & bottom)\n        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n        var bcSrc = this.transformInv_(bc);\n        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n        var daSrc = this.transformInv_(da);\n\n        this.addQuad_(\n            a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n        this.addQuad_(\n            da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n      } else {\n        // split vertically (left & right)\n        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n        var abSrc = this.transformInv_(ab);\n        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n        var cdSrc = this.transformInv_(cd);\n\n        this.addQuad_(\n            a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n        this.addQuad_(\n            ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n      }\n      return;\n    }\n  }\n\n  if (wrapsX) {\n    if (!this.canWrapXInSource_) {\n      return;\n    }\n    this.wrapsXInSource_ = true;\n  }\n\n  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n};\n\n\n/**\n * Calculates extent of the 'source' coordinates from all the triangles.\n *\n * @return {ol.Extent} Calculated extent.\n */\n_ol_reproj_Triangulation_.prototype.calculateSourceExtent = function() {\n  var extent = _ol_extent_.createEmpty();\n\n  this.triangles_.forEach(function(triangle, i, arr) {\n    var src = triangle.source;\n    _ol_extent_.extendCoordinate(extent, src[0]);\n    _ol_extent_.extendCoordinate(extent, src[1]);\n    _ol_extent_.extendCoordinate(extent, src[2]);\n  });\n\n  return extent;\n};\n\n\n/**\n * @return {Array.<ol.ReprojTriangle>} Array of the calculated triangles.\n */\n_ol_reproj_Triangulation_.prototype.getTriangles = function() {\n  return this.triangles_;\n};\nexport default _ol_reproj_Triangulation_;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _ol_math_ from '../../math.js';\nvar _ol_geom_flat_textpath_ = {};\n/**\n * @param {Array.<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {function(string):number} measure Measure function returning the\n * width of the character passed as 1st argument.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @return {Array.<Array.<*>>} The result array of null if `maxAngle` was\n * exceeded. Entries of the array are x, y, anchorX, angle, chunk.\n */\n\n_ol_geom_flat_textpath_.lineString = function (flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {\n  var result = []; // Keep text upright\n\n  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n  var numChars = text.length;\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  offset += stride;\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var segmentM = 0;\n  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  var chunk = '';\n  var chunkLength = 0;\n  var data, index, previousAngle;\n\n  for (var i = 0; i < numChars; ++i) {\n    index = reverse ? numChars - i - 1 : i;\n    var char = text.charAt(index);\n    chunk = reverse ? char + chunk : chunk + char;\n    var charLength = measure(chunk) - chunkLength;\n    chunkLength += charLength;\n    var charM = startM + charLength / 2;\n\n    while (offset < end - stride && segmentM + segmentLength < charM) {\n      x1 = x2;\n      y1 = y2;\n      offset += stride;\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      segmentM += segmentLength;\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n\n    var segmentPos = charM - segmentM;\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      angle += angle > 0 ? -Math.PI : Math.PI;\n    }\n\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;\n\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n\n    var interpolate = segmentPos / segmentLength;\n\n    var x = _ol_math_.lerp(x1, x2, interpolate);\n\n    var y = _ol_math_.lerp(y1, y2, interpolate);\n\n    if (previousAngle == angle) {\n      if (reverse) {\n        data[0] = x;\n        data[1] = y;\n        data[2] = charLength / 2;\n      }\n\n      data[4] = chunk;\n    } else {\n      chunk = char;\n      chunkLength = charLength;\n      data = [x, y, charLength / 2, angle, chunk];\n\n      if (reverse) {\n        result.unshift(data);\n      } else {\n        result.push(data);\n      }\n\n      previousAngle = angle;\n    }\n\n    startM += charLength;\n  }\n\n  return result;\n};\n\nexport default _ol_geom_flat_textpath_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/geom/flat/textpath.js"],"names":["_ol_math_","_ol_geom_flat_textpath_","lineString","flatCoordinates","offset","end","stride","text","measure","startM","maxAngle","result","reverse","numChars","length","x1","y1","x2","y2","segmentM","segmentLength","Math","sqrt","pow","chunk","chunkLength","data","index","previousAngle","i","char","charAt","charLength","charM","segmentPos","angle","atan2","PI","undefined","delta","abs","interpolate","x","lerp","y","unshift","push"],"mappings":"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","sourcesContent":["import _ol_math_ from '../../math.js';\nvar _ol_geom_flat_textpath_ = {};\n\n\n/**\n * @param {Array.<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {function(string):number} measure Measure function returning the\n * width of the character passed as 1st argument.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @return {Array.<Array.<*>>} The result array of null if `maxAngle` was\n * exceeded. Entries of the array are x, y, anchorX, angle, chunk.\n */\n_ol_geom_flat_textpath_.lineString = function(\n    flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {\n  var result = [];\n\n  // Keep text upright\n  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n\n  var numChars = text.length;\n\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  offset += stride;\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var segmentM = 0;\n  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n\n  var chunk = '';\n  var chunkLength = 0;\n  var data, index, previousAngle;\n  for (var i = 0; i < numChars; ++i) {\n    index = reverse ? numChars - i - 1 : i;\n    var char = text.charAt(index);\n    chunk = reverse ? char + chunk : chunk + char;\n    var charLength = measure(chunk) - chunkLength;\n    chunkLength += charLength;\n    var charM = startM + charLength / 2;\n    while (offset < end - stride && segmentM + segmentLength < charM) {\n      x1 = x2;\n      y1 = y2;\n      offset += stride;\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      segmentM += segmentLength;\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n    var segmentPos = charM - segmentM;\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -Math.PI : Math.PI;\n    }\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    var interpolate = segmentPos / segmentLength;\n    var x = _ol_math_.lerp(x1, x2, interpolate);\n    var y = _ol_math_.lerp(y1, y2, interpolate);\n    if (previousAngle == angle) {\n      if (reverse) {\n        data[0] = x;\n        data[1] = y;\n        data[2] = charLength / 2;\n      }\n      data[4] = chunk;\n    } else {\n      chunk = char;\n      chunkLength = charLength;\n      data = [x, y, charLength / 2, angle, chunk];\n      if (reverse) {\n        result.unshift(data);\n      } else {\n        result.push(data);\n      }\n      previousAngle = angle;\n    }\n    startM += charLength;\n  }\n  return result;\n};\nexport default _ol_geom_flat_textpath_;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _ol_ from '../index.js';\nimport _ol_Tile_ from '../tile.js';\nimport _ol_TileState_ from '../tilestate.js';\nimport _ol_events_ from '../events.js';\nimport _ol_events_EventType_ from '../events/eventtype.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_math_ from '../math.js';\nimport _ol_reproj_ from '../reproj.js';\nimport _ol_reproj_Triangulation_ from '../reproj/triangulation.js';\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link ol.source.TileImage}.\n *\n * @constructor\n * @extends {ol.Tile}\n * @param {ol.proj.Projection} sourceProj Source projection.\n * @param {ol.tilegrid.TileGrid} sourceTileGrid Source tile grid.\n * @param {ol.proj.Projection} targetProj Target projection.\n * @param {ol.tilegrid.TileGrid} targetTileGrid Target tile grid.\n * @param {ol.TileCoord} tileCoord Coordinate of the tile.\n * @param {ol.TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} gutter Gutter of the source tiles.\n * @param {ol.ReprojTileFunctionType} getTileFunction\n *     Function returning source tiles (z, x, y, pixelRatio).\n * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n */\n\nvar _ol_reproj_Tile_ = function (sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {\n  _ol_Tile_.call(this, tileCoord, _ol_TileState_.IDLE);\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n\n  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.pixelRatio_ = pixelRatio;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.gutter_ = gutter;\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n\n  this.canvas_ = null;\n  /**\n   * @private\n   * @type {ol.tilegrid.TileGrid}\n   */\n\n  this.sourceTileGrid_ = sourceTileGrid;\n  /**\n   * @private\n   * @type {ol.tilegrid.TileGrid}\n   */\n\n  this.targetTileGrid_ = targetTileGrid;\n  /**\n   * @private\n   * @type {ol.TileCoord}\n   */\n\n  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n  /**\n   * @private\n   * @type {!Array.<ol.Tile>}\n   */\n\n  this.sourceTiles_ = [];\n  /**\n   * @private\n   * @type {Array.<ol.EventsKey>}\n   */\n\n  this.sourcesListenerKeys_ = null;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.sourceZ_ = 0;\n  var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n  var maxTargetExtent = this.targetTileGrid_.getExtent();\n  var maxSourceExtent = this.sourceTileGrid_.getExtent();\n  var limitedTargetExtent = maxTargetExtent ? _ol_extent_.getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n  if (_ol_extent_.getArea(limitedTargetExtent) === 0) {\n    // Tile is completely outside range -> EMPTY\n    // TODO: is it actually correct that the source even creates the tile ?\n    this.state = _ol_TileState_.EMPTY;\n    return;\n  }\n\n  var sourceProjExtent = sourceProj.getExtent();\n\n  if (sourceProjExtent) {\n    if (!maxSourceExtent) {\n      maxSourceExtent = sourceProjExtent;\n    } else {\n      maxSourceExtent = _ol_extent_.getIntersection(maxSourceExtent, sourceProjExtent);\n    }\n  }\n\n  var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);\n\n  var targetCenter = _ol_extent_.getCenter(limitedTargetExtent);\n\n  var sourceResolution = _ol_reproj_.calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    // invalid sourceResolution -> EMPTY\n    // probably edges of the projections when no extent is defined\n    this.state = _ol_TileState_.EMPTY;\n    return;\n  }\n\n  var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;\n  /**\n   * @private\n   * @type {!ol.reproj.Triangulation}\n   */\n\n  this.triangulation_ = new _ol_reproj_Triangulation_(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);\n\n  if (this.triangulation_.getTriangles().length === 0) {\n    // no valid triangles -> EMPTY\n    this.state = _ol_TileState_.EMPTY;\n    return;\n  }\n\n  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n  var sourceExtent = this.triangulation_.calculateSourceExtent();\n\n  if (maxSourceExtent) {\n    if (sourceProj.canWrapX()) {\n      sourceExtent[1] = _ol_math_.clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n      sourceExtent[3] = _ol_math_.clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n    } else {\n      sourceExtent = _ol_extent_.getIntersection(sourceExtent, maxSourceExtent);\n    }\n  }\n\n  if (!_ol_extent_.getArea(sourceExtent)) {\n    this.state = _ol_TileState_.EMPTY;\n  } else {\n    var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);\n\n    for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n      for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n        var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n\n        if (tile) {\n          this.sourceTiles_.push(tile);\n        }\n      }\n    }\n\n    if (this.sourceTiles_.length === 0) {\n      this.state = _ol_TileState_.EMPTY;\n    }\n  }\n};\n\n_ol_.inherits(_ol_reproj_Tile_, _ol_Tile_);\n/**\n * @inheritDoc\n */\n\n\n_ol_reproj_Tile_.prototype.disposeInternal = function () {\n  if (this.state == _ol_TileState_.LOADING) {\n    this.unlistenSources_();\n  }\n\n  _ol_Tile_.prototype.disposeInternal.call(this);\n};\n/**\n * Get the HTML Canvas element for this tile.\n * @return {HTMLCanvasElement} Canvas.\n */\n\n\n_ol_reproj_Tile_.prototype.getImage = function () {\n  return this.canvas_;\n};\n/**\n * @private\n */\n\n\n_ol_reproj_Tile_.prototype.reproject_ = function () {\n  var sources = [];\n  this.sourceTiles_.forEach(function (tile, i, arr) {\n    if (tile && tile.getState() == _ol_TileState_.LOADED) {\n      sources.push({\n        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n        image: tile.getImage()\n      });\n    }\n  }, this);\n  this.sourceTiles_.length = 0;\n\n  if (sources.length === 0) {\n    this.state = _ol_TileState_.ERROR;\n  } else {\n    var z = this.wrappedTileCoord_[0];\n    var size = this.targetTileGrid_.getTileSize(z);\n    var width = typeof size === 'number' ? size : size[0];\n    var height = typeof size === 'number' ? size : size[1];\n    var targetResolution = this.targetTileGrid_.getResolution(z);\n    var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n    var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n    this.canvas_ = _ol_reproj_.render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);\n    this.state = _ol_TileState_.LOADED;\n  }\n\n  this.changed();\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_reproj_Tile_.prototype.load = function () {\n  if (this.state == _ol_TileState_.IDLE) {\n    this.state = _ol_TileState_.LOADING;\n    this.changed();\n    var leftToLoad = 0;\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      var state = tile.getState();\n\n      if (state == _ol_TileState_.IDLE || state == _ol_TileState_.LOADING) {\n        leftToLoad++;\n        var sourceListenKey;\n        sourceListenKey = _ol_events_.listen(tile, _ol_events_EventType_.CHANGE, function (e) {\n          var state = tile.getState();\n\n          if (state == _ol_TileState_.LOADED || state == _ol_TileState_.ERROR || state == _ol_TileState_.EMPTY) {\n            _ol_events_.unlistenByKey(sourceListenKey);\n\n            leftToLoad--;\n\n            if (leftToLoad === 0) {\n              this.unlistenSources_();\n              this.reproject_();\n            }\n          }\n        }, this);\n        this.sourcesListenerKeys_.push(sourceListenKey);\n      }\n    }, this);\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      var state = tile.getState();\n\n      if (state == _ol_TileState_.IDLE) {\n        tile.load();\n      }\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    }\n  }\n};\n/**\n * @private\n */\n\n\n_ol_reproj_Tile_.prototype.unlistenSources_ = function () {\n  this.sourcesListenerKeys_.forEach(_ol_events_.unlistenByKey);\n  this.sourcesListenerKeys_ = null;\n};\n\nexport default _ol_reproj_Tile_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/reproj/tile.js"],"names":["_ol_","_ol_Tile_","_ol_TileState_","_ol_events_","_ol_events_EventType_","_ol_extent_","_ol_math_","_ol_reproj_","_ol_reproj_Triangulation_","_ol_reproj_Tile_","sourceProj","sourceTileGrid","targetProj","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","opt_errorThreshold","opt_renderEdges","call","IDLE","renderEdges_","undefined","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","getExtent","maxSourceExtent","limitedTargetExtent","getIntersection","getArea","state","EMPTY","sourceProjExtent","targetResolution","getResolution","targetCenter","getCenter","sourceResolution","calculateSourceResolution","isFinite","errorThresholdInPixels","DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","canWrapX","clamp","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","push","inherits","prototype","disposeInternal","LOADING","unlistenSources_","getImage","reproject_","sources","forEach","i","arr","getState","LOADED","extent","image","ERROR","z","size","getTileSize","width","height","render","changed","load","leftToLoad","sourceListenKey","listen","CHANGE","e","unlistenByKey","setTimeout","bind"],"mappings":"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","sourcesContent":["import _ol_ from '../index.js';\nimport _ol_Tile_ from '../tile.js';\nimport _ol_TileState_ from '../tilestate.js';\nimport _ol_events_ from '../events.js';\nimport _ol_events_EventType_ from '../events/eventtype.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_math_ from '../math.js';\nimport _ol_reproj_ from '../reproj.js';\nimport _ol_reproj_Triangulation_ from '../reproj/triangulation.js';\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link ol.source.TileImage}.\n *\n * @constructor\n * @extends {ol.Tile}\n * @param {ol.proj.Projection} sourceProj Source projection.\n * @param {ol.tilegrid.TileGrid} sourceTileGrid Source tile grid.\n * @param {ol.proj.Projection} targetProj Target projection.\n * @param {ol.tilegrid.TileGrid} targetTileGrid Target tile grid.\n * @param {ol.TileCoord} tileCoord Coordinate of the tile.\n * @param {ol.TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} gutter Gutter of the source tiles.\n * @param {ol.ReprojTileFunctionType} getTileFunction\n *     Function returning source tiles (z, x, y, pixelRatio).\n * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n */\nvar _ol_reproj_Tile_ = function(sourceProj, sourceTileGrid,\n    targetProj, targetTileGrid, tileCoord, wrappedTileCoord,\n    pixelRatio, gutter, getTileFunction,\n    opt_errorThreshold, opt_renderEdges) {\n  _ol_Tile_.call(this, tileCoord, _ol_TileState_.IDLE);\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.pixelRatio_ = pixelRatio;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.gutter_ = gutter;\n\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n  this.canvas_ = null;\n\n  /**\n   * @private\n   * @type {ol.tilegrid.TileGrid}\n   */\n  this.sourceTileGrid_ = sourceTileGrid;\n\n  /**\n   * @private\n   * @type {ol.tilegrid.TileGrid}\n   */\n  this.targetTileGrid_ = targetTileGrid;\n\n  /**\n   * @private\n   * @type {ol.TileCoord}\n   */\n  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n  /**\n   * @private\n   * @type {!Array.<ol.Tile>}\n   */\n  this.sourceTiles_ = [];\n\n  /**\n   * @private\n   * @type {Array.<ol.EventsKey>}\n   */\n  this.sourcesListenerKeys_ = null;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.sourceZ_ = 0;\n\n  var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n  var maxTargetExtent = this.targetTileGrid_.getExtent();\n  var maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n  var limitedTargetExtent = maxTargetExtent ?\n    _ol_extent_.getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n  if (_ol_extent_.getArea(limitedTargetExtent) === 0) {\n    // Tile is completely outside range -> EMPTY\n    // TODO: is it actually correct that the source even creates the tile ?\n    this.state = _ol_TileState_.EMPTY;\n    return;\n  }\n\n  var sourceProjExtent = sourceProj.getExtent();\n  if (sourceProjExtent) {\n    if (!maxSourceExtent) {\n      maxSourceExtent = sourceProjExtent;\n    } else {\n      maxSourceExtent = _ol_extent_.getIntersection(\n          maxSourceExtent, sourceProjExtent);\n    }\n  }\n\n  var targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]);\n\n  var targetCenter = _ol_extent_.getCenter(limitedTargetExtent);\n  var sourceResolution = _ol_reproj_.calculateSourceResolution(\n      sourceProj, targetProj, targetCenter, targetResolution);\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    // invalid sourceResolution -> EMPTY\n    // probably edges of the projections when no extent is defined\n    this.state = _ol_TileState_.EMPTY;\n    return;\n  }\n\n  var errorThresholdInPixels = opt_errorThreshold !== undefined ?\n    opt_errorThreshold : _ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;\n\n  /**\n   * @private\n   * @type {!ol.reproj.Triangulation}\n   */\n  this.triangulation_ = new _ol_reproj_Triangulation_(\n      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,\n      sourceResolution * errorThresholdInPixels);\n\n  if (this.triangulation_.getTriangles().length === 0) {\n    // no valid triangles -> EMPTY\n    this.state = _ol_TileState_.EMPTY;\n    return;\n  }\n\n  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n  var sourceExtent = this.triangulation_.calculateSourceExtent();\n\n  if (maxSourceExtent) {\n    if (sourceProj.canWrapX()) {\n      sourceExtent[1] = _ol_math_.clamp(\n          sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n      sourceExtent[3] = _ol_math_.clamp(\n          sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n    } else {\n      sourceExtent = _ol_extent_.getIntersection(sourceExtent, maxSourceExtent);\n    }\n  }\n\n  if (!_ol_extent_.getArea(sourceExtent)) {\n    this.state = _ol_TileState_.EMPTY;\n  } else {\n    var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent, this.sourceZ_);\n\n    for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n      for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n        var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n        if (tile) {\n          this.sourceTiles_.push(tile);\n        }\n      }\n    }\n\n    if (this.sourceTiles_.length === 0) {\n      this.state = _ol_TileState_.EMPTY;\n    }\n  }\n};\n\n_ol_.inherits(_ol_reproj_Tile_, _ol_Tile_);\n\n\n/**\n * @inheritDoc\n */\n_ol_reproj_Tile_.prototype.disposeInternal = function() {\n  if (this.state == _ol_TileState_.LOADING) {\n    this.unlistenSources_();\n  }\n  _ol_Tile_.prototype.disposeInternal.call(this);\n};\n\n\n/**\n * Get the HTML Canvas element for this tile.\n * @return {HTMLCanvasElement} Canvas.\n */\n_ol_reproj_Tile_.prototype.getImage = function() {\n  return this.canvas_;\n};\n\n\n/**\n * @private\n */\n_ol_reproj_Tile_.prototype.reproject_ = function() {\n  var sources = [];\n  this.sourceTiles_.forEach(function(tile, i, arr) {\n    if (tile && tile.getState() == _ol_TileState_.LOADED) {\n      sources.push({\n        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n        image: tile.getImage()\n      });\n    }\n  }, this);\n  this.sourceTiles_.length = 0;\n\n  if (sources.length === 0) {\n    this.state = _ol_TileState_.ERROR;\n  } else {\n    var z = this.wrappedTileCoord_[0];\n    var size = this.targetTileGrid_.getTileSize(z);\n    var width = typeof size === 'number' ? size : size[0];\n    var height = typeof size === 'number' ? size : size[1];\n    var targetResolution = this.targetTileGrid_.getResolution(z);\n    var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n    var targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_);\n    this.canvas_ = _ol_reproj_.render(width, height, this.pixelRatio_,\n        sourceResolution, this.sourceTileGrid_.getExtent(),\n        targetResolution, targetExtent, this.triangulation_, sources,\n        this.gutter_, this.renderEdges_);\n\n    this.state = _ol_TileState_.LOADED;\n  }\n  this.changed();\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_reproj_Tile_.prototype.load = function() {\n  if (this.state == _ol_TileState_.IDLE) {\n    this.state = _ol_TileState_.LOADING;\n    this.changed();\n\n    var leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach(function(tile, i, arr) {\n      var state = tile.getState();\n      if (state == _ol_TileState_.IDLE || state == _ol_TileState_.LOADING) {\n        leftToLoad++;\n\n        var sourceListenKey;\n        sourceListenKey = _ol_events_.listen(tile, _ol_events_EventType_.CHANGE,\n            function(e) {\n              var state = tile.getState();\n              if (state == _ol_TileState_.LOADED ||\n                  state == _ol_TileState_.ERROR ||\n                  state == _ol_TileState_.EMPTY) {\n                _ol_events_.unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            }, this);\n        this.sourcesListenerKeys_.push(sourceListenKey);\n      }\n    }, this);\n\n    this.sourceTiles_.forEach(function(tile, i, arr) {\n      var state = tile.getState();\n      if (state == _ol_TileState_.IDLE) {\n        tile.load();\n      }\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    }\n  }\n};\n\n\n/**\n * @private\n */\n_ol_reproj_Tile_.prototype.unlistenSources_ = function() {\n  this.sourcesListenerKeys_.forEach(_ol_events_.unlistenByKey);\n  this.sourcesListenerKeys_ = null;\n};\nexport default _ol_reproj_Tile_;\n"]},"metadata":{},"sourceType":"module"}
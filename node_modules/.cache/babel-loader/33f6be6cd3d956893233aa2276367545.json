{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/layer/MapboxVector\n */\n\n\nimport BaseEvent from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport MVT from '../format/MVT.js';\nimport SourceState from '../source/State.js';\nimport VectorTileLayer from '../layer/VectorTile.js';\nimport VectorTileSource from '../source/VectorTile.js';\nimport { applyStyle, setupVectorSource } from 'ol-mapbox-style';\nvar mapboxBaseUrl = 'https://api.mapbox.com';\n/**\n * Gets the path from a mapbox:// URL.\n * @param {string} url The Mapbox URL.\n * @return {string} The path.\n * @private\n */\n\nexport function getMapboxPath(url) {\n  var startsWith = 'mapbox://';\n\n  if (url.indexOf(startsWith) !== 0) {\n    return '';\n  }\n\n  return url.slice(startsWith.length);\n}\n/**\n * Turns mapbox:// sprite URLs into resolvable URLs.\n * @param {string} url The sprite URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\n\nexport function normalizeSpriteUrl(url, token) {\n  var mapboxPath = getMapboxPath(url);\n\n  if (!mapboxPath) {\n    return url;\n  }\n\n  var startsWith = 'sprites/';\n\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(\"unexpected sprites url: \" + url);\n  }\n\n  var sprite = mapboxPath.slice(startsWith.length);\n  return mapboxBaseUrl + \"/styles/v1/\" + sprite + \"/sprite?access_token=\" + token;\n}\n/**\n * Turns mapbox:// glyphs URLs into resolvable URLs.\n * @param {string} url The glyphs URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\n\nexport function normalizeGlyphsUrl(url, token) {\n  var mapboxPath = getMapboxPath(url);\n\n  if (!mapboxPath) {\n    return url;\n  }\n\n  var startsWith = 'fonts/';\n\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(\"unexpected fonts url: \" + url);\n  }\n\n  var font = mapboxPath.slice(startsWith.length);\n  return mapboxBaseUrl + \"/fonts/v1/\" + font + \"/0-255.pbf?access_token=\" + token;\n}\n/**\n * Turns mapbox:// style URLs into resolvable URLs.\n * @param {string} url The style URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\n\nexport function normalizeStyleUrl(url, token) {\n  var mapboxPath = getMapboxPath(url);\n\n  if (!mapboxPath) {\n    return url;\n  }\n\n  var startsWith = 'styles/';\n\n  if (mapboxPath.indexOf(startsWith) !== 0) {\n    throw new Error(\"unexpected style url: \" + url);\n  }\n\n  var style = mapboxPath.slice(startsWith.length);\n  return mapboxBaseUrl + \"/styles/v1/\" + style + \"?&access_token=\" + token;\n}\n/**\n * Turns mapbox:// source URLs into vector tile URL templates.\n * @param {string} url The source URL.\n * @param {string} token The access token.\n * @return {string} A vector tile template.\n * @private\n */\n\nexport function normalizeSourceUrl(url, token) {\n  var mapboxPath = getMapboxPath(url);\n\n  if (!mapboxPath) {\n    return url;\n  }\n\n  return \"https://{a-d}.tiles.mapbox.com/v4/\" + mapboxPath + \"/{z}/{x}/{y}.vector.pbf?access_token=\" + token;\n}\n/**\n * @classdesc\n * Event emitted on configuration or loading error.\n */\n\nvar ErrorEvent =\n/** @class */\nfunction (_super) {\n  __extends(ErrorEvent, _super);\n  /**\n   * @param {Error} error error object.\n   */\n\n\n  function ErrorEvent(error) {\n    var _this = _super.call(this, EventType.ERROR) || this;\n    /**\n     * @type {Error}\n     */\n\n\n    _this.error = error;\n    return _this;\n  }\n\n  return ErrorEvent;\n}(BaseEvent);\n/**\n * @typedef {Object} StyleObject\n * @property {Object<string, SourceObject>} sources The style sources.\n * @property {string} sprite The sprite URL.\n * @property {string} glyphs The glyphs URL.\n * @property {Array<LayerObject>} layers The style layers.\n */\n\n/**\n * @typedef {Object} SourceObject\n * @property {string} url The source URL.\n * @property {SourceType} type The source type.\n */\n\n/**\n * The Mapbox source type.\n * @enum {string}\n */\n\n\nvar SourceType = {\n  VECTOR: 'vector'\n};\n/**\n * @typedef {Object} LayerObject\n * @property {string} id The layer id.\n * @property {string} source The source id.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} styleUrl The URL of the Mapbox style object to use for this layer.  For a\n * style created with Mapbox Studio and hosted on Mapbox, this will look like\n * 'mapbox://styles/you/your-style'.\n * @property {string} [accessToken] The access token for your Mapbox style. This has to be provided\n * for `mapbox://` style urls. For `https://` and other urls, access keys must be part of the style\n * url.\n * @property {string} [source] If your style uses more than one source, you need to use either the\n * `source` property or the `layers` property to limit rendering to a single vector source.  The\n * `source` property corresponds to the id of a vector source in your Mapbox style.\n * @property {Array<string>} [layers] Limit rendering to the list of included layers.  All layers\n * must share the same vector source.  If your style uses more than one source, you need to use\n * either the `source` property or the `layers` property to limit rendering to a single vector\n * source.\n * @property {boolean} [declutter=true] Declutter images and text. Decluttering is applied to all\n * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority\n * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.\n * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has\n * higher priority.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {import(\"./VectorTileRenderType.js\").default|string} [renderMode='hybrid'] Render mode for vector tiles:\n *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views.\n *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector\n *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of\n *    another layer with the same source).\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../PluggableMap.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * A vector tile layer based on a Mapbox style that uses a single vector source.  Configure\n * the layer with the `styleUrl` and `accessToken` shown in Mapbox Studio's share panel.\n * If the style uses more than one source, use the `source` property to choose a single\n * vector source.  If you want to render a subset of the layers in the style, use the `layers`\n * property (all layers must share the same vector source).  See the constructor options for\n * more detail.\n *\n *     var map = new Map({\n *       view: new View({\n *         center: [0, 0],\n *         zoom: 1\n *       }),\n *       layers: [\n *         new MapboxVectorLayer({\n *           styleUrl: 'mapbox://styles/mapbox/bright-v9',\n *           accessToken: 'your-mapbox-access-token-here'\n *         })\n *       ],\n *       target: 'map'\n *     });\n *\n * On configuration or loading error, the layer will trigger an `'error'` event.  Listeners\n * will receive an object with an `error` property that can be used to diagnose the problem.\n *\n * @param {Options} options Options.\n * @extends {VectorTileLayer}\n * @fires module:ol/events/Event~BaseEvent#event:error\n * @api\n */\n\nvar MapboxVectorLayer =\n/** @class */\nfunction (_super) {\n  __extends(MapboxVectorLayer, _super);\n  /**\n   * @param {Options} options Layer options.  At a minimum, `styleUrl` and `accessToken`\n   * must be provided.\n   */\n\n\n  function MapboxVectorLayer(options) {\n    var _this = this;\n\n    var declutter = 'declutter' in options ? options.declutter : true;\n    var source = new VectorTileSource({\n      state: SourceState.LOADING,\n      format: new MVT()\n    });\n    _this = _super.call(this, {\n      source: source,\n      declutter: declutter,\n      className: options.className,\n      opacity: options.opacity,\n      visible: options.visible,\n      zIndex: options.zIndex,\n      minResolution: options.minResolution,\n      maxResolution: options.maxResolution,\n      minZoom: options.minZoom,\n      maxZoom: options.maxZoom,\n      renderOrder: options.renderOrder,\n      renderBuffer: options.renderBuffer,\n      renderMode: options.renderMode,\n      map: options.map,\n      updateWhileAnimating: options.updateWhileAnimating,\n      updateWhileInteracting: options.updateWhileInteracting,\n      preload: options.preload,\n      useInterimTilesOnError: options.useInterimTilesOnError,\n      properties: options.properties\n    }) || this;\n    _this.sourceId = options.source;\n    _this.layers = options.layers;\n    _this.accessToken = options.accessToken;\n\n    _this.fetchStyle(options.styleUrl);\n\n    return _this;\n  }\n  /**\n   * Fetch the style object.\n   * @param {string} styleUrl The URL of the style to load.\n   * @protected\n   */\n\n\n  MapboxVectorLayer.prototype.fetchStyle = function (styleUrl) {\n    var _this = this;\n\n    var url = normalizeStyleUrl(styleUrl, this.accessToken);\n    fetch(url).then(function (response) {\n      if (!response.ok) {\n        throw new Error(\"unexpected response when fetching style: \" + response.status);\n      }\n\n      return response.json();\n    }).then(function (style) {\n      _this.onStyleLoad(style);\n    }).catch(function (error) {\n      _this.handleError(error);\n    });\n  };\n  /**\n   * Handle the loaded style object.\n   * @param {StyleObject} style The loaded style.\n   * @protected\n   */\n\n\n  MapboxVectorLayer.prototype.onStyleLoad = function (style) {\n    var _this = this;\n\n    var sourceId;\n    var sourceIdOrLayersList;\n\n    if (this.layers) {\n      // confirm all layers share the same source\n      var lookup = {};\n\n      for (var i = 0; i < style.layers.length; ++i) {\n        var layer = style.layers[i];\n\n        if (layer.source) {\n          lookup[layer.id] = layer.source;\n        }\n      }\n\n      var firstSource = void 0;\n\n      for (var i = 0; i < this.layers.length; ++i) {\n        var candidate = lookup[this.layers[i]];\n\n        if (!candidate) {\n          this.handleError(new Error(\"could not find source for \" + this.layers[i]));\n          return;\n        }\n\n        if (!firstSource) {\n          firstSource = candidate;\n        } else if (firstSource !== candidate) {\n          this.handleError(new Error(\"layers can only use a single source, found \" + firstSource + \" and \" + candidate));\n          return;\n        }\n      }\n\n      sourceId = firstSource;\n      sourceIdOrLayersList = this.layers;\n    } else {\n      sourceId = this.sourceId;\n      sourceIdOrLayersList = sourceId;\n    }\n\n    if (!sourceIdOrLayersList) {\n      // default to the first source in the style\n      sourceId = Object.keys(style.sources)[0];\n      sourceIdOrLayersList = sourceId;\n    }\n\n    if (style.sprite) {\n      style.sprite = normalizeSpriteUrl(style.sprite, this.accessToken);\n    }\n\n    if (style.glyphs) {\n      style.glyphs = normalizeGlyphsUrl(style.glyphs, this.accessToken);\n    }\n\n    var styleSource = style.sources[sourceId];\n\n    if (styleSource.type !== SourceType.VECTOR) {\n      this.handleError(new Error(\"only works for vector sources, found \" + styleSource.type));\n      return;\n    }\n\n    var source = this.getSource();\n\n    if (styleSource.url.startsWith('mapbox://') || styleSource.url.indexOf('{z}') !== -1) {\n      // Tile source url, handle it directly\n      source.setUrl(normalizeSourceUrl(styleSource.url, this.accessToken));\n      applyStyle(this, style, sourceIdOrLayersList).then(function () {\n        source.setState(SourceState.READY);\n      }).catch(function (error) {\n        _this.handleError(error);\n      });\n    } else {\n      // TileJSON url, let ol-mapbox-style handle it\n      setupVectorSource(styleSource, styleSource.url).then(function (source) {\n        applyStyle(_this, style, sourceIdOrLayersList).then(function () {\n          _this.setSource(source);\n        }).catch(function (error) {\n          _this.setSource(source);\n\n          _this.handleError(error);\n        });\n      });\n    }\n  };\n  /**\n   * Handle configuration or loading error.\n   * @param {Error} error The error.\n   * @protected\n   */\n\n\n  MapboxVectorLayer.prototype.handleError = function (error) {\n    this.dispatchEvent(new ErrorEvent(error));\n    var source = this.getSource();\n    source.setState(SourceState.ERROR);\n  };\n\n  return MapboxVectorLayer;\n}(VectorTileLayer);\n\nexport default MapboxVectorLayer;","map":{"version":3,"sources":["../src/layer/MapboxVector.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/layer/MapboxVector\n */\nimport BaseEvent from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport MVT from '../format/MVT.js';\nimport SourceState from '../source/State.js';\nimport VectorTileLayer from '../layer/VectorTile.js';\nimport VectorTileSource from '../source/VectorTile.js';\nimport { applyStyle, setupVectorSource } from 'ol-mapbox-style';\nvar mapboxBaseUrl = 'https://api.mapbox.com';\n/**\n * Gets the path from a mapbox:// URL.\n * @param {string} url The Mapbox URL.\n * @return {string} The path.\n * @private\n */\nexport function getMapboxPath(url) {\n    var startsWith = 'mapbox://';\n    if (url.indexOf(startsWith) !== 0) {\n        return '';\n    }\n    return url.slice(startsWith.length);\n}\n/**\n * Turns mapbox:// sprite URLs into resolvable URLs.\n * @param {string} url The sprite URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeSpriteUrl(url, token) {\n    var mapboxPath = getMapboxPath(url);\n    if (!mapboxPath) {\n        return url;\n    }\n    var startsWith = 'sprites/';\n    if (mapboxPath.indexOf(startsWith) !== 0) {\n        throw new Error(\"unexpected sprites url: \" + url);\n    }\n    var sprite = mapboxPath.slice(startsWith.length);\n    return mapboxBaseUrl + \"/styles/v1/\" + sprite + \"/sprite?access_token=\" + token;\n}\n/**\n * Turns mapbox:// glyphs URLs into resolvable URLs.\n * @param {string} url The glyphs URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeGlyphsUrl(url, token) {\n    var mapboxPath = getMapboxPath(url);\n    if (!mapboxPath) {\n        return url;\n    }\n    var startsWith = 'fonts/';\n    if (mapboxPath.indexOf(startsWith) !== 0) {\n        throw new Error(\"unexpected fonts url: \" + url);\n    }\n    var font = mapboxPath.slice(startsWith.length);\n    return mapboxBaseUrl + \"/fonts/v1/\" + font + \"/0-255.pbf?access_token=\" + token;\n}\n/**\n * Turns mapbox:// style URLs into resolvable URLs.\n * @param {string} url The style URL.\n * @param {string} token The access token.\n * @return {string} A resolvable URL.\n * @private\n */\nexport function normalizeStyleUrl(url, token) {\n    var mapboxPath = getMapboxPath(url);\n    if (!mapboxPath) {\n        return url;\n    }\n    var startsWith = 'styles/';\n    if (mapboxPath.indexOf(startsWith) !== 0) {\n        throw new Error(\"unexpected style url: \" + url);\n    }\n    var style = mapboxPath.slice(startsWith.length);\n    return mapboxBaseUrl + \"/styles/v1/\" + style + \"?&access_token=\" + token;\n}\n/**\n * Turns mapbox:// source URLs into vector tile URL templates.\n * @param {string} url The source URL.\n * @param {string} token The access token.\n * @return {string} A vector tile template.\n * @private\n */\nexport function normalizeSourceUrl(url, token) {\n    var mapboxPath = getMapboxPath(url);\n    if (!mapboxPath) {\n        return url;\n    }\n    return \"https://{a-d}.tiles.mapbox.com/v4/\" + mapboxPath + \"/{z}/{x}/{y}.vector.pbf?access_token=\" + token;\n}\n/**\n * @classdesc\n * Event emitted on configuration or loading error.\n */\nvar ErrorEvent = /** @class */ (function (_super) {\n    __extends(ErrorEvent, _super);\n    /**\n     * @param {Error} error error object.\n     */\n    function ErrorEvent(error) {\n        var _this = _super.call(this, EventType.ERROR) || this;\n        /**\n         * @type {Error}\n         */\n        _this.error = error;\n        return _this;\n    }\n    return ErrorEvent;\n}(BaseEvent));\n/**\n * @typedef {Object} StyleObject\n * @property {Object<string, SourceObject>} sources The style sources.\n * @property {string} sprite The sprite URL.\n * @property {string} glyphs The glyphs URL.\n * @property {Array<LayerObject>} layers The style layers.\n */\n/**\n * @typedef {Object} SourceObject\n * @property {string} url The source URL.\n * @property {SourceType} type The source type.\n */\n/**\n * The Mapbox source type.\n * @enum {string}\n */\nvar SourceType = {\n    VECTOR: 'vector',\n};\n/**\n * @typedef {Object} LayerObject\n * @property {string} id The layer id.\n * @property {string} source The source id.\n */\n/**\n * @typedef {Object} Options\n * @property {string} styleUrl The URL of the Mapbox style object to use for this layer.  For a\n * style created with Mapbox Studio and hosted on Mapbox, this will look like\n * 'mapbox://styles/you/your-style'.\n * @property {string} [accessToken] The access token for your Mapbox style. This has to be provided\n * for `mapbox://` style urls. For `https://` and other urls, access keys must be part of the style\n * url.\n * @property {string} [source] If your style uses more than one source, you need to use either the\n * `source` property or the `layers` property to limit rendering to a single vector source.  The\n * `source` property corresponds to the id of a vector source in your Mapbox style.\n * @property {Array<string>} [layers] Limit rendering to the list of included layers.  All layers\n * must share the same vector source.  If your style uses more than one source, you need to use\n * either the `source` property or the `layers` property to limit rendering to a single vector\n * source.\n * @property {boolean} [declutter=true] Declutter images and text. Decluttering is applied to all\n * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority\n * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.\n * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has\n * higher priority.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the\n * renderer when getting features from the vector tile for the rendering or hit-detection.\n * Recommended value: Vector tiles are usually generated with a buffer, so this value should match\n * the largest possible buffer of the used tiles. It should be at least the size of the largest\n * point symbol or line width.\n * @property {import(\"./VectorTileRenderType.js\").default|string} [renderMode='hybrid'] Render mode for vector tiles:\n *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom\n *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on\n *    rotated views.\n *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector\n *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of\n *    another layer with the same source).\n * @property {import(\"../PluggableMap.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../PluggableMap.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be\n * recreated during animations. This means that no vectors will be shown clipped, but the setting\n * will have a performance impact for large amounts of vector data. When set to `false`, batches\n * will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be\n * recreated during interactions. See also `updateWhileAnimating`.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n/**\n * @classdesc\n * A vector tile layer based on a Mapbox style that uses a single vector source.  Configure\n * the layer with the `styleUrl` and `accessToken` shown in Mapbox Studio's share panel.\n * If the style uses more than one source, use the `source` property to choose a single\n * vector source.  If you want to render a subset of the layers in the style, use the `layers`\n * property (all layers must share the same vector source).  See the constructor options for\n * more detail.\n *\n *     var map = new Map({\n *       view: new View({\n *         center: [0, 0],\n *         zoom: 1\n *       }),\n *       layers: [\n *         new MapboxVectorLayer({\n *           styleUrl: 'mapbox://styles/mapbox/bright-v9',\n *           accessToken: 'your-mapbox-access-token-here'\n *         })\n *       ],\n *       target: 'map'\n *     });\n *\n * On configuration or loading error, the layer will trigger an `'error'` event.  Listeners\n * will receive an object with an `error` property that can be used to diagnose the problem.\n *\n * @param {Options} options Options.\n * @extends {VectorTileLayer}\n * @fires module:ol/events/Event~BaseEvent#event:error\n * @api\n */\nvar MapboxVectorLayer = /** @class */ (function (_super) {\n    __extends(MapboxVectorLayer, _super);\n    /**\n     * @param {Options} options Layer options.  At a minimum, `styleUrl` and `accessToken`\n     * must be provided.\n     */\n    function MapboxVectorLayer(options) {\n        var _this = this;\n        var declutter = 'declutter' in options ? options.declutter : true;\n        var source = new VectorTileSource({\n            state: SourceState.LOADING,\n            format: new MVT(),\n        });\n        _this = _super.call(this, {\n            source: source,\n            declutter: declutter,\n            className: options.className,\n            opacity: options.opacity,\n            visible: options.visible,\n            zIndex: options.zIndex,\n            minResolution: options.minResolution,\n            maxResolution: options.maxResolution,\n            minZoom: options.minZoom,\n            maxZoom: options.maxZoom,\n            renderOrder: options.renderOrder,\n            renderBuffer: options.renderBuffer,\n            renderMode: options.renderMode,\n            map: options.map,\n            updateWhileAnimating: options.updateWhileAnimating,\n            updateWhileInteracting: options.updateWhileInteracting,\n            preload: options.preload,\n            useInterimTilesOnError: options.useInterimTilesOnError,\n            properties: options.properties,\n        }) || this;\n        _this.sourceId = options.source;\n        _this.layers = options.layers;\n        _this.accessToken = options.accessToken;\n        _this.fetchStyle(options.styleUrl);\n        return _this;\n    }\n    /**\n     * Fetch the style object.\n     * @param {string} styleUrl The URL of the style to load.\n     * @protected\n     */\n    MapboxVectorLayer.prototype.fetchStyle = function (styleUrl) {\n        var _this = this;\n        var url = normalizeStyleUrl(styleUrl, this.accessToken);\n        fetch(url)\n            .then(function (response) {\n            if (!response.ok) {\n                throw new Error(\"unexpected response when fetching style: \" + response.status);\n            }\n            return response.json();\n        })\n            .then(function (style) {\n            _this.onStyleLoad(style);\n        })\n            .catch(function (error) {\n            _this.handleError(error);\n        });\n    };\n    /**\n     * Handle the loaded style object.\n     * @param {StyleObject} style The loaded style.\n     * @protected\n     */\n    MapboxVectorLayer.prototype.onStyleLoad = function (style) {\n        var _this = this;\n        var sourceId;\n        var sourceIdOrLayersList;\n        if (this.layers) {\n            // confirm all layers share the same source\n            var lookup = {};\n            for (var i = 0; i < style.layers.length; ++i) {\n                var layer = style.layers[i];\n                if (layer.source) {\n                    lookup[layer.id] = layer.source;\n                }\n            }\n            var firstSource = void 0;\n            for (var i = 0; i < this.layers.length; ++i) {\n                var candidate = lookup[this.layers[i]];\n                if (!candidate) {\n                    this.handleError(new Error(\"could not find source for \" + this.layers[i]));\n                    return;\n                }\n                if (!firstSource) {\n                    firstSource = candidate;\n                }\n                else if (firstSource !== candidate) {\n                    this.handleError(new Error(\"layers can only use a single source, found \" + firstSource + \" and \" + candidate));\n                    return;\n                }\n            }\n            sourceId = firstSource;\n            sourceIdOrLayersList = this.layers;\n        }\n        else {\n            sourceId = this.sourceId;\n            sourceIdOrLayersList = sourceId;\n        }\n        if (!sourceIdOrLayersList) {\n            // default to the first source in the style\n            sourceId = Object.keys(style.sources)[0];\n            sourceIdOrLayersList = sourceId;\n        }\n        if (style.sprite) {\n            style.sprite = normalizeSpriteUrl(style.sprite, this.accessToken);\n        }\n        if (style.glyphs) {\n            style.glyphs = normalizeGlyphsUrl(style.glyphs, this.accessToken);\n        }\n        var styleSource = style.sources[sourceId];\n        if (styleSource.type !== SourceType.VECTOR) {\n            this.handleError(new Error(\"only works for vector sources, found \" + styleSource.type));\n            return;\n        }\n        var source = this.getSource();\n        if (styleSource.url.startsWith('mapbox://') ||\n            styleSource.url.indexOf('{z}') !== -1) {\n            // Tile source url, handle it directly\n            source.setUrl(normalizeSourceUrl(styleSource.url, this.accessToken));\n            applyStyle(this, style, sourceIdOrLayersList)\n                .then(function () {\n                source.setState(SourceState.READY);\n            })\n                .catch(function (error) {\n                _this.handleError(error);\n            });\n        }\n        else {\n            // TileJSON url, let ol-mapbox-style handle it\n            setupVectorSource(styleSource, styleSource.url).then(function (source) {\n                applyStyle(_this, style, sourceIdOrLayersList)\n                    .then(function () {\n                    _this.setSource(source);\n                })\n                    .catch(function (error) {\n                    _this.setSource(source);\n                    _this.handleError(error);\n                });\n            });\n        }\n    };\n    /**\n     * Handle configuration or loading error.\n     * @param {Error} error The error.\n     * @protected\n     */\n    MapboxVectorLayer.prototype.handleError = function (error) {\n        this.dispatchEvent(new ErrorEvent(error));\n        var source = this.getSource();\n        source.setState(SourceState.ERROR);\n    };\n    return MapboxVectorLayer;\n}(VectorTileLayer));\nexport default MapboxVectorLayer;\n//# sourceMappingURL=MapboxVector.js.map"]},"metadata":{},"sourceType":"module"}
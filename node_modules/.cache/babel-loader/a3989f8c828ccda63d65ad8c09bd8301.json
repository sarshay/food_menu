{"ast":null,"code":"/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport GeoJSON from 'ol/format/GeoJSON.js';\nimport MVT from 'ol/format/MVT.js';\nimport Map from 'ol/Map.js';\nimport TileGrid from 'ol/tilegrid/TileGrid.js';\nimport TileJSON from 'ol/source/TileJSON.js';\nimport TileLayer from 'ol/layer/Tile.js';\nimport VectorLayer from 'ol/layer/Vector.js';\nimport VectorSource from 'ol/source/Vector.js';\nimport VectorTileLayer from 'ol/layer/VectorTile.js';\nimport VectorTileSource from 'ol/source/VectorTile.js';\nimport View from 'ol/View.js';\nimport applyStyleFunction, { getValue } from './stylefunction.js';\nimport googleFonts from 'webfont-matcher/lib/fonts/google.js';\nimport mb2css from 'mapbox-to-css-font';\nimport { Color } from '@mapbox/mapbox-gl-style-spec';\nimport { assign, defaultResolutions } from './util.js';\nimport { createXYZ } from 'ol/tilegrid.js';\nimport { fromLonLat } from 'ol/proj.js';\nimport { unByKey } from 'ol/Observable.js';\n/**\n * @typedef {import(\"ol/Map\").default} PluggableMap\n * @typedef {import(\"ol/layer/Layer\").default} Layer\n * @typedef {import(\"ol/source/Source\").default} Source\n * @private\n */\n\nvar tilejsonCache = {};\nvar fontFamilyRegEx = /font-family: ?([^;]*);/;\nvar stripQuotesRegEx = /(\"|')/g;\nvar loadedFontFamilies;\n\nfunction hasFontFamily(family) {\n  if (!loadedFontFamilies) {\n    loadedFontFamilies = {};\n    var styleSheets = document.styleSheets;\n\n    for (var i = 0, ii = styleSheets.length; i < ii; ++i) {\n      var styleSheet =\n      /** @type {CSSStyleSheet} */\n      styleSheets[i];\n\n      try {\n        var cssRules = styleSheet.rules || styleSheet.cssRules;\n\n        if (cssRules) {\n          for (var j = 0, jj = cssRules.length; j < jj; ++j) {\n            var cssRule = cssRules[j];\n\n            if (cssRule.type == 5) {\n              var match = cssRule.cssText.match(fontFamilyRegEx);\n              loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;\n            }\n          }\n        }\n      } catch (e) {// empty catch block\n      }\n    }\n  }\n\n  return family in loadedFontFamilies;\n}\n\nvar processedFontFamilies = {};\nvar googleFamilies = googleFonts.getNames();\n/**\n * @private\n * @param {Array} fonts Fonts.\n * @return {Array} Processed fonts.\n */\n\nfunction getFonts(fonts) {\n  var fontsKey = fonts.toString();\n\n  if (fontsKey in processedFontFamilies) {\n    return fonts;\n  }\n\n  var googleFontDescriptions = fonts.map(function (font) {\n    var parts = mb2css(font, 1).split(' ');\n    return [parts.slice(3).join(' ').replace(/\"/g, ''), parts[1] + parts[0]];\n  });\n\n  for (var i = 0, ii = googleFontDescriptions.length; i < ii; ++i) {\n    var googleFontDescription = googleFontDescriptions[i];\n    var family = googleFontDescription[0];\n\n    if (!hasFontFamily(family) && googleFamilies.indexOf(family) !== -1) {\n      var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+') + ':' + googleFontDescription[1];\n\n      if (!document.querySelector('link[href=\"' + fontUrl + '\"]')) {\n        var markup = document.createElement('link');\n        markup.href = fontUrl;\n        markup.rel = 'stylesheet';\n        document.head.appendChild(markup);\n      }\n    }\n  }\n\n  processedFontFamilies[fontsKey] = true;\n  return fonts;\n}\n\nvar spriteRegEx = /^(.*)(\\?.*)$/;\n\nfunction withPath(url, path) {\n  if (path && url.indexOf('.') === 0) {\n    url = path + url;\n  }\n\n  return url;\n}\n\nfunction toSpriteUrl(url, path, extension) {\n  url = withPath(url, path);\n  var parts = url.match(spriteRegEx);\n  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;\n}\n/**\n * ```js\n * import {applyStyle} from 'ol-mapbox-style';\n * ```\n *\n * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`\n * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function\n * will render all layers from the `glStyle` object that use the specified\n * `source`, or a subset of layers from the same source. The source needs to be\n * a `\"type\": \"vector\"` or `\"type\": \"geojson\"` source.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s from the\n * Mapbox Style object. When a `source` key is provided, all layers for the\n * specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {string} [path=undefined] Path of the style file. Only required when\n * a relative path is used with the `\"sprite\"` property of the style.\n * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.\n * @return {Promise} Promise which will be resolved when the style can be used\n * for rendering.\n */\n\n\nexport function applyStyle(layer, glStyle, source, path, resolutions) {\n  return new Promise(function (resolve, reject) {\n    // TODO: figure out where best place to check source type is\n    // Note that the source arg is an array of gl layer ids and each must be\n    // dereferenced to get source type to validate\n    if (typeof glStyle != 'object') {\n      glStyle = JSON.parse(glStyle);\n    }\n\n    if (glStyle.version != 8) {\n      return reject(new Error('glStyle version 8 required.'));\n    }\n\n    if (!(layer instanceof VectorLayer || layer instanceof VectorTileLayer)) {\n      return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));\n    }\n\n    var spriteScale, spriteData, spriteImageUrl, style;\n\n    function onChange() {\n      if (!style && (!glStyle.sprite || spriteData)) {\n        style = applyStyleFunction(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts);\n\n        if (!layer.getStyle()) {\n          reject(new Error(\"Nothing to show for source [\" + source + \"]\"));\n        } else {\n          resolve();\n        }\n      } else if (style) {\n        layer.setStyle(style);\n        resolve();\n      } else {\n        reject(new Error('Something went wrong trying to apply style.'));\n      }\n    }\n\n    if (glStyle.sprite) {\n      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;\n      var sizeFactor_1 = spriteScale == 0.5 ? '@2x' : '';\n      var spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.json');\n      fetch(spriteUrl_1, {\n        credentials: 'same-origin'\n      }).then(function (response) {\n        if (!response.ok && sizeFactor_1 !== '') {\n          spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, '.json');\n          return fetch(spriteUrl_1, {\n            credentials: 'same-origin'\n          });\n        } else {\n          return response;\n        }\n      }).then(function (response) {\n        if (response.ok) {\n          return response.json();\n        } else {\n          reject(new Error(\"Problem fetching sprite from \" + spriteUrl_1 + \": \" + response.statusText));\n        }\n      }).then(function (spritesJson) {\n        if (spritesJson === undefined) {\n          return reject(new Error('No sprites found.'));\n        }\n\n        spriteData = spritesJson;\n        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.png');\n        onChange();\n      }).catch(function (err) {\n        reject(new Error(\"Sprites cannot be loaded: \" + spriteUrl_1 + \": \" + err.message));\n      });\n    } else {\n      onChange();\n    }\n  });\n}\nvar emptyObj = {};\n\nfunction setBackground(map, layer) {\n  var background = {\n    type: layer.type\n  };\n\n  function updateStyle() {\n    var element = map.getTargetElement();\n\n    if (!element) {\n      return;\n    }\n\n    var layout = layer.layout || {};\n    var paint = layer.paint || {};\n    background['paint'] = paint;\n    background.id = 'olms-bg-' + paint['background-opacity'] + paint['background-color'];\n    var zoom = map.getView().getZoom();\n\n    if (paint['background-color'] !== undefined) {\n      var bg = getValue(background, 'paint', 'background-color', zoom, emptyObj);\n      element.style.background = Color.parse(bg).toString();\n    }\n\n    if (paint['background-opacity'] !== undefined) {\n      element.style.opacity = getValue(background, 'paint', 'background-opacity', zoom, emptyObj);\n    }\n\n    if (layout.visibility == 'none') {\n      element.style.backgroundColor = '';\n      element.style.opacity = '';\n    }\n  }\n\n  if (map.getTargetElement()) {\n    updateStyle();\n  }\n\n  map.on(['change:resolution', 'change:target'], updateStyle);\n}\n/**\n * ```js\n * import {applyBackground} from 'ol-mapbox-style';\n * ```\n * Applies properties of the Mapbox Style's first `background` layer to the map.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {Object} glStyle Mapbox Style object.\n */\n\n\nexport function applyBackground(map, glStyle) {\n  glStyle.layers.some(function (l) {\n    if (l.type == 'background') {\n      setBackground(map, l);\n      return true;\n    }\n  });\n}\n\nfunction getSourceIdByRef(layers, ref) {\n  var sourceId;\n  layers.some(function (layer) {\n    if (layer.id == ref) {\n      sourceId = layer.source;\n      return true;\n    }\n  });\n  return sourceId;\n}\n\nfunction extentFromTileJSON(tileJSON) {\n  var bounds = tileJSON.bounds;\n\n  if (bounds) {\n    var ll = fromLonLat([bounds[0], bounds[1]]);\n    var tr = fromLonLat([bounds[2], bounds[3]]);\n    return [ll[0], ll[1], tr[0], tr[1]];\n  }\n}\n/**\n * Creates an OpenLayers VectorTile source for a gl source entry.\n * @param {Object} glSource \"source\" entry from a Mapbox Style object.\n * @param {string} url URL to use for the source. This is expected to be the complete http(s) url,\n * with access key applied.\n * @return {Promise<import(\"ol/source/VectorTile\").default>} Promise resolving to a VectorTile source.\n * @private\n */\n\n\nexport function setupVectorSource(glSource, url) {\n  glSource = assign({}, glSource);\n  var cacheKey = JSON.stringify(glSource);\n  var tilejson = tilejsonCache[cacheKey];\n\n  if (!tilejson) {\n    tilejson = new TileJSON({\n      url: glSource.tiles ? undefined : url,\n      tileJSON: glSource.tiles ? glSource : undefined\n    });\n    tilejsonCache[cacheKey] = tilejson;\n  }\n\n  return new Promise(function (resolve) {\n    var key = tilejson.on('change', function () {\n      var state = tilejson.getState();\n\n      if (state === 'ready') {\n        var tileJSONDoc = tilejson.getTileJSON();\n        var tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];\n\n        if (url) {\n          for (var i = 0, ii = tiles.length; i < ii; ++i) {\n            var tile = tiles[i];\n\n            if (tile.indexOf('http') != 0) {\n              tiles[i] = url.replace(/\\/?$/, '/') + tile.replace(/^\\//, '');\n            }\n          }\n        }\n\n        var tileGrid = tilejson.getTileGrid();\n        var extent = extentFromTileJSON(tileJSONDoc);\n        var minZoom = tileJSONDoc.minzoom || 0;\n        var maxZoom = tileJSONDoc.maxzoom || 22;\n        var source = tilejson.get('ol-source');\n\n        if (source === undefined) {\n          source = new VectorTileSource({\n            attributions: tilejson.getAttributions(),\n            format: new MVT(),\n            tileGrid: new TileGrid({\n              origin: tileGrid.getOrigin(0),\n              extent: extent || tileGrid.getExtent(),\n              minZoom: minZoom,\n              resolutions: defaultResolutions.slice(0, maxZoom + 1),\n              tileSize: 512\n            }),\n            urls: tiles\n          });\n          tilejson.set('ol-source', source);\n        }\n\n        unByKey(key);\n        resolve(source);\n      } else if (state === 'error') {\n        tilejson.set('ol-source', null);\n        unByKey(key);\n        resolve(undefined);\n      }\n    });\n\n    if (tilejson.getState() === 'ready') {\n      tilejson.changed();\n    }\n  });\n}\n\nfunction setupVectorLayer(glSource, url) {\n  var layer = new VectorTileLayer({\n    declutter: true,\n    visible: false\n  });\n  setupVectorSource(glSource, url).then(function (source) {\n    layer.setSource(source);\n  });\n  return layer;\n}\n\nfunction setupRasterLayer(glSource, url) {\n  var layer = new TileLayer();\n  var source = new TileJSON({\n    transition: 0,\n    url: glSource.tiles ? undefined : url,\n    tileJSON: glSource.tiles ? glSource : undefined,\n    crossOrigin: 'anonymous'\n  });\n  var key = source.on('change', function () {\n    var state = source.getState();\n\n    if (state === 'ready') {\n      unByKey(key);\n      var tileJSONDoc =\n      /** @type {Object} */\n      source.getTileJSON();\n      var extent = extentFromTileJSON(tileJSONDoc);\n      var tileGrid = source.getTileGrid();\n      var tileSize = glSource.tileSize || tileJSONDoc.tileSize || 512;\n      var minZoom = tileJSONDoc.minzoom || 0;\n      var maxZoom = tileJSONDoc.maxzoom || 22; // Only works when using ES modules\n      //@ts-ignore\n\n      source.tileGrid = new TileGrid({\n        origin: tileGrid.getOrigin(0),\n        extent: extent || tileGrid.getExtent(),\n        minZoom: minZoom,\n        resolutions: createXYZ({\n          maxZoom: maxZoom,\n          tileSize: tileSize\n        }).getResolutions(),\n        tileSize: tileSize\n      });\n      layer.setSource(source);\n    } else if (state === 'error') {\n      unByKey(key);\n      layer.setSource(undefined);\n    }\n  });\n  source.setTileLoadFunction(function (tile, src) {\n    if (src.indexOf('{bbox-epsg-3857}') != -1) {\n      var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());\n      src = src.replace('{bbox-epsg-3857}', bbox.toString());\n    }\n\n    var img =\n    /** @type {import(\"ol/ImageTile\").default} */\n    tile.getImage();\n    /** @type {HTMLImageElement} */\n\n    img.src = src;\n  });\n  return layer;\n}\n\nvar geoJsonFormat = new GeoJSON();\n\nfunction setupGeoJSONLayer(glSource, path) {\n  var data = glSource.data;\n  var features, geoJsonUrl;\n\n  if (typeof data == 'string') {\n    geoJsonUrl = withPath(data, path);\n  } else {\n    features = geoJsonFormat.readFeatures(data, {\n      featureProjection: 'EPSG:3857'\n    });\n  }\n\n  return new VectorLayer({\n    source: new VectorSource({\n      attributions: glSource.attribution,\n      features: features,\n      format: geoJsonFormat,\n      url: geoJsonUrl\n    }),\n    visible: false\n  });\n}\n\nfunction updateRasterLayerProperties(glLayer, layer, view) {\n  var zoom = view.getZoom();\n  var opacity = getValue(glLayer, 'paint', 'raster-opacity', zoom, emptyObj);\n  layer.setOpacity(opacity);\n}\n\nfunction processStyle(glStyle, map, baseUrl, host, path, accessToken) {\n  if (accessToken === void 0) {\n    accessToken = '';\n  }\n\n  var promises = [];\n  var view = map.getView();\n\n  if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {\n    view = new View({\n      maxResolution: defaultResolutions[0]\n    });\n    map.setView(view);\n  }\n\n  if ('center' in glStyle && !view.getCenter()) {\n    view.setCenter(fromLonLat(glStyle.center));\n  }\n\n  if ('zoom' in glStyle && view.getZoom() === undefined) {\n    view.setResolution(defaultResolutions[0] / Math.pow(2, glStyle.zoom));\n  }\n\n  if (!view.getCenter() || view.getZoom() === undefined) {\n    view.fit(view.getProjection().getExtent(), {\n      nearest: true,\n      size: map.getSize()\n    });\n  }\n\n  if (glStyle.sprite) {\n    if (glStyle.sprite.indexOf('mapbox://') == 0) {\n      glStyle.sprite = baseUrl + '/sprite' + accessToken;\n    } else if (glStyle.sprite.indexOf('http') != 0) {\n      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;\n    }\n  }\n\n  var glLayers = glStyle.layers;\n  var layerIds = [];\n  var glLayer, glSource, glSourceId, id, layer, url;\n\n  var _loop_1 = function (i, ii) {\n    glLayer = glLayers[i];\n    var type = glLayer.type;\n\n    if (type == 'heatmap' || type == 'hillshade') {//FIXME Unsupported layer type\n    } else if (type == 'background') {\n      setBackground(map, glLayer);\n    } else {\n      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref); // this technique assumes gl layers will be in a particular order\n\n      if (id != glSourceId) {\n        if (layerIds.length) {\n          promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n          layerIds = [];\n        }\n\n        glSource = glStyle.sources[id];\n        url = glSource.url;\n\n        if (url) {\n          url = withPath(url, path);\n\n          if (url.indexOf('mapbox://') == 0) {\n            var mapid_1 = url.replace('mapbox://', '');\n            glSource.tiles = ['a', 'b', 'c', 'd'].map(function (host) {\n              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid_1 + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;\n            });\n          } else if (url.indexOf('/') === 0 && host.indexOf('http') === 0) {\n            url = host + url;\n          }\n        }\n\n        if (glSource.tiles) {\n          glSource.tiles = glSource.tiles.map(function (url) {\n            return withPath(url, path);\n          });\n        }\n\n        if (glSource.type == 'vector') {\n          layer = setupVectorLayer(glSource, url);\n        } else if (glSource.type == 'raster') {\n          layer = setupRasterLayer(glSource, url);\n          layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);\n          view.on('change:resolution', updateRasterLayerProperties.bind(this_1, glLayer, layer, view));\n          updateRasterLayerProperties(glLayer, layer, view);\n        } else if (glSource.type == 'geojson') {\n          layer = setupGeoJSONLayer(glSource, path);\n        }\n\n        glSourceId = id;\n\n        if (layer) {\n          layer.set('mapbox-source', glSourceId);\n        }\n      }\n\n      layerIds.push(glLayer.id);\n    }\n  };\n\n  var this_1 = this;\n\n  for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n    _loop_1(i, ii);\n  }\n\n  promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n  map.set('mapbox-style', glStyle);\n  return Promise.all(promises);\n}\n/**\n * ```js\n * import olms from 'ol-mapbox-style';\n * ```\n *\n * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes\n * the map background, the layers, the center and the zoom.\n *\n * The center and zoom will only be set if present in the Mapbox Style document,\n * and if not already set on the OpenLayers map.\n *\n * Layers will be added to the OpenLayers map, without affecting any layers that\n * might already be set on the map.\n *\n * Layers added by `apply()` will have two additional properties:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function sets an additional `mapbox-style` property on the OpenLayers\n * map instance, which holds the Mapbox Style object.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {Promise} A promise that resolves after all layers have been added to\n * the OpenLayers Map instance, their sources set, and their styles applied. the\n * `resolve` callback will be called with the OpenLayers Map instance as\n * argument.\n */\n\n\nexport default function olms(map, style) {\n  var promise,\n      accessToken = '',\n      baseUrl = '',\n      host = '',\n      path = '';\n\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n\n  if (typeof style === 'string') {\n    var parts = style.match(spriteRegEx);\n\n    if (parts) {\n      baseUrl = parts[1];\n      accessToken = parts.length > 2 ? parts[2] : '';\n    }\n\n    promise = new Promise(function (resolve, reject) {\n      fetch(style, {\n        credentials: 'same-origin'\n      }).then(function (response) {\n        return response.json();\n      }).then(function (glStyle) {\n        var a =\n        /** @type {HTMLAnchorElement} */\n        document.createElement('A');\n        a.href = style;\n        var href = a.href;\n        path = a.pathname.split('/').slice(0, -1).join('/') + '/';\n        host = href.substr(0, href.indexOf(path));\n        processStyle(glStyle, map, baseUrl, host, path, accessToken).then(function () {\n          resolve(map);\n        }).catch(reject);\n      }).catch(function (err) {\n        reject(new Error(\"Could not load \" + style + \": \" + err.message));\n      });\n    });\n  } else {\n    promise = new Promise(function (resolve, reject) {\n      processStyle(style, map).then(function () {\n        resolve(map);\n      }).catch(reject);\n    });\n  }\n\n  return promise;\n}\n/**\n * ```js\n * import {apply} from 'ol-mapbox-style';\n * ```\n * Like `olms`, but returns an `ol/Map` instance instead of a `Promise`.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {PluggableMap} The OpenLayers Map instance that will be populated with the\n * contents described in the Mapbox Style object.\n */\n\nexport function apply(map, style) {\n  if (typeof map === 'string' || map instanceof HTMLElement) {\n    map = new Map({\n      target: map\n    });\n  }\n\n  setTimeout(function () {\n    olms(map, style);\n  }, 0);\n  return map;\n}\n/**\n * If layerIds is not empty, applies the style specified in glStyle to the layer,\n * and adds the layer to the map.\n *\n * The layer may not yet have a source when the function is called.  If so, the style\n * is applied to the layer via a once listener on the 'change:source' event.\n *\n * @param {Layer} layer An OpenLayers layer instance.\n * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.\n * @param {Object} glStyle Style as a JSON object.\n * @param {string|undefined} path The path part of the style URL. Only required\n * when a relative path is used with the `\"sprite\"` property of the style.\n * @param {PluggableMap} map OpenLayers Map.\n * @return {Promise} Returns a promise that resolves after the source has\n * been set on the specified layer, and the style has been applied.\n * @private\n */\n\nfunction finalizeLayer(layer, layerIds, glStyle, path, map) {\n  var minZoom = 24;\n  var maxZoom = 0;\n  var glLayers = glStyle.layers;\n\n  for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n    var glLayer = glLayers[i];\n\n    if (layerIds.indexOf(glLayer.id) !== -1) {\n      minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);\n      maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);\n    }\n  }\n\n  return new Promise(function (resolve, reject) {\n    var setStyle = function () {\n      var source = layer.getSource();\n\n      if (!source || source.getState() === 'error') {\n        reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));\n        return;\n      }\n\n      if (typeof source.getTileGrid === 'function') {\n        var tileGrid = source.getTileGrid();\n\n        if (tileGrid) {\n          var sourceMinZoom = tileGrid.getMinZoom();\n\n          if (minZoom > 0 || sourceMinZoom > 0) {\n            layer.setMaxResolution(Math.min(defaultResolutions[minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);\n          }\n\n          if (maxZoom < 24) {\n            layer.setMinResolution(defaultResolutions[maxZoom] + 1e-9);\n          }\n        }\n      }\n\n      if (source instanceof VectorSource || source instanceof VectorTileSource) {\n        applyStyle(\n        /** @type {import(\"ol/layer/Vector\").default|import(\"ol/layer/VectorTile\").default} */\n        layer, glStyle, layerIds, path).then(function () {\n          layer.setVisible(true);\n          resolve();\n        }, function (e) {\n          reject(e);\n        });\n      } else {\n        resolve();\n      }\n    };\n\n    layer.set('mapbox-layers', layerIds);\n\n    if (map.getLayers().getArray().indexOf(layer) === -1) {\n      map.addLayer(layer);\n    }\n\n    if (layer.getSource()) {\n      setStyle();\n    } else {\n      layer.once('change:source', setStyle);\n    }\n  });\n}\n/**\n * ```js\n * import {getLayer} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instance that contains the provided Mapbox Style\n * `layer`. Note that multiple Mapbox Style layers are combined in a single\n * OpenLayers layer instance when they use the same Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} layerId Mapbox Style layer id.\n * @return {Layer} OpenLayers layer instance.\n */\n\n\nexport function getLayer(map, layerId) {\n  var layers = map.getLayers().getArray();\n\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var mapboxLayers = layers[i].get('mapbox-layers');\n\n    if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {\n      return (\n        /** @type {Layer} */\n        layers[i]\n      );\n    }\n  }\n}\n/**\n * ```js\n * import {getLayers} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instances for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Array<Layer>} OpenLayers layer instances.\n */\n\nexport function getLayers(map, sourceId) {\n  var result = [];\n  var layers = map.getLayers().getArray();\n\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    if (layers[i].get('mapbox-source') === sourceId) {\n      result.push(\n      /** @type {Layer} */\n      layers[i]);\n    }\n  }\n\n  return result;\n}\n/**\n * ```js\n * import {getSource} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers source instance for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Source} OpenLayers source instance.\n */\n\nexport function getSource(map, sourceId) {\n  var layers = map.getLayers().getArray();\n\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var source =\n    /** @type {Layer} */\n    layers[i].getSource();\n\n    if (layers[i].get('mapbox-source') === sourceId) {\n      return source;\n    }\n  }\n}\nexport { finalizeLayer as _finalizeLayer, getFonts as _getFonts };","map":{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport GeoJSON from 'ol/format/GeoJSON.js';\nimport MVT from 'ol/format/MVT.js';\nimport Map from 'ol/Map.js';\nimport TileGrid from 'ol/tilegrid/TileGrid.js';\nimport TileJSON from 'ol/source/TileJSON.js';\nimport TileLayer from 'ol/layer/Tile.js';\nimport VectorLayer from 'ol/layer/Vector.js';\nimport VectorSource from 'ol/source/Vector.js';\nimport VectorTileLayer from 'ol/layer/VectorTile.js';\nimport VectorTileSource from 'ol/source/VectorTile.js';\nimport View from 'ol/View.js';\nimport applyStyleFunction, { getValue } from './stylefunction.js';\nimport googleFonts from 'webfont-matcher/lib/fonts/google.js';\nimport mb2css from 'mapbox-to-css-font';\nimport { Color } from '@mapbox/mapbox-gl-style-spec';\nimport { assign, defaultResolutions } from './util.js';\nimport { createXYZ } from 'ol/tilegrid.js';\nimport { fromLonLat } from 'ol/proj.js';\nimport { unByKey } from 'ol/Observable.js';\n/**\n * @typedef {import(\"ol/Map\").default} PluggableMap\n * @typedef {import(\"ol/layer/Layer\").default} Layer\n * @typedef {import(\"ol/source/Source\").default} Source\n * @private\n */\nvar tilejsonCache = {};\nvar fontFamilyRegEx = /font-family: ?([^;]*);/;\nvar stripQuotesRegEx = /(\"|')/g;\nvar loadedFontFamilies;\nfunction hasFontFamily(family) {\n    if (!loadedFontFamilies) {\n        loadedFontFamilies = {};\n        var styleSheets = document.styleSheets;\n        for (var i = 0, ii = styleSheets.length; i < ii; ++i) {\n            var styleSheet = /** @type {CSSStyleSheet} */ (styleSheets[i]);\n            try {\n                var cssRules = styleSheet.rules || styleSheet.cssRules;\n                if (cssRules) {\n                    for (var j = 0, jj = cssRules.length; j < jj; ++j) {\n                        var cssRule = cssRules[j];\n                        if (cssRule.type == 5) {\n                            var match = cssRule.cssText.match(fontFamilyRegEx);\n                            loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;\n                        }\n                    }\n                }\n            }\n            catch (e) {\n                // empty catch block\n            }\n        }\n    }\n    return family in loadedFontFamilies;\n}\nvar processedFontFamilies = {};\nvar googleFamilies = googleFonts.getNames();\n/**\n * @private\n * @param {Array} fonts Fonts.\n * @return {Array} Processed fonts.\n */\nfunction getFonts(fonts) {\n    var fontsKey = fonts.toString();\n    if (fontsKey in processedFontFamilies) {\n        return fonts;\n    }\n    var googleFontDescriptions = fonts.map(function (font) {\n        var parts = mb2css(font, 1).split(' ');\n        return [parts.slice(3).join(' ').replace(/\"/g, ''), parts[1] + parts[0]];\n    });\n    for (var i = 0, ii = googleFontDescriptions.length; i < ii; ++i) {\n        var googleFontDescription = googleFontDescriptions[i];\n        var family = googleFontDescription[0];\n        if (!hasFontFamily(family) && googleFamilies.indexOf(family) !== -1) {\n            var fontUrl = 'https://fonts.googleapis.com/css?family=' +\n                family.replace(/ /g, '+') +\n                ':' +\n                googleFontDescription[1];\n            if (!document.querySelector('link[href=\"' + fontUrl + '\"]')) {\n                var markup = document.createElement('link');\n                markup.href = fontUrl;\n                markup.rel = 'stylesheet';\n                document.head.appendChild(markup);\n            }\n        }\n    }\n    processedFontFamilies[fontsKey] = true;\n    return fonts;\n}\nvar spriteRegEx = /^(.*)(\\?.*)$/;\nfunction withPath(url, path) {\n    if (path && url.indexOf('.') === 0) {\n        url = path + url;\n    }\n    return url;\n}\nfunction toSpriteUrl(url, path, extension) {\n    url = withPath(url, path);\n    var parts = url.match(spriteRegEx);\n    return parts\n        ? parts[1] + extension + (parts.length > 2 ? parts[2] : '')\n        : url + extension;\n}\n/**\n * ```js\n * import {applyStyle} from 'ol-mapbox-style';\n * ```\n *\n * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`\n * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function\n * will render all layers from the `glStyle` object that use the specified\n * `source`, or a subset of layers from the same source. The source needs to be\n * a `\"type\": \"vector\"` or `\"type\": \"geojson\"` source.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s from the\n * Mapbox Style object. When a `source` key is provided, all layers for the\n * specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {string} [path=undefined] Path of the style file. Only required when\n * a relative path is used with the `\"sprite\"` property of the style.\n * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.\n * @return {Promise} Promise which will be resolved when the style can be used\n * for rendering.\n */\nexport function applyStyle(layer, glStyle, source, path, resolutions) {\n    return new Promise(function (resolve, reject) {\n        // TODO: figure out where best place to check source type is\n        // Note that the source arg is an array of gl layer ids and each must be\n        // dereferenced to get source type to validate\n        if (typeof glStyle != 'object') {\n            glStyle = JSON.parse(glStyle);\n        }\n        if (glStyle.version != 8) {\n            return reject(new Error('glStyle version 8 required.'));\n        }\n        if (!(layer instanceof VectorLayer || layer instanceof VectorTileLayer)) {\n            return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));\n        }\n        var spriteScale, spriteData, spriteImageUrl, style;\n        function onChange() {\n            if (!style && (!glStyle.sprite || spriteData)) {\n                style = applyStyleFunction(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts);\n                if (!layer.getStyle()) {\n                    reject(new Error(\"Nothing to show for source [\" + source + \"]\"));\n                }\n                else {\n                    resolve();\n                }\n            }\n            else if (style) {\n                layer.setStyle(style);\n                resolve();\n            }\n            else {\n                reject(new Error('Something went wrong trying to apply style.'));\n            }\n        }\n        if (glStyle.sprite) {\n            spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;\n            var sizeFactor_1 = spriteScale == 0.5 ? '@2x' : '';\n            var spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.json');\n            fetch(spriteUrl_1, { credentials: 'same-origin' })\n                .then(function (response) {\n                if (!response.ok && sizeFactor_1 !== '') {\n                    spriteUrl_1 = toSpriteUrl(glStyle.sprite, path, '.json');\n                    return fetch(spriteUrl_1, { credentials: 'same-origin' });\n                }\n                else {\n                    return response;\n                }\n            })\n                .then(function (response) {\n                if (response.ok) {\n                    return response.json();\n                }\n                else {\n                    reject(new Error(\"Problem fetching sprite from \" + spriteUrl_1 + \": \" + response.statusText));\n                }\n            })\n                .then(function (spritesJson) {\n                if (spritesJson === undefined) {\n                    return reject(new Error('No sprites found.'));\n                }\n                spriteData = spritesJson;\n                spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor_1 + '.png');\n                onChange();\n            })\n                .catch(function (err) {\n                reject(new Error(\"Sprites cannot be loaded: \" + spriteUrl_1 + \": \" + err.message));\n            });\n        }\n        else {\n            onChange();\n        }\n    });\n}\nvar emptyObj = {};\nfunction setBackground(map, layer) {\n    var background = {\n        type: layer.type,\n    };\n    function updateStyle() {\n        var element = map.getTargetElement();\n        if (!element) {\n            return;\n        }\n        var layout = layer.layout || {};\n        var paint = layer.paint || {};\n        background['paint'] = paint;\n        background.id =\n            'olms-bg-' + paint['background-opacity'] + paint['background-color'];\n        var zoom = map.getView().getZoom();\n        if (paint['background-color'] !== undefined) {\n            var bg = getValue(background, 'paint', 'background-color', zoom, emptyObj);\n            element.style.background = Color.parse(bg).toString();\n        }\n        if (paint['background-opacity'] !== undefined) {\n            element.style.opacity = getValue(background, 'paint', 'background-opacity', zoom, emptyObj);\n        }\n        if (layout.visibility == 'none') {\n            element.style.backgroundColor = '';\n            element.style.opacity = '';\n        }\n    }\n    if (map.getTargetElement()) {\n        updateStyle();\n    }\n    map.on(['change:resolution', 'change:target'], updateStyle);\n}\n/**\n * ```js\n * import {applyBackground} from 'ol-mapbox-style';\n * ```\n * Applies properties of the Mapbox Style's first `background` layer to the map.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {Object} glStyle Mapbox Style object.\n */\nexport function applyBackground(map, glStyle) {\n    glStyle.layers.some(function (l) {\n        if (l.type == 'background') {\n            setBackground(map, l);\n            return true;\n        }\n    });\n}\nfunction getSourceIdByRef(layers, ref) {\n    var sourceId;\n    layers.some(function (layer) {\n        if (layer.id == ref) {\n            sourceId = layer.source;\n            return true;\n        }\n    });\n    return sourceId;\n}\nfunction extentFromTileJSON(tileJSON) {\n    var bounds = tileJSON.bounds;\n    if (bounds) {\n        var ll = fromLonLat([bounds[0], bounds[1]]);\n        var tr = fromLonLat([bounds[2], bounds[3]]);\n        return [ll[0], ll[1], tr[0], tr[1]];\n    }\n}\n/**\n * Creates an OpenLayers VectorTile source for a gl source entry.\n * @param {Object} glSource \"source\" entry from a Mapbox Style object.\n * @param {string} url URL to use for the source. This is expected to be the complete http(s) url,\n * with access key applied.\n * @return {Promise<import(\"ol/source/VectorTile\").default>} Promise resolving to a VectorTile source.\n * @private\n */\nexport function setupVectorSource(glSource, url) {\n    glSource = assign({}, glSource);\n    var cacheKey = JSON.stringify(glSource);\n    var tilejson = tilejsonCache[cacheKey];\n    if (!tilejson) {\n        tilejson = new TileJSON({\n            url: glSource.tiles ? undefined : url,\n            tileJSON: glSource.tiles ? glSource : undefined,\n        });\n        tilejsonCache[cacheKey] = tilejson;\n    }\n    return new Promise(function (resolve) {\n        var key = tilejson.on('change', function () {\n            var state = tilejson.getState();\n            if (state === 'ready') {\n                var tileJSONDoc = tilejson.getTileJSON();\n                var tiles = Array.isArray(tileJSONDoc.tiles)\n                    ? tileJSONDoc.tiles\n                    : [tileJSONDoc.tiles];\n                if (url) {\n                    for (var i = 0, ii = tiles.length; i < ii; ++i) {\n                        var tile = tiles[i];\n                        if (tile.indexOf('http') != 0) {\n                            tiles[i] = url.replace(/\\/?$/, '/') + tile.replace(/^\\//, '');\n                        }\n                    }\n                }\n                var tileGrid = tilejson.getTileGrid();\n                var extent = extentFromTileJSON(tileJSONDoc);\n                var minZoom = tileJSONDoc.minzoom || 0;\n                var maxZoom = tileJSONDoc.maxzoom || 22;\n                var source = tilejson.get('ol-source');\n                if (source === undefined) {\n                    source = new VectorTileSource({\n                        attributions: tilejson.getAttributions(),\n                        format: new MVT(),\n                        tileGrid: new TileGrid({\n                            origin: tileGrid.getOrigin(0),\n                            extent: extent || tileGrid.getExtent(),\n                            minZoom: minZoom,\n                            resolutions: defaultResolutions.slice(0, maxZoom + 1),\n                            tileSize: 512,\n                        }),\n                        urls: tiles,\n                    });\n                    tilejson.set('ol-source', source);\n                }\n                unByKey(key);\n                resolve(source);\n            }\n            else if (state === 'error') {\n                tilejson.set('ol-source', null);\n                unByKey(key);\n                resolve(undefined);\n            }\n        });\n        if (tilejson.getState() === 'ready') {\n            tilejson.changed();\n        }\n    });\n}\nfunction setupVectorLayer(glSource, url) {\n    var layer = new VectorTileLayer({\n        declutter: true,\n        visible: false,\n    });\n    setupVectorSource(glSource, url).then(function (source) {\n        layer.setSource(source);\n    });\n    return layer;\n}\nfunction setupRasterLayer(glSource, url) {\n    var layer = new TileLayer();\n    var source = new TileJSON({\n        transition: 0,\n        url: glSource.tiles ? undefined : url,\n        tileJSON: glSource.tiles ? glSource : undefined,\n        crossOrigin: 'anonymous',\n    });\n    var key = source.on('change', function () {\n        var state = source.getState();\n        if (state === 'ready') {\n            unByKey(key);\n            var tileJSONDoc = /** @type {Object} */ (source.getTileJSON());\n            var extent = extentFromTileJSON(tileJSONDoc);\n            var tileGrid = source.getTileGrid();\n            var tileSize = glSource.tileSize || tileJSONDoc.tileSize || 512;\n            var minZoom = tileJSONDoc.minzoom || 0;\n            var maxZoom = tileJSONDoc.maxzoom || 22;\n            // Only works when using ES modules\n            //@ts-ignore\n            source.tileGrid = new TileGrid({\n                origin: tileGrid.getOrigin(0),\n                extent: extent || tileGrid.getExtent(),\n                minZoom: minZoom,\n                resolutions: createXYZ({\n                    maxZoom: maxZoom,\n                    tileSize: tileSize,\n                }).getResolutions(),\n                tileSize: tileSize,\n            });\n            layer.setSource(source);\n        }\n        else if (state === 'error') {\n            unByKey(key);\n            layer.setSource(undefined);\n        }\n    });\n    source.setTileLoadFunction(function (tile, src) {\n        if (src.indexOf('{bbox-epsg-3857}') != -1) {\n            var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());\n            src = src.replace('{bbox-epsg-3857}', bbox.toString());\n        }\n        var img = /** @type {import(\"ol/ImageTile\").default} */ (tile).getImage();\n        /** @type {HTMLImageElement} */ (img).src = src;\n    });\n    return layer;\n}\nvar geoJsonFormat = new GeoJSON();\nfunction setupGeoJSONLayer(glSource, path) {\n    var data = glSource.data;\n    var features, geoJsonUrl;\n    if (typeof data == 'string') {\n        geoJsonUrl = withPath(data, path);\n    }\n    else {\n        features = geoJsonFormat.readFeatures(data, {\n            featureProjection: 'EPSG:3857',\n        });\n    }\n    return new VectorLayer({\n        source: new VectorSource({\n            attributions: glSource.attribution,\n            features: features,\n            format: geoJsonFormat,\n            url: geoJsonUrl,\n        }),\n        visible: false,\n    });\n}\nfunction updateRasterLayerProperties(glLayer, layer, view) {\n    var zoom = view.getZoom();\n    var opacity = getValue(glLayer, 'paint', 'raster-opacity', zoom, emptyObj);\n    layer.setOpacity(opacity);\n}\nfunction processStyle(glStyle, map, baseUrl, host, path, accessToken) {\n    if (accessToken === void 0) { accessToken = ''; }\n    var promises = [];\n    var view = map.getView();\n    if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {\n        view = new View({\n            maxResolution: defaultResolutions[0],\n        });\n        map.setView(view);\n    }\n    if ('center' in glStyle && !view.getCenter()) {\n        view.setCenter(fromLonLat(glStyle.center));\n    }\n    if ('zoom' in glStyle && view.getZoom() === undefined) {\n        view.setResolution(defaultResolutions[0] / Math.pow(2, glStyle.zoom));\n    }\n    if (!view.getCenter() || view.getZoom() === undefined) {\n        view.fit(view.getProjection().getExtent(), {\n            nearest: true,\n            size: map.getSize(),\n        });\n    }\n    if (glStyle.sprite) {\n        if (glStyle.sprite.indexOf('mapbox://') == 0) {\n            glStyle.sprite = baseUrl + '/sprite' + accessToken;\n        }\n        else if (glStyle.sprite.indexOf('http') != 0) {\n            glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;\n        }\n    }\n    var glLayers = glStyle.layers;\n    var layerIds = [];\n    var glLayer, glSource, glSourceId, id, layer, url;\n    var _loop_1 = function (i, ii) {\n        glLayer = glLayers[i];\n        var type = glLayer.type;\n        if (type == 'heatmap' || type == 'hillshade') {\n            //FIXME Unsupported layer type\n        }\n        else if (type == 'background') {\n            setBackground(map, glLayer);\n        }\n        else {\n            id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);\n            // this technique assumes gl layers will be in a particular order\n            if (id != glSourceId) {\n                if (layerIds.length) {\n                    promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n                    layerIds = [];\n                }\n                glSource = glStyle.sources[id];\n                url = glSource.url;\n                if (url) {\n                    url = withPath(url, path);\n                    if (url.indexOf('mapbox://') == 0) {\n                        var mapid_1 = url.replace('mapbox://', '');\n                        glSource.tiles = ['a', 'b', 'c', 'd'].map(function (host) {\n                            return ('https://' +\n                                host +\n                                '.tiles.mapbox.com/v4/' +\n                                mapid_1 +\n                                '/{z}/{x}/{y}.' +\n                                (glSource.type == 'vector' ? 'vector.pbf' : 'png') +\n                                accessToken);\n                        });\n                    }\n                    else if (url.indexOf('/') === 0 && host.indexOf('http') === 0) {\n                        url = host + url;\n                    }\n                }\n                if (glSource.tiles) {\n                    glSource.tiles = glSource.tiles.map(function (url) { return withPath(url, path); });\n                }\n                if (glSource.type == 'vector') {\n                    layer = setupVectorLayer(glSource, url);\n                }\n                else if (glSource.type == 'raster') {\n                    layer = setupRasterLayer(glSource, url);\n                    layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);\n                    view.on('change:resolution', updateRasterLayerProperties.bind(this_1, glLayer, layer, view));\n                    updateRasterLayerProperties(glLayer, layer, view);\n                }\n                else if (glSource.type == 'geojson') {\n                    layer = setupGeoJSONLayer(glSource, path);\n                }\n                glSourceId = id;\n                if (layer) {\n                    layer.set('mapbox-source', glSourceId);\n                }\n            }\n            layerIds.push(glLayer.id);\n        }\n    };\n    var this_1 = this;\n    for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n        _loop_1(i, ii);\n    }\n    promises.push(finalizeLayer(layer, layerIds, glStyle, path, map));\n    map.set('mapbox-style', glStyle);\n    return Promise.all(promises);\n}\n/**\n * ```js\n * import olms from 'ol-mapbox-style';\n * ```\n *\n * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes\n * the map background, the layers, the center and the zoom.\n *\n * The center and zoom will only be set if present in the Mapbox Style document,\n * and if not already set on the OpenLayers map.\n *\n * Layers will be added to the OpenLayers map, without affecting any layers that\n * might already be set on the map.\n *\n * Layers added by `apply()` will have two additional properties:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function sets an additional `mapbox-style` property on the OpenLayers\n * map instance, which holds the Mapbox Style object.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {Promise} A promise that resolves after all layers have been added to\n * the OpenLayers Map instance, their sources set, and their styles applied. the\n * `resolve` callback will be called with the OpenLayers Map instance as\n * argument.\n */\nexport default function olms(map, style) {\n    var promise, accessToken = '', baseUrl = '', host = '', path = '';\n    if (typeof map === 'string' || map instanceof HTMLElement) {\n        map = new Map({\n            target: map,\n        });\n    }\n    if (typeof style === 'string') {\n        var parts = style.match(spriteRegEx);\n        if (parts) {\n            baseUrl = parts[1];\n            accessToken = parts.length > 2 ? parts[2] : '';\n        }\n        promise = new Promise(function (resolve, reject) {\n            fetch(style, {\n                credentials: 'same-origin',\n            })\n                .then(function (response) {\n                return response.json();\n            })\n                .then(function (glStyle) {\n                var a = /** @type {HTMLAnchorElement} */ (document.createElement('A'));\n                a.href = style;\n                var href = a.href;\n                path = a.pathname.split('/').slice(0, -1).join('/') + '/';\n                host = href.substr(0, href.indexOf(path));\n                processStyle(glStyle, map, baseUrl, host, path, accessToken)\n                    .then(function () {\n                    resolve(map);\n                })\n                    .catch(reject);\n            })\n                .catch(function (err) {\n                reject(new Error(\"Could not load \" + style + \": \" + err.message));\n            });\n        });\n    }\n    else {\n        promise = new Promise(function (resolve, reject) {\n            processStyle(style, map)\n                .then(function () {\n                resolve(map);\n            })\n                .catch(reject);\n        });\n    }\n    return promise;\n}\n/**\n * ```js\n * import {apply} from 'ol-mapbox-style';\n * ```\n * Like `olms`, but returns an `ol/Map` instance instead of a `Promise`.\n *\n * @param {PluggableMap|HTMLElement|string} map Either an existing OpenLayers Map\n * instance, or a HTML element, or the id of a HTML element that will be the\n * target of a new OpenLayers Map.\n * @param {string|Object} style JSON style object or style url pointing to a\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\n * token and look like\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\n * will be immediately available, but they may not have a source yet (i.e. when\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\n * as style url, layers will be added to the map when the Mapbox Style document\n * is loaded and parsed.\n * @return {PluggableMap} The OpenLayers Map instance that will be populated with the\n * contents described in the Mapbox Style object.\n */\nexport function apply(map, style) {\n    if (typeof map === 'string' || map instanceof HTMLElement) {\n        map = new Map({\n            target: map,\n        });\n    }\n    setTimeout(function () {\n        olms(map, style);\n    }, 0);\n    return map;\n}\n/**\n * If layerIds is not empty, applies the style specified in glStyle to the layer,\n * and adds the layer to the map.\n *\n * The layer may not yet have a source when the function is called.  If so, the style\n * is applied to the layer via a once listener on the 'change:source' event.\n *\n * @param {Layer} layer An OpenLayers layer instance.\n * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.\n * @param {Object} glStyle Style as a JSON object.\n * @param {string|undefined} path The path part of the style URL. Only required\n * when a relative path is used with the `\"sprite\"` property of the style.\n * @param {PluggableMap} map OpenLayers Map.\n * @return {Promise} Returns a promise that resolves after the source has\n * been set on the specified layer, and the style has been applied.\n * @private\n */\nfunction finalizeLayer(layer, layerIds, glStyle, path, map) {\n    var minZoom = 24;\n    var maxZoom = 0;\n    var glLayers = glStyle.layers;\n    for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n        var glLayer = glLayers[i];\n        if (layerIds.indexOf(glLayer.id) !== -1) {\n            minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);\n            maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);\n        }\n    }\n    return new Promise(function (resolve, reject) {\n        var setStyle = function () {\n            var source = layer.getSource();\n            if (!source || source.getState() === 'error') {\n                reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));\n                return;\n            }\n            if (typeof source.getTileGrid === 'function') {\n                var tileGrid = source.getTileGrid();\n                if (tileGrid) {\n                    var sourceMinZoom = tileGrid.getMinZoom();\n                    if (minZoom > 0 || sourceMinZoom > 0) {\n                        layer.setMaxResolution(Math.min(defaultResolutions[minZoom], tileGrid.getResolution(sourceMinZoom)) + 1e-9);\n                    }\n                    if (maxZoom < 24) {\n                        layer.setMinResolution(defaultResolutions[maxZoom] + 1e-9);\n                    }\n                }\n            }\n            if (source instanceof VectorSource ||\n                source instanceof VectorTileSource) {\n                applyStyle(\n                /** @type {import(\"ol/layer/Vector\").default|import(\"ol/layer/VectorTile\").default} */ (layer), glStyle, layerIds, path).then(function () {\n                    layer.setVisible(true);\n                    resolve();\n                }, function (e) {\n                    reject(e);\n                });\n            }\n            else {\n                resolve();\n            }\n        };\n        layer.set('mapbox-layers', layerIds);\n        if (map.getLayers().getArray().indexOf(layer) === -1) {\n            map.addLayer(layer);\n        }\n        if (layer.getSource()) {\n            setStyle();\n        }\n        else {\n            layer.once('change:source', setStyle);\n        }\n    });\n}\n/**\n * ```js\n * import {getLayer} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instance that contains the provided Mapbox Style\n * `layer`. Note that multiple Mapbox Style layers are combined in a single\n * OpenLayers layer instance when they use the same Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} layerId Mapbox Style layer id.\n * @return {Layer} OpenLayers layer instance.\n */\nexport function getLayer(map, layerId) {\n    var layers = map.getLayers().getArray();\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n        var mapboxLayers = layers[i].get('mapbox-layers');\n        if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {\n            return /** @type {Layer} */ (layers[i]);\n        }\n    }\n}\n/**\n * ```js\n * import {getLayers} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers layer instances for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Array<Layer>} OpenLayers layer instances.\n */\nexport function getLayers(map, sourceId) {\n    var result = [];\n    var layers = map.getLayers().getArray();\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n        if (layers[i].get('mapbox-source') === sourceId) {\n            result.push(/** @type {Layer} */ (layers[i]));\n        }\n    }\n    return result;\n}\n/**\n * ```js\n * import {getSource} from 'ol-mapbox-style';\n * ```\n * Get the OpenLayers source instance for the provided Mapbox Style `source`.\n * @param {PluggableMap} map OpenLayers Map.\n * @param {string} sourceId Mapbox Style source id.\n * @return {Source} OpenLayers source instance.\n */\nexport function getSource(map, sourceId) {\n    var layers = map.getLayers().getArray();\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n        var source = /** @type {Layer} */ (layers[i]).getSource();\n        if (layers[i].get('mapbox-source') === sourceId) {\n            return source;\n        }\n    }\n}\nexport { finalizeLayer as _finalizeLayer, getFonts as _getFonts };\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}
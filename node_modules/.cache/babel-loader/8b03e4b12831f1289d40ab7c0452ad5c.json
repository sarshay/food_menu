{"ast":null,"code":"/**\n * @license\n * Latitude/longitude spherical geodesy formulae taken from\n * http://www.movable-type.co.uk/scripts/latlong.html\n * Licensed under CC-BY-3.0.\n */\nimport _ol_math_ from './math.js';\nimport _ol_geom_GeometryType_ from './geom/geometrytype.js';\n/**\n * @classdesc\n * Class to create objects that can be used with {@link\n * ol.geom.Polygon.circular}.\n *\n * For example to create a sphere whose radius is equal to the semi-major\n * axis of the WGS84 ellipsoid:\n *\n * ```js\n * var wgs84Sphere= new ol.Sphere(6378137);\n * ```\n *\n * @constructor\n * @param {number} radius Radius.\n * @api\n */\n\nvar _ol_Sphere_ = function (radius) {\n  /**\n   * @type {number}\n   */\n  this.radius = radius;\n};\n/**\n * Returns the geodesic area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @return {number} Area.\n * @api\n */\n\n\n_ol_Sphere_.prototype.geodesicArea = function (coordinates) {\n  return _ol_Sphere_.getArea_(coordinates, this.radius);\n};\n/**\n * Returns the distance from c1 to c2 using the haversine formula.\n *\n * @param {ol.Coordinate} c1 Coordinate 1.\n * @param {ol.Coordinate} c2 Coordinate 2.\n * @return {number} Haversine distance.\n * @api\n */\n\n\n_ol_Sphere_.prototype.haversineDistance = function (c1, c2) {\n  return _ol_Sphere_.getDistance_(c1, c2, this.radius);\n};\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @return {ol.Coordinate} The target point.\n */\n\n\n_ol_Sphere_.prototype.offset = function (c1, distance, bearing) {\n  var lat1 = _ol_math_.toRadians(c1[1]);\n\n  var lon1 = _ol_math_.toRadians(c1[0]);\n\n  var dByR = distance / this.radius;\n  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [_ol_math_.toDegrees(lon), _ol_math_.toDegrees(lat)];\n};\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\n\n\n_ol_Sphere_.DEFAULT_RADIUS = 6371008.8;\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {ol.geom.Geometry} geometry A geometry.\n * @param {olx.SphereMetricOptions=} opt_options Options for the length\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\n\n_ol_Sphere_.getLength = function (geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  var type = geometry.getType();\n  var length = 0;\n  var coordinates, coords, i, ii, j, jj;\n\n  switch (type) {\n    case _ol_geom_GeometryType_.POINT:\n    case _ol_geom_GeometryType_.MULTI_POINT:\n      {\n        break;\n      }\n\n    case _ol_geom_GeometryType_.LINE_STRING:\n    case _ol_geom_GeometryType_.LINEAR_RING:\n      {\n        coordinates =\n        /** @type {ol.geom.SimpleGeometry} */\n        geometry.getCoordinates();\n        length = _ol_Sphere_.getLength_(coordinates, radius);\n        break;\n      }\n\n    case _ol_geom_GeometryType_.MULTI_LINE_STRING:\n    case _ol_geom_GeometryType_.POLYGON:\n      {\n        coordinates =\n        /** @type {ol.geom.SimpleGeometry} */\n        geometry.getCoordinates();\n\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          length += _ol_Sphere_.getLength_(coordinates[i], radius);\n        }\n\n        break;\n      }\n\n    case _ol_geom_GeometryType_.MULTI_POLYGON:\n      {\n        coordinates =\n        /** @type {ol.geom.SimpleGeometry} */\n        geometry.getCoordinates();\n\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n\n          for (j = 0, jj = coords.length; j < jj; ++j) {\n            length += _ol_Sphere_.getLength_(coords[j], radius);\n          }\n        }\n\n        break;\n      }\n\n    case _ol_geom_GeometryType_.GEOMETRY_COLLECTION:\n      {\n        var geometries =\n        /** @type {ol.geom.GeometryCollection} */\n        geometry.getGeometries();\n\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          length += _ol_Sphere_.getLength(geometries[i], opt_options);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n  }\n\n  return length;\n};\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\n\n\n_ol_Sphere_.getLength_ = function (coordinates, radius) {\n  var length = 0;\n\n  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += _ol_Sphere_.getDistance_(coordinates[i], coordinates[i + 1], radius);\n  }\n\n  return length;\n};\n/**\n * Get the great circle distance between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} radius The sphere radius to use.\n * @return {number} The great circle distance between the points (in meters).\n */\n\n\n_ol_Sphere_.getDistance_ = function (c1, c2, radius) {\n  var lat1 = _ol_math_.toRadians(c1[1]);\n\n  var lat2 = _ol_math_.toRadians(c2[1]);\n\n  var deltaLatBy2 = (lat2 - lat1) / 2;\n  var deltaLonBy2 = _ol_math_.toRadians(c2[0] - c1[0]) / 2;\n  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n};\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {ol.geom.Geometry} geometry A geometry.\n * @param {olx.SphereMetricOptions=} opt_options Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\n\n\n_ol_Sphere_.getArea = function (geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  var type = geometry.getType();\n  var area = 0;\n  var coordinates, coords, i, ii, j, jj;\n\n  switch (type) {\n    case _ol_geom_GeometryType_.POINT:\n    case _ol_geom_GeometryType_.MULTI_POINT:\n    case _ol_geom_GeometryType_.LINE_STRING:\n    case _ol_geom_GeometryType_.MULTI_LINE_STRING:\n    case _ol_geom_GeometryType_.LINEAR_RING:\n      {\n        break;\n      }\n\n    case _ol_geom_GeometryType_.POLYGON:\n      {\n        coordinates =\n        /** @type {ol.geom.Polygon} */\n        geometry.getCoordinates();\n        area = Math.abs(_ol_Sphere_.getArea_(coordinates[0], radius));\n\n        for (i = 1, ii = coordinates.length; i < ii; ++i) {\n          area -= Math.abs(_ol_Sphere_.getArea_(coordinates[i], radius));\n        }\n\n        break;\n      }\n\n    case _ol_geom_GeometryType_.MULTI_POLYGON:\n      {\n        coordinates =\n        /** @type {ol.geom.SimpleGeometry} */\n        geometry.getCoordinates();\n\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          area += Math.abs(_ol_Sphere_.getArea_(coords[0], radius));\n\n          for (j = 1, jj = coords.length; j < jj; ++j) {\n            area -= Math.abs(_ol_Sphere_.getArea_(coords[j], radius));\n          }\n        }\n\n        break;\n      }\n\n    case _ol_geom_GeometryType_.GEOMETRY_COLLECTION:\n      {\n        var geometries =\n        /** @type {ol.geom.GeometryCollection} */\n        geometry.getGeometries();\n\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          area += _ol_Sphere_.getArea(geometries[i], opt_options);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n  }\n\n  return area;\n};\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\n\n\n_ol_Sphere_.getArea_ = function (coordinates, radius) {\n  var area = 0,\n      len = coordinates.length;\n  var x1 = coordinates[len - 1][0];\n  var y1 = coordinates[len - 1][1];\n\n  for (var i = 0; i < len; i++) {\n    var x2 = coordinates[i][0],\n        y2 = coordinates[i][1];\n    area += _ol_math_.toRadians(x2 - x1) * (2 + Math.sin(_ol_math_.toRadians(y1)) + Math.sin(_ol_math_.toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return area * radius * radius / 2.0;\n};\n\nexport default _ol_Sphere_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/sphere.js"],"names":["_ol_math_","_ol_geom_GeometryType_","_ol_Sphere_","radius","prototype","geodesicArea","coordinates","getArea_","haversineDistance","c1","c2","getDistance_","offset","distance","bearing","lat1","toRadians","lon1","dByR","lat","Math","asin","sin","cos","lon","atan2","toDegrees","DEFAULT_RADIUS","getLength","geometry","opt_options","options","projection","clone","transform","type","getType","length","coords","i","ii","j","jj","POINT","MULTI_POINT","LINE_STRING","LINEAR_RING","getCoordinates","getLength_","MULTI_LINE_STRING","POLYGON","MULTI_POLYGON","GEOMETRY_COLLECTION","geometries","getGeometries","Error","lat2","deltaLatBy2","deltaLonBy2","a","sqrt","getArea","area","abs","len","x1","y1","x2","y2"],"mappings":"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","sourcesContent":["/**\n * @license\n * Latitude/longitude spherical geodesy formulae taken from\n * http://www.movable-type.co.uk/scripts/latlong.html\n * Licensed under CC-BY-3.0.\n */\n\nimport _ol_math_ from './math.js';\nimport _ol_geom_GeometryType_ from './geom/geometrytype.js';\n\n/**\n * @classdesc\n * Class to create objects that can be used with {@link\n * ol.geom.Polygon.circular}.\n *\n * For example to create a sphere whose radius is equal to the semi-major\n * axis of the WGS84 ellipsoid:\n *\n * ```js\n * var wgs84Sphere= new ol.Sphere(6378137);\n * ```\n *\n * @constructor\n * @param {number} radius Radius.\n * @api\n */\nvar _ol_Sphere_ = function(radius) {\n\n  /**\n   * @type {number}\n   */\n  this.radius = radius;\n\n};\n\n\n/**\n * Returns the geodesic area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @return {number} Area.\n * @api\n */\n_ol_Sphere_.prototype.geodesicArea = function(coordinates) {\n  return _ol_Sphere_.getArea_(coordinates, this.radius);\n};\n\n\n/**\n * Returns the distance from c1 to c2 using the haversine formula.\n *\n * @param {ol.Coordinate} c1 Coordinate 1.\n * @param {ol.Coordinate} c2 Coordinate 2.\n * @return {number} Haversine distance.\n * @api\n */\n_ol_Sphere_.prototype.haversineDistance = function(c1, c2) {\n  return _ol_Sphere_.getDistance_(c1, c2, this.radius);\n};\n\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @return {ol.Coordinate} The target point.\n */\n_ol_Sphere_.prototype.offset = function(c1, distance, bearing) {\n  var lat1 = _ol_math_.toRadians(c1[1]);\n  var lon1 = _ol_math_.toRadians(c1[0]);\n  var dByR = distance / this.radius;\n  var lat = Math.asin(\n      Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  var lon = lon1 + Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [_ol_math_.toDegrees(lon), _ol_math_.toDegrees(lat)];\n};\n\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\n_ol_Sphere_.DEFAULT_RADIUS = 6371008.8;\n\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {ol.geom.Geometry} geometry A geometry.\n * @param {olx.SphereMetricOptions=} opt_options Options for the length\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\n_ol_Sphere_.getLength = function(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  var type = geometry.getType();\n  var length = 0;\n  var coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case _ol_geom_GeometryType_.POINT:\n    case _ol_geom_GeometryType_.MULTI_POINT: {\n      break;\n    }\n    case _ol_geom_GeometryType_.LINE_STRING:\n    case _ol_geom_GeometryType_.LINEAR_RING: {\n      coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n      length = _ol_Sphere_.getLength_(coordinates, radius);\n      break;\n    }\n    case _ol_geom_GeometryType_.MULTI_LINE_STRING:\n    case _ol_geom_GeometryType_.POLYGON: {\n      coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        length += _ol_Sphere_.getLength_(coordinates[i], radius);\n      }\n      break;\n    }\n    case _ol_geom_GeometryType_.MULTI_POLYGON: {\n      coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        for (j = 0, jj = coords.length; j < jj; ++j) {\n          length += _ol_Sphere_.getLength_(coords[j], radius);\n        }\n      }\n      break;\n    }\n    case _ol_geom_GeometryType_.GEOMETRY_COLLECTION: {\n      var geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        length += _ol_Sphere_.getLength(geometries[i], opt_options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return length;\n};\n\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\n_ol_Sphere_.getLength_ = function(coordinates, radius) {\n  var length = 0;\n  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += _ol_Sphere_.getDistance_(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n};\n\n\n/**\n * Get the great circle distance between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} radius The sphere radius to use.\n * @return {number} The great circle distance between the points (in meters).\n */\n_ol_Sphere_.getDistance_ = function(c1, c2, radius) {\n  var lat1 = _ol_math_.toRadians(c1[1]);\n  var lat2 = _ol_math_.toRadians(c2[1]);\n  var deltaLatBy2 = (lat2 - lat1) / 2;\n  var deltaLonBy2 = _ol_math_.toRadians(c2[0] - c1[0]) / 2;\n  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n      Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *\n      Math.cos(lat1) * Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n};\n\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {ol.geom.Geometry} geometry A geometry.\n * @param {olx.SphereMetricOptions=} opt_options Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\n_ol_Sphere_.getArea = function(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;\n  var projection = options.projection || 'EPSG:3857';\n  geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  var type = geometry.getType();\n  var area = 0;\n  var coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case _ol_geom_GeometryType_.POINT:\n    case _ol_geom_GeometryType_.MULTI_POINT:\n    case _ol_geom_GeometryType_.LINE_STRING:\n    case _ol_geom_GeometryType_.MULTI_LINE_STRING:\n    case _ol_geom_GeometryType_.LINEAR_RING: {\n      break;\n    }\n    case _ol_geom_GeometryType_.POLYGON: {\n      coordinates = /** @type {ol.geom.Polygon} */ (geometry).getCoordinates();\n      area = Math.abs(_ol_Sphere_.getArea_(coordinates[0], radius));\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\n        area -= Math.abs(_ol_Sphere_.getArea_(coordinates[i], radius));\n      }\n      break;\n    }\n    case _ol_geom_GeometryType_.MULTI_POLYGON: {\n      coordinates = /** @type {ol.geom.SimpleGeometry} */ (geometry).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        area += Math.abs(_ol_Sphere_.getArea_(coords[0], radius));\n        for (j = 1, jj = coords.length; j < jj; ++j) {\n          area -= Math.abs(_ol_Sphere_.getArea_(coords[j], radius));\n        }\n      }\n      break;\n    }\n    case _ol_geom_GeometryType_.GEOMETRY_COLLECTION: {\n      var geometries = /** @type {ol.geom.GeometryCollection} */ (geometry).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        area += _ol_Sphere_.getArea(geometries[i], opt_options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return area;\n};\n\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\n_ol_Sphere_.getArea_ = function(coordinates, radius) {\n  var area = 0, len = coordinates.length;\n  var x1 = coordinates[len - 1][0];\n  var y1 = coordinates[len - 1][1];\n  for (var i = 0; i < len; i++) {\n    var x2 = coordinates[i][0], y2 = coordinates[i][1];\n    area += _ol_math_.toRadians(x2 - x1) *\n        (2 + Math.sin(_ol_math_.toRadians(y1)) +\n        Math.sin(_ol_math_.toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return area * radius * radius / 2.0;\n};\nexport default _ol_Sphere_;\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * @module ol/source/VectorTile\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { buffer as bufferExtent, getIntersection, intersects } from '../extent.js';\nimport { createForProjection, createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { fromKey, getCacheKeyForTileKey, getKeyZXY } from '../tilecoord.js';\nimport { isEmpty } from '../obj.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\n\nvar VectorTile =\n/** @class */\nfunction (_super) {\n  __extends(VectorTile, _super);\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n\n\n  function VectorTile(options) {\n    var _this = this;\n\n    var projection = options.projection || 'EPSG:3857';\n    var extent = options.extent || extentFromProjection(projection);\n    var tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n\n    _this.format_ = options.format ? options.format : null;\n    /**\n     * @private\n     * @type {TileCache}\n     */\n\n    _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n\n    _this.tileClass = options.tileClass ? options.tileClass : Tile;\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n\n    _this.tileGrids_ = {};\n    return _this;\n  }\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n\n\n  VectorTile.prototype.getFeaturesInExtent = function (extent) {\n    var features = [];\n    var tileCache = this.tileCache;\n\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n\n    var z = fromKey(tileCache.peekFirstKey())[0];\n    var tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n\n      var sourceTiles = tile.getSourceTiles();\n\n      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        var sourceTile = sourceTiles[i];\n        var tileCoord = sourceTile.tileCoord;\n\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          var tileFeatures = sourceTile.getFeatures();\n\n          if (tileFeatures) {\n            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              var candidate = tileFeatures[j];\n              var geometry = candidate.getGeometry();\n\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  };\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n\n\n  VectorTile.prototype.getOverlaps = function () {\n    return this.overlaps_;\n  };\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n\n\n  VectorTile.prototype.clear = function () {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n\n\n  VectorTile.prototype.expireCache = function (projection, usedTiles) {\n    var tileCache = this.getTileCacheForProjection(projection);\n    var usedSourceTiles = Object.keys(usedTiles).reduce(function (acc, key) {\n      var cacheKey = getCacheKeyForTileKey(key);\n\n      if (tileCache.containsKey(cacheKey)) {\n        var sourceTiles = tileCache.get(cacheKey).sourceTiles;\n\n        for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n          acc[sourceTiles[i].getKey()] = true;\n        }\n      }\n\n      return acc;\n    }, {});\n\n    _super.prototype.expireCache.call(this, projection, usedTiles);\n\n    this.sourceTileCache.expireCache(usedSourceTiles);\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n\n\n  VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n    var _this = this;\n\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n      var urlTileCoord = tile.wrappedTileCoord;\n      var tileGrid = this.getTileGridForProjection(projection);\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      var z = urlTileCoord[0];\n      var resolution = tileGrid.getResolution(z); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      bufferExtent(extent, -resolution, extent);\n      var sourceTileGrid_1 = this.tileGrid;\n      var sourceExtent = sourceTileGrid_1.getExtent();\n\n      if (sourceExtent) {\n        getIntersection(extent, sourceExtent, extent);\n      }\n\n      var sourceZ = sourceTileGrid_1.getZForResolution(resolution, 1);\n      sourceTileGrid_1.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        var tileUrl = _this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n\n        var sourceTile = _this.sourceTileCache.containsKey(tileUrl) ? _this.sourceTileCache.get(tileUrl) : new _this.tileClass(sourceTileCoord, tileUrl ? TileState.IDLE : TileState.EMPTY, tileUrl, _this.format_, _this.tileLoadFunction);\n        tile.sourceTiles.push(sourceTile);\n        var sourceTileState = sourceTile.getState();\n\n        if (sourceTileState < TileState.LOADED) {\n          var listenChange_1 = function (event) {\n            _this.handleTileChange(event);\n\n            var state = sourceTile.getState();\n\n            if (state === TileState.LOADED || state === TileState.ERROR) {\n              var sourceTileKey = sourceTile.getKey();\n\n              if (sourceTileKey in tile.errorTileKeys) {\n                if (sourceTile.getState() === TileState.LOADED) {\n                  delete tile.errorTileKeys[sourceTileKey];\n                }\n              } else {\n                tile.loadingSourceTiles--;\n              }\n\n              if (state === TileState.ERROR) {\n                tile.errorTileKeys[sourceTileKey] = true;\n              } else {\n                sourceTile.removeEventListener(EventType.CHANGE, listenChange_1);\n              }\n\n              if (tile.loadingSourceTiles === 0) {\n                tile.setState(isEmpty(tile.errorTileKeys) ? TileState.LOADED : TileState.ERROR);\n              }\n            }\n          };\n\n          sourceTile.addEventListener(EventType.CHANGE, listenChange_1);\n          tile.loadingSourceTiles++;\n        }\n\n        if (sourceTileState === TileState.IDLE) {\n          sourceTile.extent = sourceTileGrid_1.getTileCoordExtent(sourceTileCoord);\n          sourceTile.projection = projection;\n          sourceTile.resolution = sourceTileGrid_1.getResolution(sourceTileCoord[0]);\n\n          _this.sourceTileCache.set(tileUrl, sourceTile);\n\n          sourceTile.load();\n        }\n      });\n\n      if (!tile.loadingSourceTiles) {\n        tile.setState(tile.sourceTiles.some(function (sourceTile) {\n          return sourceTile.getState() === TileState.ERROR;\n        }) ? TileState.ERROR : TileState.LOADED);\n      }\n    }\n\n    return tile.sourceTiles;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n\n\n  VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var coordKey = getKeyZXY(z, x, y);\n    var key = this.getKey();\n    var tile;\n\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var sourceExtent = this.getTileGrid().getExtent();\n    var tileGrid = this.getTileGridForProjection(projection);\n\n    if (urlTileCoord && sourceExtent) {\n      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n\n    var empty = true;\n\n    if (urlTileCoord !== null) {\n      var sourceTileGrid = this.tileGrid;\n      var resolution = tileGrid.getResolution(z);\n      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      }.bind(this));\n    }\n\n    var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n    newTile.key = key;\n\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n\n    return newTile;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n\n\n  VectorTile.prototype.getTileGridForProjection = function (projection) {\n    var code = projection.getCode();\n    var tileGrid = this.tileGrids_[code];\n\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      var sourceTileGrid = this.tileGrid;\n      tileGrid = createForProjection(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n      this.tileGrids_[code] = tileGrid;\n    }\n\n    return tileGrid;\n  };\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n\n\n  VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n    return pixelRatio;\n  };\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n\n\n  VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  };\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n\n\n  VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n\n    this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;\n  };\n\n  return VectorTile;\n}(UrlTile);\n\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\n\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  function (extent, resolution, projection) {\n    loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));\n  });\n}","map":{"version":3,"sources":["../src/source/VectorTile.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/source/VectorTile\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { buffer as bufferExtent, getIntersection, intersects, } from '../extent.js';\nimport { createForProjection, createXYZ, extentFromProjection, } from '../tilegrid.js';\nimport { fromKey, getCacheKeyForTileKey, getKeyZXY } from '../tilecoord.js';\nimport { isEmpty } from '../obj.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent] Extent.\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=1]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar VectorTile = /** @class */ (function (_super) {\n    __extends(VectorTile, _super);\n    /**\n     * @param {!Options} options Vector tile options.\n     */\n    function VectorTile(options) {\n        var _this = this;\n        var projection = options.projection || 'EPSG:3857';\n        var extent = options.extent || extentFromProjection(projection);\n        var tileGrid = options.tileGrid ||\n            createXYZ({\n                extent: extent,\n                maxResolution: options.maxResolution,\n                maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n                minZoom: options.minZoom,\n                tileSize: options.tileSize || 512,\n            });\n        _this = _super.call(this, {\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            cacheSize: options.cacheSize,\n            opaque: false,\n            projection: projection,\n            state: options.state,\n            tileGrid: tileGrid,\n            tileLoadFunction: options.tileLoadFunction\n                ? options.tileLoadFunction\n                : defaultLoadFunction,\n            tileUrlFunction: options.tileUrlFunction,\n            url: options.url,\n            urls: options.urls,\n            wrapX: options.wrapX === undefined ? true : options.wrapX,\n            transition: options.transition,\n            zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n        }) || this;\n        /**\n         * @private\n         * @type {import(\"../format/Feature.js\").default}\n         */\n        _this.format_ = options.format ? options.format : null;\n        /**\n         * @private\n         * @type {TileCache}\n         */\n        _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n        /**\n         * @protected\n         * @type {typeof import(\"../VectorTile.js\").default}\n         */\n        _this.tileClass = options.tileClass ? options.tileClass : Tile;\n        /**\n         * @private\n         * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n         */\n        _this.tileGrids_ = {};\n        return _this;\n    }\n    /**\n     * Get features whose bounding box intersects the provided extent. Only features for cached\n     * tiles for the last rendered zoom level are available in the source. So this method is only\n     * suitable for requesting tiles for extents that are currently rendered.\n     *\n     * Features are returned in random tile order and as they are included in the tiles. This means\n     * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     * @api\n     */\n    VectorTile.prototype.getFeaturesInExtent = function (extent) {\n        var features = [];\n        var tileCache = this.tileCache;\n        if (tileCache.getCount() === 0) {\n            return features;\n        }\n        var z = fromKey(tileCache.peekFirstKey())[0];\n        var tileGrid = this.tileGrid;\n        tileCache.forEach(function (tile) {\n            if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n                return;\n            }\n            var sourceTiles = tile.getSourceTiles();\n            for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n                var sourceTile = sourceTiles[i];\n                var tileCoord = sourceTile.tileCoord;\n                if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n                    var tileFeatures = sourceTile.getFeatures();\n                    if (tileFeatures) {\n                        for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n                            var candidate = tileFeatures[j];\n                            var geometry = candidate.getGeometry();\n                            if (intersects(extent, geometry.getExtent())) {\n                                features.push(candidate);\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return features;\n    };\n    /**\n     * @return {boolean} The source can have overlapping geometries.\n     */\n    VectorTile.prototype.getOverlaps = function () {\n        return this.overlaps_;\n    };\n    /**\n     * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n     * @api\n     */\n    VectorTile.prototype.clear = function () {\n        this.tileCache.clear();\n        this.sourceTileCache.clear();\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    VectorTile.prototype.expireCache = function (projection, usedTiles) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        var usedSourceTiles = Object.keys(usedTiles).reduce(function (acc, key) {\n            var cacheKey = getCacheKeyForTileKey(key);\n            if (tileCache.containsKey(cacheKey)) {\n                var sourceTiles = tileCache.get(cacheKey).sourceTiles;\n                for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n                    acc[sourceTiles[i].getKey()] = true;\n                }\n            }\n            return acc;\n        }, {});\n        _super.prototype.expireCache.call(this, projection, usedTiles);\n        this.sourceTileCache.expireCache(usedSourceTiles);\n    };\n    /**\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection\").default} projection Projection.\n     * @param {VectorRenderTile} tile Vector image tile.\n     * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n     */\n    VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n        var _this = this;\n        if (tile.getState() === TileState.IDLE) {\n            tile.setState(TileState.LOADING);\n            var urlTileCoord = tile.wrappedTileCoord;\n            var tileGrid = this.getTileGridForProjection(projection);\n            var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n            var z = urlTileCoord[0];\n            var resolution = tileGrid.getResolution(z);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            bufferExtent(extent, -resolution, extent);\n            var sourceTileGrid_1 = this.tileGrid;\n            var sourceExtent = sourceTileGrid_1.getExtent();\n            if (sourceExtent) {\n                getIntersection(extent, sourceExtent, extent);\n            }\n            var sourceZ = sourceTileGrid_1.getZForResolution(resolution, 1);\n            sourceTileGrid_1.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n                var tileUrl = _this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n                var sourceTile = _this.sourceTileCache.containsKey(tileUrl)\n                    ? _this.sourceTileCache.get(tileUrl)\n                    : new _this.tileClass(sourceTileCoord, tileUrl ? TileState.IDLE : TileState.EMPTY, tileUrl, _this.format_, _this.tileLoadFunction);\n                tile.sourceTiles.push(sourceTile);\n                var sourceTileState = sourceTile.getState();\n                if (sourceTileState < TileState.LOADED) {\n                    var listenChange_1 = function (event) {\n                        _this.handleTileChange(event);\n                        var state = sourceTile.getState();\n                        if (state === TileState.LOADED || state === TileState.ERROR) {\n                            var sourceTileKey = sourceTile.getKey();\n                            if (sourceTileKey in tile.errorTileKeys) {\n                                if (sourceTile.getState() === TileState.LOADED) {\n                                    delete tile.errorTileKeys[sourceTileKey];\n                                }\n                            }\n                            else {\n                                tile.loadingSourceTiles--;\n                            }\n                            if (state === TileState.ERROR) {\n                                tile.errorTileKeys[sourceTileKey] = true;\n                            }\n                            else {\n                                sourceTile.removeEventListener(EventType.CHANGE, listenChange_1);\n                            }\n                            if (tile.loadingSourceTiles === 0) {\n                                tile.setState(isEmpty(tile.errorTileKeys)\n                                    ? TileState.LOADED\n                                    : TileState.ERROR);\n                            }\n                        }\n                    };\n                    sourceTile.addEventListener(EventType.CHANGE, listenChange_1);\n                    tile.loadingSourceTiles++;\n                }\n                if (sourceTileState === TileState.IDLE) {\n                    sourceTile.extent =\n                        sourceTileGrid_1.getTileCoordExtent(sourceTileCoord);\n                    sourceTile.projection = projection;\n                    sourceTile.resolution = sourceTileGrid_1.getResolution(sourceTileCoord[0]);\n                    _this.sourceTileCache.set(tileUrl, sourceTile);\n                    sourceTile.load();\n                }\n            });\n            if (!tile.loadingSourceTiles) {\n                tile.setState(tile.sourceTiles.some(function (sourceTile) { return sourceTile.getState() === TileState.ERROR; })\n                    ? TileState.ERROR\n                    : TileState.LOADED);\n            }\n        }\n        return tile.sourceTiles;\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!VectorRenderTile} Tile.\n     */\n    VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var coordKey = getKeyZXY(z, x, y);\n        var key = this.getKey();\n        var tile;\n        if (this.tileCache.containsKey(coordKey)) {\n            tile = this.tileCache.get(coordKey);\n            if (tile.key === key) {\n                return tile;\n            }\n        }\n        var tileCoord = [z, x, y];\n        var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var sourceExtent = this.getTileGrid().getExtent();\n        var tileGrid = this.getTileGridForProjection(projection);\n        if (urlTileCoord && sourceExtent) {\n            var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n            if (!intersects(sourceExtent, tileExtent)) {\n                urlTileCoord = null;\n            }\n        }\n        var empty = true;\n        if (urlTileCoord !== null) {\n            var sourceTileGrid = this.tileGrid;\n            var resolution = tileGrid.getResolution(z);\n            var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n            bufferExtent(extent, -resolution, extent);\n            sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n                empty =\n                    empty &&\n                        !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n            }.bind(this));\n        }\n        var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n        newTile.key = key;\n        if (tile) {\n            newTile.interimTile = tile;\n            newTile.refreshInterimChain();\n            this.tileCache.replace(coordKey, newTile);\n        }\n        else {\n            this.tileCache.set(coordKey, newTile);\n        }\n        return newTile;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n    VectorTile.prototype.getTileGridForProjection = function (projection) {\n        var code = projection.getCode();\n        var tileGrid = this.tileGrids_[code];\n        if (!tileGrid) {\n            // A tile grid that matches the tile size of the source tile grid is more\n            // likely to have 1:1 relationships between source tiles and rendered tiles.\n            var sourceTileGrid = this.tileGrid;\n            tileGrid = createForProjection(projection, undefined, sourceTileGrid\n                ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom())\n                : undefined);\n            this.tileGrids_[code] = tileGrid;\n        }\n        return tileGrid;\n    };\n    /**\n     * Get the tile pixel ratio for this source.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Tile pixel ratio.\n     */\n    VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n        return pixelRatio;\n    };\n    /**\n     * @param {number} z Z.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../size.js\").Size} Tile size.\n     */\n    VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n        var tileGrid = this.getTileGridForProjection(projection);\n        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n        return [\n            Math.round(tileSize[0] * pixelRatio),\n            Math.round(tileSize[1] * pixelRatio),\n        ];\n    };\n    /**\n     * Increases the cache size if needed\n     * @param {number} tileCount Minimum number of tiles needed.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n        _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n        this.sourceTileCache.highWaterMark =\n            this.getTileCacheForProjection(projection).highWaterMark;\n    };\n    return VectorTile;\n}(UrlTile));\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n    tile.setLoader(\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    function (extent, resolution, projection) {\n        loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));\n    });\n}\n//# sourceMappingURL=VectorTile.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"// FIXME draw drag box\nimport _ol_events_Event_ from '../events/event.js';\nimport _ol_ from '../index.js';\nimport _ol_events_condition_ from '../events/condition.js';\nimport _ol_interaction_Pointer_ from '../interaction/pointer.js';\nimport _ol_render_Box_ from '../render/box.js';\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map,\n * normally combined with an {@link ol.events.condition} that limits\n * it to when the shift or other key is held down. This is used, for example,\n * for zooming to a specific area of the map\n * (see {@link ol.interaction.DragZoom} and\n * {@link ol.interaction.DragRotateAndZoom}).\n *\n * This interaction is only supported for mouse devices.\n *\n * @constructor\n * @extends {ol.interaction.Pointer}\n * @fires ol.interaction.DragBox.Event\n * @param {olx.interaction.DragBoxOptions=} opt_options Options.\n * @api\n */\n\nvar _ol_interaction_DragBox_ = function (opt_options) {\n  _ol_interaction_Pointer_.call(this, {\n    handleDownEvent: _ol_interaction_DragBox_.handleDownEvent_,\n    handleDragEvent: _ol_interaction_DragBox_.handleDragEvent_,\n    handleUpEvent: _ol_interaction_DragBox_.handleUpEvent_\n  });\n\n  var options = opt_options ? opt_options : {};\n  /**\n   * @type {ol.render.Box}\n   * @private\n   */\n\n  this.box_ = new _ol_render_Box_(options.className || 'ol-dragbox');\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n  /**\n   * @type {ol.Pixel}\n   * @private\n   */\n\n  this.startPixel_ = null;\n  /**\n   * @private\n   * @type {ol.EventsConditionType}\n   */\n\n  this.condition_ = options.condition ? options.condition : _ol_events_condition_.always;\n  /**\n   * @private\n   * @type {ol.DragBoxEndConditionType}\n   */\n\n  this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _ol_interaction_DragBox_.defaultBoxEndCondition;\n};\n\n_ol_.inherits(_ol_interaction_DragBox_, _ol_interaction_Pointer_);\n/**\n * The default condition for determining whether the boxend event\n * should fire.\n * @param {ol.MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent\n *     leading to the box end.\n * @param {ol.Pixel} startPixel The starting pixel of the box.\n * @param {ol.Pixel} endPixel The end pixel of the box.\n * @return {boolean} Whether or not the boxend condition should be fired.\n * @this {ol.interaction.DragBox}\n */\n\n\n_ol_interaction_DragBox_.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {\n  var width = endPixel[0] - startPixel[0];\n  var height = endPixel[1] - startPixel[1];\n  return width * width + height * height >= this.minArea_;\n};\n/**\n * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n * @this {ol.interaction.DragBox}\n * @private\n */\n\n\n_ol_interaction_DragBox_.handleDragEvent_ = function (mapBrowserEvent) {\n  if (!_ol_events_condition_.mouseOnly(mapBrowserEvent)) {\n    return;\n  }\n\n  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n  this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));\n};\n/**\n * Returns geometry of last drawn box.\n * @return {ol.geom.Polygon} Geometry.\n * @api\n */\n\n\n_ol_interaction_DragBox_.prototype.getGeometry = function () {\n  return this.box_.getGeometry();\n};\n/**\n * To be overridden by child classes.\n * FIXME: use constructor option instead of relying on overriding.\n * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n * @protected\n */\n\n\n_ol_interaction_DragBox_.prototype.onBoxEnd = _ol_.nullFunction;\n/**\n * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Stop drag sequence?\n * @this {ol.interaction.DragBox}\n * @private\n */\n\n_ol_interaction_DragBox_.handleUpEvent_ = function (mapBrowserEvent) {\n  if (!_ol_events_condition_.mouseOnly(mapBrowserEvent)) {\n    return true;\n  }\n\n  this.box_.setMap(null);\n\n  if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {\n    this.onBoxEnd(mapBrowserEvent);\n    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));\n  }\n\n  return false;\n};\n/**\n * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Start drag sequence?\n * @this {ol.interaction.DragBox}\n * @private\n */\n\n\n_ol_interaction_DragBox_.handleDownEvent_ = function (mapBrowserEvent) {\n  if (!_ol_events_condition_.mouseOnly(mapBrowserEvent)) {\n    return false;\n  }\n\n  if (_ol_events_condition_.mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {\n    this.startPixel_ = mapBrowserEvent.pixel;\n    this.box_.setMap(mapBrowserEvent.map);\n    this.box_.setPixels(this.startPixel_, this.startPixel_);\n    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));\n    return true;\n  } else {\n    return false;\n  }\n};\n/**\n * @enum {string}\n * @private\n */\n\n\n_ol_interaction_DragBox_.EventType_ = {\n  /**\n   * Triggered upon drag box start.\n   * @event ol.interaction.DragBox.Event#boxstart\n   * @api\n   */\n  BOXSTART: 'boxstart',\n\n  /**\n   * Triggered on drag when box is active.\n   * @event ol.interaction.DragBox.Event#boxdrag\n   * @api\n   */\n  BOXDRAG: 'boxdrag',\n\n  /**\n   * Triggered upon drag box end.\n   * @event ol.interaction.DragBox.Event#boxend\n   * @api\n   */\n  BOXEND: 'boxend'\n};\n/**\n * @classdesc\n * Events emitted by {@link ol.interaction.DragBox} instances are instances of\n * this type.\n *\n * @param {string} type The event type.\n * @param {ol.Coordinate} coordinate The event coordinate.\n * @param {ol.MapBrowserEvent} mapBrowserEvent Originating event.\n * @extends {ol.events.Event}\n * @constructor\n * @implements {oli.DragBoxEvent}\n */\n\n_ol_interaction_DragBox_.Event = function (type, coordinate, mapBrowserEvent) {\n  _ol_events_Event_.call(this, type);\n  /**\n   * The coordinate of the drag event.\n   * @const\n   * @type {ol.Coordinate}\n   * @api\n   */\n\n\n  this.coordinate = coordinate;\n  /**\n   * @const\n   * @type {ol.MapBrowserEvent}\n   * @api\n   */\n\n  this.mapBrowserEvent = mapBrowserEvent;\n};\n\n_ol_.inherits(_ol_interaction_DragBox_.Event, _ol_events_Event_);\n\nexport default _ol_interaction_DragBox_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/interaction/dragbox.js"],"names":["_ol_events_Event_","_ol_","_ol_events_condition_","_ol_interaction_Pointer_","_ol_render_Box_","_ol_interaction_DragBox_","opt_options","call","handleDownEvent","handleDownEvent_","handleDragEvent","handleDragEvent_","handleUpEvent","handleUpEvent_","options","box_","className","minArea_","minArea","undefined","startPixel_","condition_","condition","always","boxEndCondition_","boxEndCondition","defaultBoxEndCondition","inherits","mapBrowserEvent","startPixel","endPixel","width","height","mouseOnly","setPixels","pixel","dispatchEvent","Event","EventType_","BOXDRAG","coordinate","prototype","getGeometry","onBoxEnd","nullFunction","setMap","BOXEND","mouseActionButton","map","BOXSTART","type"],"mappings":"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","sourcesContent":["// FIXME draw drag box\nimport _ol_events_Event_ from '../events/event.js';\nimport _ol_ from '../index.js';\nimport _ol_events_condition_ from '../events/condition.js';\nimport _ol_interaction_Pointer_ from '../interaction/pointer.js';\nimport _ol_render_Box_ from '../render/box.js';\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map,\n * normally combined with an {@link ol.events.condition} that limits\n * it to when the shift or other key is held down. This is used, for example,\n * for zooming to a specific area of the map\n * (see {@link ol.interaction.DragZoom} and\n * {@link ol.interaction.DragRotateAndZoom}).\n *\n * This interaction is only supported for mouse devices.\n *\n * @constructor\n * @extends {ol.interaction.Pointer}\n * @fires ol.interaction.DragBox.Event\n * @param {olx.interaction.DragBoxOptions=} opt_options Options.\n * @api\n */\nvar _ol_interaction_DragBox_ = function(opt_options) {\n\n  _ol_interaction_Pointer_.call(this, {\n    handleDownEvent: _ol_interaction_DragBox_.handleDownEvent_,\n    handleDragEvent: _ol_interaction_DragBox_.handleDragEvent_,\n    handleUpEvent: _ol_interaction_DragBox_.handleUpEvent_\n  });\n\n  var options = opt_options ? opt_options : {};\n\n  /**\n   * @type {ol.render.Box}\n   * @private\n   */\n  this.box_ = new _ol_render_Box_(options.className || 'ol-dragbox');\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n\n  /**\n   * @type {ol.Pixel}\n   * @private\n   */\n  this.startPixel_ = null;\n\n  /**\n   * @private\n   * @type {ol.EventsConditionType}\n   */\n  this.condition_ = options.condition ?\n    options.condition : _ol_events_condition_.always;\n\n  /**\n   * @private\n   * @type {ol.DragBoxEndConditionType}\n   */\n  this.boxEndCondition_ = options.boxEndCondition ?\n    options.boxEndCondition : _ol_interaction_DragBox_.defaultBoxEndCondition;\n};\n\n_ol_.inherits(_ol_interaction_DragBox_, _ol_interaction_Pointer_);\n\n\n/**\n * The default condition for determining whether the boxend event\n * should fire.\n * @param {ol.MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent\n *     leading to the box end.\n * @param {ol.Pixel} startPixel The starting pixel of the box.\n * @param {ol.Pixel} endPixel The end pixel of the box.\n * @return {boolean} Whether or not the boxend condition should be fired.\n * @this {ol.interaction.DragBox}\n */\n_ol_interaction_DragBox_.defaultBoxEndCondition = function(mapBrowserEvent, startPixel, endPixel) {\n  var width = endPixel[0] - startPixel[0];\n  var height = endPixel[1] - startPixel[1];\n  return width * width + height * height >= this.minArea_;\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n * @this {ol.interaction.DragBox}\n * @private\n */\n_ol_interaction_DragBox_.handleDragEvent_ = function(mapBrowserEvent) {\n  if (!_ol_events_condition_.mouseOnly(mapBrowserEvent)) {\n    return;\n  }\n\n  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n\n  this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXDRAG,\n      mapBrowserEvent.coordinate, mapBrowserEvent));\n};\n\n\n/**\n * Returns geometry of last drawn box.\n * @return {ol.geom.Polygon} Geometry.\n * @api\n */\n_ol_interaction_DragBox_.prototype.getGeometry = function() {\n  return this.box_.getGeometry();\n};\n\n\n/**\n * To be overridden by child classes.\n * FIXME: use constructor option instead of relying on overriding.\n * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n * @protected\n */\n_ol_interaction_DragBox_.prototype.onBoxEnd = _ol_.nullFunction;\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Stop drag sequence?\n * @this {ol.interaction.DragBox}\n * @private\n */\n_ol_interaction_DragBox_.handleUpEvent_ = function(mapBrowserEvent) {\n  if (!_ol_events_condition_.mouseOnly(mapBrowserEvent)) {\n    return true;\n  }\n\n  this.box_.setMap(null);\n\n  if (this.boxEndCondition_(mapBrowserEvent,\n      this.startPixel_, mapBrowserEvent.pixel)) {\n    this.onBoxEnd(mapBrowserEvent);\n    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXEND,\n        mapBrowserEvent.coordinate, mapBrowserEvent));\n  }\n  return false;\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.\n * @return {boolean} Start drag sequence?\n * @this {ol.interaction.DragBox}\n * @private\n */\n_ol_interaction_DragBox_.handleDownEvent_ = function(mapBrowserEvent) {\n  if (!_ol_events_condition_.mouseOnly(mapBrowserEvent)) {\n    return false;\n  }\n\n  if (_ol_events_condition_.mouseActionButton(mapBrowserEvent) &&\n      this.condition_(mapBrowserEvent)) {\n    this.startPixel_ = mapBrowserEvent.pixel;\n    this.box_.setMap(mapBrowserEvent.map);\n    this.box_.setPixels(this.startPixel_, this.startPixel_);\n    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXSTART,\n        mapBrowserEvent.coordinate, mapBrowserEvent));\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @enum {string}\n * @private\n */\n_ol_interaction_DragBox_.EventType_ = {\n  /**\n   * Triggered upon drag box start.\n   * @event ol.interaction.DragBox.Event#boxstart\n   * @api\n   */\n  BOXSTART: 'boxstart',\n\n  /**\n   * Triggered on drag when box is active.\n   * @event ol.interaction.DragBox.Event#boxdrag\n   * @api\n   */\n  BOXDRAG: 'boxdrag',\n\n  /**\n   * Triggered upon drag box end.\n   * @event ol.interaction.DragBox.Event#boxend\n   * @api\n   */\n  BOXEND: 'boxend'\n};\n\n\n/**\n * @classdesc\n * Events emitted by {@link ol.interaction.DragBox} instances are instances of\n * this type.\n *\n * @param {string} type The event type.\n * @param {ol.Coordinate} coordinate The event coordinate.\n * @param {ol.MapBrowserEvent} mapBrowserEvent Originating event.\n * @extends {ol.events.Event}\n * @constructor\n * @implements {oli.DragBoxEvent}\n */\n_ol_interaction_DragBox_.Event = function(type, coordinate, mapBrowserEvent) {\n  _ol_events_Event_.call(this, type);\n\n  /**\n   * The coordinate of the drag event.\n   * @const\n   * @type {ol.Coordinate}\n   * @api\n   */\n  this.coordinate = coordinate;\n\n  /**\n   * @const\n   * @type {ol.MapBrowserEvent}\n   * @api\n   */\n  this.mapBrowserEvent = mapBrowserEvent;\n\n};\n_ol_.inherits(_ol_interaction_DragBox_.Event, _ol_events_Event_);\nexport default _ol_interaction_DragBox_;\n"]},"metadata":{},"sourceType":"module"}
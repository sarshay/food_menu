{"ast":null,"code":"import _ol_asserts_ from './asserts.js';\nvar _ol_transform_ = {};\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 3x3 martrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n\n/**\n * @private\n * @type {ol.Transform}\n */\n\n_ol_transform_.tmp_ = new Array(6);\n/**\n * Create an identity transform.\n * @return {!ol.Transform} Identity transform.\n */\n\n_ol_transform_.create = function () {\n  return [1, 0, 0, 1, 0, 0];\n};\n/**\n * Resets the given transform to an identity transform.\n * @param {!ol.Transform} transform Transform.\n * @return {!ol.Transform} Transform.\n */\n\n\n_ol_transform_.reset = function (transform) {\n  return _ol_transform_.set(transform, 1, 0, 0, 1, 0, 0);\n};\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!ol.Transform} transform1 Transform parameters of matrix 1.\n * @param {!ol.Transform} transform2 Transform parameters of matrix 2.\n * @return {!ol.Transform} transform1 multiplied with transform2.\n */\n\n\n_ol_transform_.multiply = function (transform1, transform2) {\n  var a1 = transform1[0];\n  var b1 = transform1[1];\n  var c1 = transform1[2];\n  var d1 = transform1[3];\n  var e1 = transform1[4];\n  var f1 = transform1[5];\n  var a2 = transform2[0];\n  var b2 = transform2[1];\n  var c2 = transform2[2];\n  var d2 = transform2[3];\n  var e2 = transform2[4];\n  var f2 = transform2[5];\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n  return transform1;\n};\n/**\n * Set the transform components a-f on a given transform.\n * @param {!ol.Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!ol.Transform} Matrix with transform applied.\n */\n\n\n_ol_transform_.set = function (transform, a, b, c, d, e, f) {\n  transform[0] = a;\n  transform[1] = b;\n  transform[2] = c;\n  transform[3] = d;\n  transform[4] = e;\n  transform[5] = f;\n  return transform;\n};\n/**\n * Set transform on one matrix from another matrix.\n * @param {!ol.Transform} transform1 Matrix to set transform to.\n * @param {!ol.Transform} transform2 Matrix to set transform from.\n * @return {!ol.Transform} transform1 with transform from transform2 applied.\n */\n\n\n_ol_transform_.setFromArray = function (transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n};\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {ol.Transform} transform The transformation.\n * @param {ol.Coordinate|ol.Pixel} coordinate The coordinate to transform.\n * @return {ol.Coordinate|ol.Pixel} return coordinate so that operations can be\n *     chained together.\n */\n\n\n_ol_transform_.apply = function (transform, coordinate) {\n  var x = coordinate[0],\n      y = coordinate[1];\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n  return coordinate;\n};\n/**\n * Applies rotation to the given transform.\n * @param {!ol.Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!ol.Transform} The rotated transform.\n */\n\n\n_ol_transform_.rotate = function (transform, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, cos, sin, -sin, cos, 0, 0));\n};\n/**\n * Applies scale to a given transform.\n * @param {!ol.Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!ol.Transform} The scaled transform.\n */\n\n\n_ol_transform_.scale = function (transform, x, y) {\n  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, x, 0, 0, y, 0, 0));\n};\n/**\n * Applies translation to the given transform.\n * @param {!ol.Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!ol.Transform} The translated transform.\n */\n\n\n_ol_transform_.translate = function (transform, dx, dy) {\n  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, 1, 0, 0, 1, dx, dy));\n};\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!ol.Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!ol.Transform} The composite transform.\n */\n\n\n_ol_transform_.compose = function (transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n  var sin = Math.sin(angle);\n  var cos = Math.cos(angle);\n  transform[0] = sx * cos;\n  transform[1] = sy * sin;\n  transform[2] = -sx * sin;\n  transform[3] = sy * cos;\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform;\n};\n/**\n * Invert the given transform.\n * @param {!ol.Transform} transform Transform.\n * @return {!ol.Transform} Inverse of the transform.\n */\n\n\n_ol_transform_.invert = function (transform) {\n  var det = _ol_transform_.determinant(transform);\n\n  _ol_asserts_.assert(det !== 0, 32); // Transformation matrix cannot be inverted\n\n\n  var a = transform[0];\n  var b = transform[1];\n  var c = transform[2];\n  var d = transform[3];\n  var e = transform[4];\n  var f = transform[5];\n  transform[0] = d / det;\n  transform[1] = -b / det;\n  transform[2] = -c / det;\n  transform[3] = a / det;\n  transform[4] = (c * f - d * e) / det;\n  transform[5] = -(a * f - b * e) / det;\n  return transform;\n};\n/**\n * Returns the determinant of the given matrix.\n * @param {!ol.Transform} mat Matrix.\n * @return {number} Determinant.\n */\n\n\n_ol_transform_.determinant = function (mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n};\n\nexport default _ol_transform_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/transform.js"],"names":["_ol_asserts_","_ol_transform_","tmp_","Array","create","reset","transform","set","multiply","transform1","transform2","a1","b1","c1","d1","e1","f1","a2","b2","c2","d2","e2","f2","a","b","c","d","e","f","setFromArray","apply","coordinate","x","y","rotate","angle","cos","Math","sin","scale","translate","dx","dy","compose","dx1","dy1","sx","sy","dx2","dy2","invert","det","determinant","assert","mat"],"mappings":"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","sourcesContent":["import _ol_asserts_ from './asserts.js';\nvar _ol_transform_ = {};\n\n\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 3x3 martrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n\n\n/**\n * @private\n * @type {ol.Transform}\n */\n_ol_transform_.tmp_ = new Array(6);\n\n\n/**\n * Create an identity transform.\n * @return {!ol.Transform} Identity transform.\n */\n_ol_transform_.create = function() {\n  return [1, 0, 0, 1, 0, 0];\n};\n\n\n/**\n * Resets the given transform to an identity transform.\n * @param {!ol.Transform} transform Transform.\n * @return {!ol.Transform} Transform.\n */\n_ol_transform_.reset = function(transform) {\n  return _ol_transform_.set(transform, 1, 0, 0, 1, 0, 0);\n};\n\n\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!ol.Transform} transform1 Transform parameters of matrix 1.\n * @param {!ol.Transform} transform2 Transform parameters of matrix 2.\n * @return {!ol.Transform} transform1 multiplied with transform2.\n */\n_ol_transform_.multiply = function(transform1, transform2) {\n  var a1 = transform1[0];\n  var b1 = transform1[1];\n  var c1 = transform1[2];\n  var d1 = transform1[3];\n  var e1 = transform1[4];\n  var f1 = transform1[5];\n  var a2 = transform2[0];\n  var b2 = transform2[1];\n  var c2 = transform2[2];\n  var d2 = transform2[3];\n  var e2 = transform2[4];\n  var f2 = transform2[5];\n\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n\n  return transform1;\n};\n\n/**\n * Set the transform components a-f on a given transform.\n * @param {!ol.Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!ol.Transform} Matrix with transform applied.\n */\n_ol_transform_.set = function(transform, a, b, c, d, e, f) {\n  transform[0] = a;\n  transform[1] = b;\n  transform[2] = c;\n  transform[3] = d;\n  transform[4] = e;\n  transform[5] = f;\n  return transform;\n};\n\n\n/**\n * Set transform on one matrix from another matrix.\n * @param {!ol.Transform} transform1 Matrix to set transform to.\n * @param {!ol.Transform} transform2 Matrix to set transform from.\n * @return {!ol.Transform} transform1 with transform from transform2 applied.\n */\n_ol_transform_.setFromArray = function(transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n};\n\n\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {ol.Transform} transform The transformation.\n * @param {ol.Coordinate|ol.Pixel} coordinate The coordinate to transform.\n * @return {ol.Coordinate|ol.Pixel} return coordinate so that operations can be\n *     chained together.\n */\n_ol_transform_.apply = function(transform, coordinate) {\n  var x = coordinate[0], y = coordinate[1];\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n  return coordinate;\n};\n\n\n/**\n * Applies rotation to the given transform.\n * @param {!ol.Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!ol.Transform} The rotated transform.\n */\n_ol_transform_.rotate = function(transform, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  return _ol_transform_.multiply(transform,\n      _ol_transform_.set(_ol_transform_.tmp_, cos, sin, -sin, cos, 0, 0));\n};\n\n\n/**\n * Applies scale to a given transform.\n * @param {!ol.Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!ol.Transform} The scaled transform.\n */\n_ol_transform_.scale = function(transform, x, y) {\n  return _ol_transform_.multiply(transform,\n      _ol_transform_.set(_ol_transform_.tmp_, x, 0, 0, y, 0, 0));\n};\n\n\n/**\n * Applies translation to the given transform.\n * @param {!ol.Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!ol.Transform} The translated transform.\n */\n_ol_transform_.translate = function(transform, dx, dy) {\n  return _ol_transform_.multiply(transform,\n      _ol_transform_.set(_ol_transform_.tmp_, 1, 0, 0, 1, dx, dy));\n};\n\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!ol.Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!ol.Transform} The composite transform.\n */\n_ol_transform_.compose = function(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n  var sin = Math.sin(angle);\n  var cos = Math.cos(angle);\n  transform[0] = sx * cos;\n  transform[1] = sy * sin;\n  transform[2] = -sx * sin;\n  transform[3] = sy * cos;\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform;\n};\n\n\n/**\n * Invert the given transform.\n * @param {!ol.Transform} transform Transform.\n * @return {!ol.Transform} Inverse of the transform.\n */\n_ol_transform_.invert = function(transform) {\n  var det = _ol_transform_.determinant(transform);\n  _ol_asserts_.assert(det !== 0, 32); // Transformation matrix cannot be inverted\n\n  var a = transform[0];\n  var b = transform[1];\n  var c = transform[2];\n  var d = transform[3];\n  var e = transform[4];\n  var f = transform[5];\n\n  transform[0] = d / det;\n  transform[1] = -b / det;\n  transform[2] = -c / det;\n  transform[3] = a / det;\n  transform[4] = (c * f - d * e) / det;\n  transform[5] = -(a * f - b * e) / det;\n\n  return transform;\n};\n\n\n/**\n * Returns the determinant of the given matrix.\n * @param {!ol.Transform} mat Matrix.\n * @return {number} Determinant.\n */\n_ol_transform_.determinant = function(mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n};\nexport default _ol_transform_;\n"]},"metadata":{},"sourceType":"module"}
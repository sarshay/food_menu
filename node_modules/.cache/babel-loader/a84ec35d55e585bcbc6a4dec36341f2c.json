{"ast":null,"code":"import _ol_ from '../../index.js';\nimport _ol_color_ from '../../color.js';\nimport _ol_geom_flat_simplify_ from '../../geom/flat/simplify.js';\nimport _ol_render_canvas_ from '../canvas.js';\nimport _ol_render_canvas_Instruction_ from '../canvas/instruction.js';\nimport _ol_render_canvas_Replay_ from '../canvas/replay.js';\n/**\n * @constructor\n * @extends {ol.render.canvas.Replay}\n * @param {number} tolerance Tolerance.\n * @param {ol.Extent} maxExtent Maximum extent.\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {boolean} overlaps The replay can have overlapping geometries.\n * @param {?} declutterTree Declutter tree.\n * @struct\n */\n\nvar _ol_render_canvas_PolygonReplay_ = function (tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n  _ol_render_canvas_Replay_.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n};\n\n_ol_.inherits(_ol_render_canvas_PolygonReplay_, _ol_render_canvas_Replay_);\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @private\n * @return {number} End.\n */\n\n\n_ol_render_canvas_PolygonReplay_.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {\n  var state = this.state;\n  var fill = state.fillStyle !== undefined;\n  var stroke = state.strokeStyle != undefined;\n  var numEnds = ends.length;\n  var beginPathInstruction = [_ol_render_canvas_Instruction_.BEGIN_PATH];\n  this.instructions.push(beginPathInstruction);\n  this.hitDetectionInstructions.push(beginPathInstruction);\n\n  for (var i = 0; i < numEnds; ++i) {\n    var end = ends[i];\n    var myBegin = this.coordinates.length;\n    var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n    var moveToLineToInstruction = [_ol_render_canvas_Instruction_.MOVE_TO_LINE_TO, myBegin, myEnd];\n    this.instructions.push(moveToLineToInstruction);\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\n\n    if (stroke) {\n      // Performance optimization: only call closePath() when we have a stroke.\n      // Otherwise the ring is closed already (see appendFlatCoordinates above).\n      var closePathInstruction = [_ol_render_canvas_Instruction_.CLOSE_PATH];\n      this.instructions.push(closePathInstruction);\n      this.hitDetectionInstructions.push(closePathInstruction);\n    }\n\n    offset = end;\n  }\n\n  var fillInstruction = [_ol_render_canvas_Instruction_.FILL];\n  this.hitDetectionInstructions.push(fillInstruction);\n\n  if (fill) {\n    this.instructions.push(fillInstruction);\n  }\n\n  if (stroke) {\n    var strokeInstruction = [_ol_render_canvas_Instruction_.STROKE];\n    this.instructions.push(strokeInstruction);\n    this.hitDetectionInstructions.push(strokeInstruction);\n  }\n\n  return offset;\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_canvas_PolygonReplay_.prototype.drawCircle = function (circleGeometry, feature) {\n  var state = this.state;\n  var fillStyle = state.fillStyle;\n  var strokeStyle = state.strokeStyle;\n\n  if (fillStyle === undefined && strokeStyle === undefined) {\n    return;\n  }\n\n  this.setFillStrokeStyles_(circleGeometry);\n  this.beginGeometry(circleGeometry, feature); // always fill the circle for hit detection\n\n  this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_FILL_STYLE, _ol_color_.asString(_ol_render_canvas_.defaultFillStyle)]);\n\n  if (state.strokeStyle !== undefined) {\n    this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n  }\n\n  var flatCoordinates = circleGeometry.getFlatCoordinates();\n  var stride = circleGeometry.getStride();\n  var myBegin = this.coordinates.length;\n  this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n  var beginPathInstruction = [_ol_render_canvas_Instruction_.BEGIN_PATH];\n  var circleInstruction = [_ol_render_canvas_Instruction_.CIRCLE, myBegin];\n  this.instructions.push(beginPathInstruction, circleInstruction);\n  this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n  var fillInstruction = [_ol_render_canvas_Instruction_.FILL];\n  this.hitDetectionInstructions.push(fillInstruction);\n\n  if (state.fillStyle !== undefined) {\n    this.instructions.push(fillInstruction);\n  }\n\n  if (state.strokeStyle !== undefined) {\n    var strokeInstruction = [_ol_render_canvas_Instruction_.STROKE];\n    this.instructions.push(strokeInstruction);\n    this.hitDetectionInstructions.push(strokeInstruction);\n  }\n\n  this.endGeometry(circleGeometry, feature);\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_canvas_PolygonReplay_.prototype.drawPolygon = function (polygonGeometry, feature) {\n  var state = this.state;\n  this.setFillStrokeStyles_(polygonGeometry);\n  this.beginGeometry(polygonGeometry, feature); // always fill the polygon for hit detection\n\n  this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_FILL_STYLE, _ol_color_.asString(_ol_render_canvas_.defaultFillStyle)]);\n\n  if (state.strokeStyle !== undefined) {\n    this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n  }\n\n  var ends = polygonGeometry.getEnds();\n  var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n  var stride = polygonGeometry.getStride();\n  this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n  this.endGeometry(polygonGeometry, feature);\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_canvas_PolygonReplay_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {\n  var state = this.state;\n  var fillStyle = state.fillStyle;\n  var strokeStyle = state.strokeStyle;\n\n  if (fillStyle === undefined && strokeStyle === undefined) {\n    return;\n  }\n\n  this.setFillStrokeStyles_(multiPolygonGeometry);\n  this.beginGeometry(multiPolygonGeometry, feature); // always fill the multi-polygon for hit detection\n\n  this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_FILL_STYLE, _ol_color_.asString(_ol_render_canvas_.defaultFillStyle)]);\n\n  if (state.strokeStyle !== undefined) {\n    this.hitDetectionInstructions.push([_ol_render_canvas_Instruction_.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n  }\n\n  var endss = multiPolygonGeometry.getEndss();\n  var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n  var stride = multiPolygonGeometry.getStride();\n  var offset = 0;\n  var i, ii;\n\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n  }\n\n  this.endGeometry(multiPolygonGeometry, feature);\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_render_canvas_PolygonReplay_.prototype.finish = function () {\n  this.reverseHitDetectionInstructions();\n  this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n  // simplified using quantization and point elimination. However, we might\n  // have received a mix of quantized and non-quantized geometries, so ensure\n  // that all are quantized by quantizing all coordinates in the batch.\n\n  var tolerance = this.tolerance;\n\n  if (tolerance !== 0) {\n    var coordinates = this.coordinates;\n    var i, ii;\n\n    for (i = 0, ii = coordinates.length; i < ii; ++i) {\n      coordinates[i] = _ol_geom_flat_simplify_.snap(coordinates[i], tolerance);\n    }\n  }\n};\n/**\n * @private\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n */\n\n\n_ol_render_canvas_PolygonReplay_.prototype.setFillStrokeStyles_ = function (geometry) {\n  var state = this.state;\n  var fillStyle = state.fillStyle;\n\n  if (fillStyle !== undefined) {\n    this.updateFillStyle(state, this.applyFill, geometry);\n  }\n\n  if (state.strokeStyle !== undefined) {\n    this.updateStrokeStyle(state, this.applyStroke);\n  }\n};\n\nexport default _ol_render_canvas_PolygonReplay_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/render/canvas/polygonreplay.js"],"names":["_ol_","_ol_color_","_ol_geom_flat_simplify_","_ol_render_canvas_","_ol_render_canvas_Instruction_","_ol_render_canvas_Replay_","_ol_render_canvas_PolygonReplay_","tolerance","maxExtent","resolution","pixelRatio","overlaps","declutterTree","call","inherits","prototype","drawFlatCoordinatess_","flatCoordinates","offset","ends","stride","state","fill","fillStyle","undefined","stroke","strokeStyle","numEnds","length","beginPathInstruction","BEGIN_PATH","instructions","push","hitDetectionInstructions","i","end","myBegin","coordinates","myEnd","appendFlatCoordinates","moveToLineToInstruction","MOVE_TO_LINE_TO","closePathInstruction","CLOSE_PATH","fillInstruction","FILL","strokeInstruction","STROKE","drawCircle","circleGeometry","feature","setFillStrokeStyles_","beginGeometry","SET_FILL_STYLE","asString","defaultFillStyle","SET_STROKE_STYLE","lineWidth","lineCap","lineJoin","miterLimit","lineDash","lineDashOffset","getFlatCoordinates","getStride","circleInstruction","CIRCLE","endGeometry","drawPolygon","polygonGeometry","getEnds","getOrientedFlatCoordinates","drawMultiPolygon","multiPolygonGeometry","endss","getEndss","ii","finish","reverseHitDetectionInstructions","snap","geometry","updateFillStyle","applyFill","updateStrokeStyle","applyStroke"],"mappings":"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","sourcesContent":["import _ol_ from '../../index.js';\nimport _ol_color_ from '../../color.js';\nimport _ol_geom_flat_simplify_ from '../../geom/flat/simplify.js';\nimport _ol_render_canvas_ from '../canvas.js';\nimport _ol_render_canvas_Instruction_ from '../canvas/instruction.js';\nimport _ol_render_canvas_Replay_ from '../canvas/replay.js';\n\n/**\n * @constructor\n * @extends {ol.render.canvas.Replay}\n * @param {number} tolerance Tolerance.\n * @param {ol.Extent} maxExtent Maximum extent.\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {boolean} overlaps The replay can have overlapping geometries.\n * @param {?} declutterTree Declutter tree.\n * @struct\n */\nvar _ol_render_canvas_PolygonReplay_ = function(\n    tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n  _ol_render_canvas_Replay_.call(this,\n      tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n};\n\n_ol_.inherits(_ol_render_canvas_PolygonReplay_, _ol_render_canvas_Replay_);\n\n\n/**\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {number} stride Stride.\n * @private\n * @return {number} End.\n */\n_ol_render_canvas_PolygonReplay_.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset, ends, stride) {\n  var state = this.state;\n  var fill = state.fillStyle !== undefined;\n  var stroke = state.strokeStyle != undefined;\n  var numEnds = ends.length;\n  var beginPathInstruction = [_ol_render_canvas_Instruction_.BEGIN_PATH];\n  this.instructions.push(beginPathInstruction);\n  this.hitDetectionInstructions.push(beginPathInstruction);\n  for (var i = 0; i < numEnds; ++i) {\n    var end = ends[i];\n    var myBegin = this.coordinates.length;\n    var myEnd = this.appendFlatCoordinates(\n        flatCoordinates, offset, end, stride, true, !stroke);\n    var moveToLineToInstruction =\n        [_ol_render_canvas_Instruction_.MOVE_TO_LINE_TO, myBegin, myEnd];\n    this.instructions.push(moveToLineToInstruction);\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\n    if (stroke) {\n      // Performance optimization: only call closePath() when we have a stroke.\n      // Otherwise the ring is closed already (see appendFlatCoordinates above).\n      var closePathInstruction = [_ol_render_canvas_Instruction_.CLOSE_PATH];\n      this.instructions.push(closePathInstruction);\n      this.hitDetectionInstructions.push(closePathInstruction);\n    }\n    offset = end;\n  }\n  var fillInstruction = [_ol_render_canvas_Instruction_.FILL];\n  this.hitDetectionInstructions.push(fillInstruction);\n  if (fill) {\n    this.instructions.push(fillInstruction);\n  }\n  if (stroke) {\n    var strokeInstruction = [_ol_render_canvas_Instruction_.STROKE];\n    this.instructions.push(strokeInstruction);\n    this.hitDetectionInstructions.push(strokeInstruction);\n  }\n  return offset;\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_canvas_PolygonReplay_.prototype.drawCircle = function(circleGeometry, feature) {\n  var state = this.state;\n  var fillStyle = state.fillStyle;\n  var strokeStyle = state.strokeStyle;\n  if (fillStyle === undefined && strokeStyle === undefined) {\n    return;\n  }\n  this.setFillStrokeStyles_(circleGeometry);\n  this.beginGeometry(circleGeometry, feature);\n  // always fill the circle for hit detection\n  this.hitDetectionInstructions.push([\n    _ol_render_canvas_Instruction_.SET_FILL_STYLE,\n    _ol_color_.asString(_ol_render_canvas_.defaultFillStyle)\n  ]);\n  if (state.strokeStyle !== undefined) {\n    this.hitDetectionInstructions.push([\n      _ol_render_canvas_Instruction_.SET_STROKE_STYLE,\n      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n      state.miterLimit, state.lineDash, state.lineDashOffset\n    ]);\n  }\n  var flatCoordinates = circleGeometry.getFlatCoordinates();\n  var stride = circleGeometry.getStride();\n  var myBegin = this.coordinates.length;\n  this.appendFlatCoordinates(\n      flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n  var beginPathInstruction = [_ol_render_canvas_Instruction_.BEGIN_PATH];\n  var circleInstruction = [_ol_render_canvas_Instruction_.CIRCLE, myBegin];\n  this.instructions.push(beginPathInstruction, circleInstruction);\n  this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n  var fillInstruction = [_ol_render_canvas_Instruction_.FILL];\n  this.hitDetectionInstructions.push(fillInstruction);\n  if (state.fillStyle !== undefined) {\n    this.instructions.push(fillInstruction);\n  }\n  if (state.strokeStyle !== undefined) {\n    var strokeInstruction = [_ol_render_canvas_Instruction_.STROKE];\n    this.instructions.push(strokeInstruction);\n    this.hitDetectionInstructions.push(strokeInstruction);\n  }\n  this.endGeometry(circleGeometry, feature);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_canvas_PolygonReplay_.prototype.drawPolygon = function(polygonGeometry, feature) {\n  var state = this.state;\n  this.setFillStrokeStyles_(polygonGeometry);\n  this.beginGeometry(polygonGeometry, feature);\n  // always fill the polygon for hit detection\n  this.hitDetectionInstructions.push([\n    _ol_render_canvas_Instruction_.SET_FILL_STYLE,\n    _ol_color_.asString(_ol_render_canvas_.defaultFillStyle)]\n  );\n  if (state.strokeStyle !== undefined) {\n    this.hitDetectionInstructions.push([\n      _ol_render_canvas_Instruction_.SET_STROKE_STYLE,\n      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n      state.miterLimit, state.lineDash, state.lineDashOffset\n    ]);\n  }\n  var ends = polygonGeometry.getEnds();\n  var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n  var stride = polygonGeometry.getStride();\n  this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n  this.endGeometry(polygonGeometry, feature);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_canvas_PolygonReplay_.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {\n  var state = this.state;\n  var fillStyle = state.fillStyle;\n  var strokeStyle = state.strokeStyle;\n  if (fillStyle === undefined && strokeStyle === undefined) {\n    return;\n  }\n  this.setFillStrokeStyles_(multiPolygonGeometry);\n  this.beginGeometry(multiPolygonGeometry, feature);\n  // always fill the multi-polygon for hit detection\n  this.hitDetectionInstructions.push([\n    _ol_render_canvas_Instruction_.SET_FILL_STYLE,\n    _ol_color_.asString(_ol_render_canvas_.defaultFillStyle)\n  ]);\n  if (state.strokeStyle !== undefined) {\n    this.hitDetectionInstructions.push([\n      _ol_render_canvas_Instruction_.SET_STROKE_STYLE,\n      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,\n      state.miterLimit, state.lineDash, state.lineDashOffset\n    ]);\n  }\n  var endss = multiPolygonGeometry.getEndss();\n  var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n  var stride = multiPolygonGeometry.getStride();\n  var offset = 0;\n  var i, ii;\n  for (i = 0, ii = endss.length; i < ii; ++i) {\n    offset = this.drawFlatCoordinatess_(\n        flatCoordinates, offset, endss[i], stride);\n  }\n  this.endGeometry(multiPolygonGeometry, feature);\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_render_canvas_PolygonReplay_.prototype.finish = function() {\n  this.reverseHitDetectionInstructions();\n  this.state = null;\n  // We want to preserve topology when drawing polygons.  Polygons are\n  // simplified using quantization and point elimination. However, we might\n  // have received a mix of quantized and non-quantized geometries, so ensure\n  // that all are quantized by quantizing all coordinates in the batch.\n  var tolerance = this.tolerance;\n  if (tolerance !== 0) {\n    var coordinates = this.coordinates;\n    var i, ii;\n    for (i = 0, ii = coordinates.length; i < ii; ++i) {\n      coordinates[i] = _ol_geom_flat_simplify_.snap(coordinates[i], tolerance);\n    }\n  }\n};\n\n\n/**\n * @private\n * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.\n */\n_ol_render_canvas_PolygonReplay_.prototype.setFillStrokeStyles_ = function(geometry) {\n  var state = this.state;\n  var fillStyle = state.fillStyle;\n  if (fillStyle !== undefined) {\n    this.updateFillStyle(state, this.applyFill, geometry);\n  }\n  if (state.strokeStyle !== undefined) {\n    this.updateStrokeStyle(state, this.applyStroke);\n  }\n};\nexport default _ol_render_canvas_PolygonReplay_;\n"]},"metadata":{},"sourceType":"module"}
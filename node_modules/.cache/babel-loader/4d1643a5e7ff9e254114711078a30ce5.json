{"ast":null,"code":"/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable } from '../style/expressions.js';\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\n\nvar ShaderBuilder =\n/** @class */\nfunction () {\n  function ShaderBuilder() {\n    /**\n     * Uniforms; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n    this.uniforms = [];\n    /**\n     * Attributes; these will be declared in the header (should include the type).\n     * @type {Array<string>}\n     * @private\n     */\n\n    this.attributes = [];\n    /**\n     * Varyings with a name, a type and an expression.\n     * @type {Array<VaryingDescription>}\n     * @private\n     */\n\n    this.varyings = [];\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.sizeExpression = 'vec2(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.rotationExpression = '0.0';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.offsetExpression = 'vec2(0.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.colorExpression = 'vec4(1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.discardExpression = 'false';\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.rotateWithView = false;\n  }\n  /**\n   * Adds a uniform accessible in both fragment and vertex shaders.\n   * The given name should include a type, such as `sampler2D u_texture`.\n   * @param {string} name Uniform name\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.addUniform = function (name) {\n    this.uniforms.push(name);\n    return this;\n  };\n  /**\n   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n   * The given name should include a type, such as `vec2 a_position`.\n   * @param {string} name Attribute name\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.addAttribute = function (name) {\n    this.attributes.push(name);\n    return this;\n  };\n  /**\n   * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n   * The type and expression of the varying have to be specified separately.\n   * @param {string} name Varying name\n   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n   * @param {string} expression Expression used to assign a value to the varying.\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.addVarying = function (name, type, expression) {\n    this.varyings.push({\n      name: name,\n      type: type,\n      expression: expression\n    });\n    return this;\n  };\n  /**\n   * Sets an expression to compute the size of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setSizeExpression = function (expression) {\n    this.sizeExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the rotation of the shape.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `float` value in radians.\n   * @param {string} expression Size expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setRotationExpression = function (expression) {\n    this.rotationExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the offset of the symbol from the point center.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec2` value.\n   * Note: will only be used for point geometry shaders.\n   * @param {string} expression Offset expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setSymbolOffsetExpression = function (expression) {\n    this.offsetExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the color of the shape.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Color expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setColorExpression = function (expression) {\n    this.colorExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to compute the texture coordinates of the vertices.\n   * This expression can use all the uniforms and attributes available\n   * in the vertex shader, and should evaluate to a `vec4` value.\n   * @param {string} expression Texture coordinate expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setTextureCoordinateExpression = function (expression) {\n    this.texCoordExpression = expression;\n    return this;\n  };\n  /**\n   * Sets an expression to determine whether a fragment (pixel) should be discarded,\n   * i.e. not drawn at all.\n   * This expression can use all the uniforms, varyings and attributes available\n   * in the fragment shader, and should evaluate to a `bool` value (it will be\n   * used in an `if` statement)\n   * @param {string} expression Fragment discard expression\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setFragmentDiscardExpression = function (expression) {\n    this.discardExpression = expression;\n    return this;\n  };\n  /**\n   * Sets whether the symbols should rotate with the view or stay aligned with the map.\n   * Note: will only be used for point geometry shaders.\n   * @param {boolean} rotateWithView Rotate with view\n   * @return {ShaderBuilder} the builder object\n   */\n\n\n  ShaderBuilder.prototype.setSymbolRotateWithView = function (rotateWithView) {\n    this.rotateWithView = rotateWithView;\n    return this;\n  };\n  /**\n   * @return {string} Previously set size expression\n   */\n\n\n  ShaderBuilder.prototype.getSizeExpression = function () {\n    return this.sizeExpression;\n  };\n  /**\n   * @return {string} Previously set symbol offset expression\n   */\n\n\n  ShaderBuilder.prototype.getOffsetExpression = function () {\n    return this.offsetExpression;\n  };\n  /**\n   * @return {string} Previously set color expression\n   */\n\n\n  ShaderBuilder.prototype.getColorExpression = function () {\n    return this.colorExpression;\n  };\n  /**\n   * @return {string} Previously set texture coordinate expression\n   */\n\n\n  ShaderBuilder.prototype.getTextureCoordinateExpression = function () {\n    return this.texCoordExpression;\n  };\n  /**\n   * @return {string} Previously set fragment discard expression\n   */\n\n\n  ShaderBuilder.prototype.getFragmentDiscardExpression = function () {\n    return this.discardExpression;\n  };\n  /**\n   * Generates a symbol vertex shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n   * `u_offsetRotateMatrix`, `u_time`.\n   *\n   * The following attributes are hardcoded and expected to be present in the vertex buffers:\n   * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n   *\n   * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n\n\n  ShaderBuilder.prototype.getSymbolVertexShader = function (forHitDetection) {\n    var offsetMatrix = this.rotateWithView ? 'u_offsetScaleMatrix * u_offsetRotateMatrix' : 'u_offsetScaleMatrix';\n    var attributes = this.attributes;\n    var varyings = this.varyings;\n\n    if (forHitDetection) {\n      attributes = attributes.concat('vec4 a_hitColor');\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n\n    return \"precision mediump float;\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\" + this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n') + \"\\nattribute vec2 a_position;\\nattribute float a_index;\\n\" + attributes.map(function (attribute) {\n      return 'attribute ' + attribute + ';';\n    }).join('\\n') + \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\" + varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n') + \"\\nvoid main(void) {\\n  mat4 offsetMatrix = \" + offsetMatrix + \";\\n  vec2 halfSize = \" + this.sizeExpression + \" * 0.5;\\n  vec2 offset = \" + this.offsetExpression + \";\\n  float angle = \" + this.rotationExpression + \";\\n  float offsetX;\\n  float offsetY;\\n  if (a_index == 0.0) {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  } else if (a_index == 1.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else if (a_index == 2.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  }\\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n  vec4 texCoord = \" + this.texCoordExpression + \";\\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\\n  v_texCoord = vec2(u, v);\\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v_quadCoord = vec2(u, v);\\n\" + varyings.map(function (varying) {\n      return '  ' + varying.name + ' = ' + varying.expression + ';';\n    }).join('\\n') + \"\\n}\";\n  };\n  /**\n   * Generates a symbol fragment shader from the builder parameters,\n   * intended to be used on point geometries.\n   *\n   * Expects the following varyings to be transmitted by the vertex shader:\n   * `vec2 v_quadCoord`, `vec2 v_texCoord`\n   *\n   * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n   * (namely, hit color with encoded feature id).\n   * @return {string} The full shader as a string.\n   */\n\n\n  ShaderBuilder.prototype.getSymbolFragmentShader = function (forHitDetection) {\n    var hitDetectionBypass = forHitDetection ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;' : '';\n    var varyings = this.varyings;\n\n    if (forHitDetection) {\n      varyings = varyings.concat({\n        name: 'v_hitColor',\n        type: 'vec4',\n        expression: 'a_hitColor'\n      });\n    }\n\n    return \"precision mediump float;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\" + this.uniforms.map(function (uniform) {\n      return 'uniform ' + uniform + ';';\n    }).join('\\n') + \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\" + varyings.map(function (varying) {\n      return 'varying ' + varying.type + ' ' + varying.name + ';';\n    }).join('\\n') + \"\\nvoid main(void) {\\n  if (\" + this.discardExpression + \") { discard; }\\n  gl_FragColor = \" + this.colorExpression + \";\\n  gl_FragColor.rgb *= gl_FragColor.a;\\n\" + hitDetectionBypass + \"\\n}\";\n  };\n\n  return ShaderBuilder;\n}();\n\nexport { ShaderBuilder };\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\n\nexport function parseLiteralStyle(style) {\n  var symbStyle = style.symbol;\n  var size = symbStyle.size !== undefined ? symbStyle.size : 1;\n  var color = symbStyle.color || 'white';\n  var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n  var offset = symbStyle.offset || [0, 0];\n  var opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n  var rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n\n  var vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    stringLiteralsMap: {}\n  };\n  var parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n  var parsedOffset = expressionToGlsl(vertContext, offset, ValueTypes.NUMBER_ARRAY);\n  var parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);\n  var parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n\n  var fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    stringLiteralsMap: vertContext.stringLiteralsMap\n  };\n  var parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n  var parsedOpacity = expressionToGlsl(fragContext, opacity, ValueTypes.NUMBER);\n  var opacityFilter = '1.0';\n  var visibleSize = \"vec2(\" + expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER) + \").x\";\n\n  switch (symbStyle.symbolType) {\n    case 'square':\n      break;\n\n    case 'image':\n      break;\n    // taken from https://thebookofshaders.com/07/\n\n    case 'circle':\n      opacityFilter = \"(1.0-smoothstep(1.-4./\" + visibleSize + \",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))\";\n      break;\n\n    case 'triangle':\n      var st = '(v_quadCoord*2.-1.)';\n      var a = \"(atan(\" + st + \".x,\" + st + \".y))\";\n      opacityFilter = \"(1.0-smoothstep(.5-3./\" + visibleSize + \",.5,cos(floor(.5+\" + a + \"/2.094395102)*2.094395102-\" + a + \")*length(\" + st + \")))\";\n      break;\n\n    default:\n      throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n  }\n\n  var builder = new ShaderBuilder().setSizeExpression(\"vec2(\" + parsedSize + \")\").setRotationExpression(parsedRotation).setSymbolOffsetExpression(parsedOffset).setTextureCoordinateExpression(parsedTexCoord).setSymbolRotateWithView(!!symbStyle.rotateWithView).setColorExpression(\"vec4(\" + parsedColor + \".rgb, \" + parsedColor + \".a * \" + parsedOpacity + \" * \" + opacityFilter + \")\");\n\n  if (style.filter) {\n    var parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(\"!\" + parsedFilter);\n  }\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n\n\n  var uniforms = {}; // define one uniform per variable\n\n  fragContext.variables.forEach(function (varName) {\n    var uniformName = uniformNameForVariable(varName);\n    builder.addUniform(\"float \" + uniformName);\n\n    uniforms[uniformName] = function () {\n      if (!style.variables || style.variables[varName] === undefined) {\n        throw new Error(\"The following variable is missing from the style: \" + varName);\n      }\n\n      var value = style.variables[varName];\n\n      if (typeof value === 'string') {\n        value = getStringNumberEquivalent(vertContext, value);\n      }\n\n      return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n    };\n  });\n\n  if (symbStyle.symbolType === 'image' && symbStyle.src) {\n    var texture = new Image();\n    texture.src = symbStyle.src;\n    builder.addUniform('sampler2D u_texture').setColorExpression(builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)');\n    uniforms['u_texture'] = texture;\n  } // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n\n\n  fragContext.attributes.forEach(function (attrName) {\n    if (vertContext.attributes.indexOf(attrName) === -1) {\n      vertContext.attributes.push(attrName);\n    }\n\n    builder.addVarying(\"v_\" + attrName, 'float', \"a_\" + attrName);\n  }); // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n\n  vertContext.attributes.forEach(function (attrName) {\n    builder.addAttribute(\"float a_\" + attrName);\n  });\n  return {\n    builder: builder,\n    attributes: vertContext.attributes.map(function (attributeName) {\n      return {\n        name: attributeName,\n        callback: function (feature, props) {\n          var value = props[attributeName];\n\n          if (typeof value === 'string') {\n            value = getStringNumberEquivalent(vertContext, value);\n          }\n\n          return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        }\n      };\n    }),\n    uniforms: uniforms\n  };\n}","map":{"version":3,"sources":["../src/webgl/ShaderBuilder.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Classes and utilities for generating shaders from literal style objects\n * @module ol/webgl/ShaderBuilder\n */\nimport { ValueTypes, expressionToGlsl, getStringNumberEquivalent, uniformNameForVariable, } from '../style/expressions.js';\n/**\n * @typedef {Object} VaryingDescription\n * @property {string} name Varying name, as will be declared in the header.\n * @property {string} type Varying type, either `float`, `vec2`, `vec4`...\n * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and\n * passed on to the fragment shader.\n */\n/**\n * @classdesc\n * This class implements a classic builder pattern for generating many different types of shaders.\n * Methods can be chained, e. g.:\n *\n * ```js\n * const shader = new ShaderBuilder()\n *   .addVarying('v_width', 'float', 'a_width')\n *   .addUniform('u_time')\n *   .setColorExpression('...')\n *   .setSizeExpression('...')\n *   .outputSymbolFragmentShader();\n * ```\n */\nvar ShaderBuilder = /** @class */ (function () {\n    function ShaderBuilder() {\n        /**\n         * Uniforms; these will be declared in the header (should include the type).\n         * @type {Array<string>}\n         * @private\n         */\n        this.uniforms = [];\n        /**\n         * Attributes; these will be declared in the header (should include the type).\n         * @type {Array<string>}\n         * @private\n         */\n        this.attributes = [];\n        /**\n         * Varyings with a name, a type and an expression.\n         * @type {Array<VaryingDescription>}\n         * @private\n         */\n        this.varyings = [];\n        /**\n         * @type {string}\n         * @private\n         */\n        this.sizeExpression = 'vec2(1.0)';\n        /**\n         * @type {string}\n         * @private\n         */\n        this.rotationExpression = '0.0';\n        /**\n         * @type {string}\n         * @private\n         */\n        this.offsetExpression = 'vec2(0.0)';\n        /**\n         * @type {string}\n         * @private\n         */\n        this.colorExpression = 'vec4(1.0)';\n        /**\n         * @type {string}\n         * @private\n         */\n        this.texCoordExpression = 'vec4(0.0, 0.0, 1.0, 1.0)';\n        /**\n         * @type {string}\n         * @private\n         */\n        this.discardExpression = 'false';\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.rotateWithView = false;\n    }\n    /**\n     * Adds a uniform accessible in both fragment and vertex shaders.\n     * The given name should include a type, such as `sampler2D u_texture`.\n     * @param {string} name Uniform name\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.addUniform = function (name) {\n        this.uniforms.push(name);\n        return this;\n    };\n    /**\n     * Adds an attribute accessible in the vertex shader, read from the geometry buffer.\n     * The given name should include a type, such as `vec2 a_position`.\n     * @param {string} name Attribute name\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.addAttribute = function (name) {\n        this.attributes.push(name);\n        return this;\n    };\n    /**\n     * Adds a varying defined in the vertex shader and accessible from the fragment shader.\n     * The type and expression of the varying have to be specified separately.\n     * @param {string} name Varying name\n     * @param {'float'|'vec2'|'vec3'|'vec4'} type Type\n     * @param {string} expression Expression used to assign a value to the varying.\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.addVarying = function (name, type, expression) {\n        this.varyings.push({\n            name: name,\n            type: type,\n            expression: expression,\n        });\n        return this;\n    };\n    /**\n     * Sets an expression to compute the size of the shape.\n     * This expression can use all the uniforms and attributes available\n     * in the vertex shader, and should evaluate to a `vec2` value.\n     * @param {string} expression Size expression\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.setSizeExpression = function (expression) {\n        this.sizeExpression = expression;\n        return this;\n    };\n    /**\n     * Sets an expression to compute the rotation of the shape.\n     * This expression can use all the uniforms and attributes available\n     * in the vertex shader, and should evaluate to a `float` value in radians.\n     * @param {string} expression Size expression\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.setRotationExpression = function (expression) {\n        this.rotationExpression = expression;\n        return this;\n    };\n    /**\n     * Sets an expression to compute the offset of the symbol from the point center.\n     * This expression can use all the uniforms and attributes available\n     * in the vertex shader, and should evaluate to a `vec2` value.\n     * Note: will only be used for point geometry shaders.\n     * @param {string} expression Offset expression\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.setSymbolOffsetExpression = function (expression) {\n        this.offsetExpression = expression;\n        return this;\n    };\n    /**\n     * Sets an expression to compute the color of the shape.\n     * This expression can use all the uniforms, varyings and attributes available\n     * in the fragment shader, and should evaluate to a `vec4` value.\n     * @param {string} expression Color expression\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.setColorExpression = function (expression) {\n        this.colorExpression = expression;\n        return this;\n    };\n    /**\n     * Sets an expression to compute the texture coordinates of the vertices.\n     * This expression can use all the uniforms and attributes available\n     * in the vertex shader, and should evaluate to a `vec4` value.\n     * @param {string} expression Texture coordinate expression\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.setTextureCoordinateExpression = function (expression) {\n        this.texCoordExpression = expression;\n        return this;\n    };\n    /**\n     * Sets an expression to determine whether a fragment (pixel) should be discarded,\n     * i.e. not drawn at all.\n     * This expression can use all the uniforms, varyings and attributes available\n     * in the fragment shader, and should evaluate to a `bool` value (it will be\n     * used in an `if` statement)\n     * @param {string} expression Fragment discard expression\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.setFragmentDiscardExpression = function (expression) {\n        this.discardExpression = expression;\n        return this;\n    };\n    /**\n     * Sets whether the symbols should rotate with the view or stay aligned with the map.\n     * Note: will only be used for point geometry shaders.\n     * @param {boolean} rotateWithView Rotate with view\n     * @return {ShaderBuilder} the builder object\n     */\n    ShaderBuilder.prototype.setSymbolRotateWithView = function (rotateWithView) {\n        this.rotateWithView = rotateWithView;\n        return this;\n    };\n    /**\n     * @return {string} Previously set size expression\n     */\n    ShaderBuilder.prototype.getSizeExpression = function () {\n        return this.sizeExpression;\n    };\n    /**\n     * @return {string} Previously set symbol offset expression\n     */\n    ShaderBuilder.prototype.getOffsetExpression = function () {\n        return this.offsetExpression;\n    };\n    /**\n     * @return {string} Previously set color expression\n     */\n    ShaderBuilder.prototype.getColorExpression = function () {\n        return this.colorExpression;\n    };\n    /**\n     * @return {string} Previously set texture coordinate expression\n     */\n    ShaderBuilder.prototype.getTextureCoordinateExpression = function () {\n        return this.texCoordExpression;\n    };\n    /**\n     * @return {string} Previously set fragment discard expression\n     */\n    ShaderBuilder.prototype.getFragmentDiscardExpression = function () {\n        return this.discardExpression;\n    };\n    /**\n     * Generates a symbol vertex shader from the builder parameters,\n     * intended to be used on point geometries.\n     *\n     * Three uniforms are hardcoded in all shaders: `u_projectionMatrix`, `u_offsetScaleMatrix`,\n     * `u_offsetRotateMatrix`, `u_time`.\n     *\n     * The following attributes are hardcoded and expected to be present in the vertex buffers:\n     * `vec2 a_position`, `float a_index` (being the index of the vertex in the quad, 0 to 3).\n     *\n     * The following varyings are hardcoded and gives the coordinate of the pixel both in the quad and on the texture:\n     * `vec2 v_quadCoord`, `vec2 v_texCoord`\n     *\n     * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n     * (namely, hit color with encoded feature id).\n     * @return {string} The full shader as a string.\n     */\n    ShaderBuilder.prototype.getSymbolVertexShader = function (forHitDetection) {\n        var offsetMatrix = this.rotateWithView\n            ? 'u_offsetScaleMatrix * u_offsetRotateMatrix'\n            : 'u_offsetScaleMatrix';\n        var attributes = this.attributes;\n        var varyings = this.varyings;\n        if (forHitDetection) {\n            attributes = attributes.concat('vec4 a_hitColor');\n            varyings = varyings.concat({\n                name: 'v_hitColor',\n                type: 'vec4',\n                expression: 'a_hitColor',\n            });\n        }\n        return \"precision mediump float;\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_offsetScaleMatrix;\\nuniform mat4 u_offsetRotateMatrix;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\" + this.uniforms\n            .map(function (uniform) {\n            return 'uniform ' + uniform + ';';\n        })\n            .join('\\n') + \"\\nattribute vec2 a_position;\\nattribute float a_index;\\n\" + attributes\n            .map(function (attribute) {\n            return 'attribute ' + attribute + ';';\n        })\n            .join('\\n') + \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\" + varyings\n            .map(function (varying) {\n            return 'varying ' + varying.type + ' ' + varying.name + ';';\n        })\n            .join('\\n') + \"\\nvoid main(void) {\\n  mat4 offsetMatrix = \" + offsetMatrix + \";\\n  vec2 halfSize = \" + this.sizeExpression + \" * 0.5;\\n  vec2 offset = \" + this.offsetExpression + \";\\n  float angle = \" + this.rotationExpression + \";\\n  float offsetX;\\n  float offsetY;\\n  if (a_index == 0.0) {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  } else if (a_index == 1.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y - halfSize.y) * sin(angle);\\n    offsetY = (offset.y - halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else if (a_index == 2.0) {\\n    offsetX = (offset.x + halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x + halfSize.x) * sin(angle);\\n  } else {\\n    offsetX = (offset.x - halfSize.x) * cos(angle) + (offset.y + halfSize.y) * sin(angle);\\n    offsetY = (offset.y + halfSize.y) * cos(angle) - (offset.x - halfSize.x) * sin(angle);\\n  }\\n  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n  vec4 texCoord = \" + this.texCoordExpression + \";\\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\\n  v_texCoord = vec2(u, v);\\n  u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v = a_index == 2.0 || a_index == 3.0 ? 0.0 : 1.0;\\n  v_quadCoord = vec2(u, v);\\n\" + varyings\n            .map(function (varying) {\n            return '  ' + varying.name + ' = ' + varying.expression + ';';\n        })\n            .join('\\n') + \"\\n}\";\n    };\n    /**\n     * Generates a symbol fragment shader from the builder parameters,\n     * intended to be used on point geometries.\n     *\n     * Expects the following varyings to be transmitted by the vertex shader:\n     * `vec2 v_quadCoord`, `vec2 v_texCoord`\n     *\n     * @param {boolean} [forHitDetection] If true, the shader will be modified to include hit detection variables\n     * (namely, hit color with encoded feature id).\n     * @return {string} The full shader as a string.\n     */\n    ShaderBuilder.prototype.getSymbolFragmentShader = function (forHitDetection) {\n        var hitDetectionBypass = forHitDetection\n            ? '  if (gl_FragColor.a < 0.1) { discard; } gl_FragColor = v_hitColor;'\n            : '';\n        var varyings = this.varyings;\n        if (forHitDetection) {\n            varyings = varyings.concat({\n                name: 'v_hitColor',\n                type: 'vec4',\n                expression: 'a_hitColor',\n            });\n        }\n        return \"precision mediump float;\\nuniform float u_time;\\nuniform float u_zoom;\\nuniform float u_resolution;\\n\" + this.uniforms\n            .map(function (uniform) {\n            return 'uniform ' + uniform + ';';\n        })\n            .join('\\n') + \"\\nvarying vec2 v_texCoord;\\nvarying vec2 v_quadCoord;\\n\" + varyings\n            .map(function (varying) {\n            return 'varying ' + varying.type + ' ' + varying.name + ';';\n        })\n            .join('\\n') + \"\\nvoid main(void) {\\n  if (\" + this.discardExpression + \") { discard; }\\n  gl_FragColor = \" + this.colorExpression + \";\\n  gl_FragColor.rgb *= gl_FragColor.a;\\n\" + hitDetectionBypass + \"\\n}\";\n    };\n    return ShaderBuilder;\n}());\nexport { ShaderBuilder };\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {Object<string,import(\"./Helper\").UniformValue>} uniforms Uniform definitions.\n * @property {Array<import(\"../renderer/webgl/PointsLayer\").CustomAttribute>} attributes Attribute descriptions.\n */\n/**\n * Parses a {@link import(\"../style/literal\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n    var symbStyle = style.symbol;\n    var size = symbStyle.size !== undefined ? symbStyle.size : 1;\n    var color = symbStyle.color || 'white';\n    var texCoord = symbStyle.textureCoord || [0, 0, 1, 1];\n    var offset = symbStyle.offset || [0, 0];\n    var opacity = symbStyle.opacity !== undefined ? symbStyle.opacity : 1;\n    var rotation = symbStyle.rotation !== undefined ? symbStyle.rotation : 0;\n    /**\n     * @type {import(\"../style/expressions.js\").ParsingContext}\n     */\n    var vertContext = {\n        inFragmentShader: false,\n        variables: [],\n        attributes: [],\n        stringLiteralsMap: {},\n    };\n    var parsedSize = expressionToGlsl(vertContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER);\n    var parsedOffset = expressionToGlsl(vertContext, offset, ValueTypes.NUMBER_ARRAY);\n    var parsedTexCoord = expressionToGlsl(vertContext, texCoord, ValueTypes.NUMBER_ARRAY);\n    var parsedRotation = expressionToGlsl(vertContext, rotation, ValueTypes.NUMBER);\n    /**\n     * @type {import(\"../style/expressions.js\").ParsingContext}\n     */\n    var fragContext = {\n        inFragmentShader: true,\n        variables: vertContext.variables,\n        attributes: [],\n        stringLiteralsMap: vertContext.stringLiteralsMap,\n    };\n    var parsedColor = expressionToGlsl(fragContext, color, ValueTypes.COLOR);\n    var parsedOpacity = expressionToGlsl(fragContext, opacity, ValueTypes.NUMBER);\n    var opacityFilter = '1.0';\n    var visibleSize = \"vec2(\" + expressionToGlsl(fragContext, size, ValueTypes.NUMBER_ARRAY | ValueTypes.NUMBER) + \").x\";\n    switch (symbStyle.symbolType) {\n        case 'square':\n            break;\n        case 'image':\n            break;\n        // taken from https://thebookofshaders.com/07/\n        case 'circle':\n            opacityFilter = \"(1.0-smoothstep(1.-4./\" + visibleSize + \",1.,dot(v_quadCoord-.5,v_quadCoord-.5)*4.))\";\n            break;\n        case 'triangle':\n            var st = '(v_quadCoord*2.-1.)';\n            var a = \"(atan(\" + st + \".x,\" + st + \".y))\";\n            opacityFilter = \"(1.0-smoothstep(.5-3./\" + visibleSize + \",.5,cos(floor(.5+\" + a + \"/2.094395102)*2.094395102-\" + a + \")*length(\" + st + \")))\";\n            break;\n        default:\n            throw new Error('Unexpected symbol type: ' + symbStyle.symbolType);\n    }\n    var builder = new ShaderBuilder()\n        .setSizeExpression(\"vec2(\" + parsedSize + \")\")\n        .setRotationExpression(parsedRotation)\n        .setSymbolOffsetExpression(parsedOffset)\n        .setTextureCoordinateExpression(parsedTexCoord)\n        .setSymbolRotateWithView(!!symbStyle.rotateWithView)\n        .setColorExpression(\"vec4(\" + parsedColor + \".rgb, \" + parsedColor + \".a * \" + parsedOpacity + \" * \" + opacityFilter + \")\");\n    if (style.filter) {\n        var parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);\n        builder.setFragmentDiscardExpression(\"!\" + parsedFilter);\n    }\n    /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n    var uniforms = {};\n    // define one uniform per variable\n    fragContext.variables.forEach(function (varName) {\n        var uniformName = uniformNameForVariable(varName);\n        builder.addUniform(\"float \" + uniformName);\n        uniforms[uniformName] = function () {\n            if (!style.variables || style.variables[varName] === undefined) {\n                throw new Error(\"The following variable is missing from the style: \" + varName);\n            }\n            var value = style.variables[varName];\n            if (typeof value === 'string') {\n                value = getStringNumberEquivalent(vertContext, value);\n            }\n            return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n        };\n    });\n    if (symbStyle.symbolType === 'image' && symbStyle.src) {\n        var texture = new Image();\n        texture.src = symbStyle.src;\n        builder\n            .addUniform('sampler2D u_texture')\n            .setColorExpression(builder.getColorExpression() + ' * texture2D(u_texture, v_texCoord)');\n        uniforms['u_texture'] = texture;\n    }\n    // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n    // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n    fragContext.attributes.forEach(function (attrName) {\n        if (vertContext.attributes.indexOf(attrName) === -1) {\n            vertContext.attributes.push(attrName);\n        }\n        builder.addVarying(\"v_\" + attrName, 'float', \"a_\" + attrName);\n    });\n    // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n    vertContext.attributes.forEach(function (attrName) {\n        builder.addAttribute(\"float a_\" + attrName);\n    });\n    return {\n        builder: builder,\n        attributes: vertContext.attributes.map(function (attributeName) {\n            return {\n                name: attributeName,\n                callback: function (feature, props) {\n                    var value = props[attributeName];\n                    if (typeof value === 'string') {\n                        value = getStringNumberEquivalent(vertContext, value);\n                    }\n                    return value !== undefined ? value : -9999999; // to avoid matching with the first string literal\n                },\n            };\n        }),\n        uniforms: uniforms,\n    };\n}\n//# sourceMappingURL=ShaderBuilder.js.map"]},"metadata":{},"sourceType":"module"}
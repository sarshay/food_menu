{"ast":null,"code":"/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray, isStringColor } from '../color.js';\nimport { log2 } from '../math.js';\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\n\nexport var ValueTypes = {\n  NUMBER: 1,\n  STRING: 2,\n  COLOR: 4,\n  BOOLEAN: 8,\n  NUMBER_ARRAY: 16,\n  ANY: 31,\n  NONE: 0\n};\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\n\nexport var Operators = {};\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\n\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n\n    return ValueTypes.STRING;\n  }\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Unhandled value type: \" + JSON.stringify(value));\n  }\n\n  var valueArr =\n  /** @type {Array<*>} */\n  value;\n  var onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n\n    return ValueTypes.NUMBER_ARRAY;\n  }\n\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\"Expected an expression operator but received: \" + JSON.stringify(valueArr));\n  }\n\n  var operator = Operators[valueArr[0]];\n\n  if (operator === undefined) {\n    throw new Error(\"Unrecognized expression operator: \" + JSON.stringify(valueArr));\n  }\n\n  return operator.getReturnType(valueArr.slice(1));\n}\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\n\nexport function isTypeUnique(valueType) {\n  return log2(valueType) % 1 === 0;\n}\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n * @property {number} [bandCount] Number of bands per pixel.\n */\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\n\nexport function numberToGlsl(v) {\n  var s = v.toString();\n  return s.indexOf('.') === -1 ? s + '.0' : s;\n}\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\n\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n\n  return \"vec\" + array.length + \"(\" + array.map(numberToGlsl).join(', ') + \")\";\n}\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\n\nexport function colorToGlsl(color) {\n  var array = asArray(color).slice();\n\n  if (array.length < 4) {\n    array.push(1);\n  }\n\n  return arrayToGlsl(array.map(function (c, i) {\n    return i < 3 ? c / 255 : c;\n  }));\n}\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\n\nexport function getStringNumberEquivalent(context, string) {\n  if (context.stringLiteralsMap[string] === undefined) {\n    context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;\n  }\n\n  return context.stringLiteralsMap[string];\n}\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\n\nexport function stringToGlsl(context, string) {\n  return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\n\nexport function expressionToGlsl(context, value, typeHint) {\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    var operator = Operators[value[0]];\n\n    if (operator === undefined) {\n      throw new Error(\"Unrecognized expression operator: \" + JSON.stringify(value));\n    }\n\n    return operator.toGlsl(context, value.slice(1), typeHint);\n  }\n\n  var valueType = getValueType(value);\n\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(\n    /** @type {number} */\n    value);\n  }\n\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n\n  if ((valueType & ValueTypes.STRING) > 0 && (typeHint === undefined || typeHint == ValueTypes.STRING)) {\n    return stringToGlsl(context, value.toString());\n  }\n\n  if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === undefined || typeHint == ValueTypes.COLOR)) {\n    return colorToGlsl(\n    /** @type {Array<number> | string} */\n    value);\n  }\n\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(\n    /** @type {Array<number>} */\n    value);\n  }\n\n  throw new Error(\"Unexpected expression \" + value + \" (expected type \" + typeHint + \")\");\n}\n\nfunction assertNumber(value) {\n  if (!(getValueType(value) & ValueTypes.NUMBER)) {\n    throw new Error(\"A numeric value was expected, got \" + JSON.stringify(value) + \" instead\");\n  }\n}\n\nfunction assertNumbers(values) {\n  for (var i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\n\nfunction assertString(value) {\n  if (!(getValueType(value) & ValueTypes.STRING)) {\n    throw new Error(\"A string value was expected, got \" + JSON.stringify(value) + \" instead\");\n  }\n}\n\nfunction assertBoolean(value) {\n  if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n    throw new Error(\"A boolean value was expected, got \" + JSON.stringify(value) + \" instead\");\n  }\n}\n\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\"Exactly \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n  }\n}\n\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\"At least \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n  }\n}\n\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\"At most \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n  }\n}\n\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\"An even amount of arguments was expected, got \" + args + \" instead\");\n  }\n}\n\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\"An odd amount of arguments was expected, got \" + args + \" instead\");\n  }\n}\n\nfunction assertUniqueInferredType(args, types) {\n  if (!isTypeUnique(types)) {\n    throw new Error(\"Could not infer only one type from the following expression: \" + JSON.stringify(args));\n  }\n}\n\nOperators['get'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n\n    if (context.attributes.indexOf(value) === -1) {\n      context.attributes.push(value);\n    }\n\n    var prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + value;\n  }\n};\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\n\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\nOperators['var'] = {\n  getReturnType: function (args) {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    var value = args[0].toString();\n\n    if (context.variables.indexOf(value) === -1) {\n      context.variables.push(value);\n    }\n\n    return uniformNameForVariable(value);\n  }\n};\nOperators['band'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    var band = args[0];\n\n    if (typeof band !== 'number') {\n      throw new Error('Band index must be a number');\n    }\n\n    var zeroBasedBand = band - 1;\n    var colorIndex = Math.floor(zeroBasedBand / 4);\n    var bandIndex = zeroBasedBand % 4;\n\n    if (band === context.bandCount && bandIndex === 1) {\n      // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n      bandIndex = 3;\n    }\n\n    if (args.length === 1) {\n      return \"color\" + colorIndex + \"[\" + bandIndex + \"]\";\n    } else {\n      var xOffset = args[1];\n      var yOffset = args[2] || 0;\n      assertNumber(xOffset);\n      assertNumber(yOffset);\n      var uniformName = Uniforms.TILE_TEXTURE_PREFIX + colorIndex;\n      return \"texture2D(\" + uniformName + \", v_textureCoord + vec2(\" + expressionToGlsl(context, xOffset) + \" / \" + Uniforms.TEXTURE_PIXEL_WIDTH + \", \" + expressionToGlsl(context, yOffset) + \" / \" + Uniforms.TEXTURE_PIXEL_HEIGHT + \"))[\" + bandIndex + \"]\";\n    }\n  }\n};\nOperators['time'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  }\n};\nOperators['zoom'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  }\n};\nOperators['resolution'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  }\n};\nOperators['*'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" * \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['/'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" / \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['+'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" + \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['-'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" - \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['clamp'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min = expressionToGlsl(context, args[1]);\n    var max = expressionToGlsl(context, args[2]);\n    return \"clamp(\" + expressionToGlsl(context, args[0]) + \", \" + min + \", \" + max + \")\";\n  }\n};\nOperators['%'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"mod(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['^'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"pow(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['abs'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"abs(\" + expressionToGlsl(context, args[0]) + \")\";\n  }\n};\nOperators['sin'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"sin(\" + expressionToGlsl(context, args[0]) + \")\";\n  }\n};\nOperators['cos'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return \"cos(\" + expressionToGlsl(context, args[0]) + \")\";\n  }\n};\nOperators['atan'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2 ? \"atan(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\" : \"atan(\" + expressionToGlsl(context, args[0]) + \")\";\n  }\n};\nOperators['>'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" > \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['>='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" >= \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['<'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" < \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\nOperators['<='] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return \"(\" + expressionToGlsl(context, args[0]) + \" <= \" + expressionToGlsl(context, args[1]) + \")\";\n  }\n};\n\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2); // find common type\n\n      var type = ValueTypes.ANY;\n\n      for (var i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n\n      if (type === ValueTypes.NONE) {\n        throw new Error(\"All arguments should be of compatible type, got \" + JSON.stringify(args) + \" instead\");\n      } // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n\n\n      type &= ~ValueTypes.COLOR;\n      return \"(\" + expressionToGlsl(context, args[0], type) + \" \" + operator + \" \" + expressionToGlsl(context, args[1], type) + \")\";\n    }\n  };\n}\n\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\nOperators['!'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return \"(!\" + expressionToGlsl(context, args[0]) + \")\";\n  }\n};\n\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function (args) {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n\n      for (var i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n\n      var result = '';\n      result = args.map(function (arg) {\n        return expressionToGlsl(context, arg);\n      }).join(\" \" + operator + \" \");\n      result = \"(\" + result + \")\";\n      return result;\n    }\n  };\n}\n\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    var min = expressionToGlsl(context, args[1]);\n    var max = expressionToGlsl(context, args[2]);\n    var value = expressionToGlsl(context, args[0]);\n    return \"(\" + value + \" >= \" + min + \" && \" + value + \" <= \" + max + \")\";\n  }\n};\nOperators['array'] = {\n  getReturnType: function (args) {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER);\n    });\n    return \"vec\" + args.length + \"(\" + parsedArgs.join(', ') + \")\";\n  }\n};\nOperators['color'] = {\n  getReturnType: function (args) {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    var array =\n    /** @type {Array<number>} */\n    args;\n\n    if (args.length === 3) {\n      array.push(1);\n    }\n\n    var parsedArgs = args.map(function (val, i) {\n      return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? ' / 255.0' : '');\n    });\n    return \"vec\" + args.length + \"(\" + parsedArgs.join(', ') + \")\";\n  }\n};\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    var type = ValueTypes.COLOR | ValueTypes.NUMBER;\n\n    for (var i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6); // validate interpolation type\n\n    var type = args[0];\n    var interpolation;\n\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n\n      case 'exponential':\n        interpolation = type[1];\n        break;\n\n      default:\n        interpolation = null;\n    }\n\n    if (!interpolation) {\n      throw new Error(\"Invalid interpolation type for \\\"interpolate\\\" operator, received: \" + JSON.stringify(type));\n    } // compute input/output types\n\n\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[1]);\n    var exponent = numberToGlsl(interpolation);\n    var result = '';\n\n    for (var i = 2; i < args.length - 2; i += 2) {\n      var stop1 = expressionToGlsl(context, args[i]);\n      var output1 = result || expressionToGlsl(context, args[i + 1], outputType);\n      var stop2 = expressionToGlsl(context, args[i + 2]);\n      var output2 = expressionToGlsl(context, args[i + 3], outputType);\n      result = \"mix(\" + output1 + \", \" + output2 + \", pow(clamp((\" + input + \" - \" + stop1 + \") / (\" + stop2 + \" - \" + stop1 + \"), 0.0, 1.0), \" + exponent + \"))\";\n    }\n\n    return result;\n  }\n};\nOperators['match'] = {\n  getReturnType: function (args) {\n    var type = ValueTypes.ANY;\n\n    for (var i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['match'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n    var input = expressionToGlsl(context, args[0]);\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n\n    for (var i = args.length - 3; i >= 1; i -= 2) {\n      var match = expressionToGlsl(context, args[i]);\n      var output = expressionToGlsl(context, args[i + 1], outputType);\n      result = \"(\" + input + \" == \" + match + \" ? \" + output + \" : \" + (result || fallback) + \")\";\n    }\n\n    return result;\n  }\n};\nOperators['case'] = {\n  getReturnType: function (args) {\n    var type = ValueTypes.ANY;\n\n    for (var i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, opt_typeHint) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n    var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n    var outputType = Operators['case'].getReturnType(args) & typeHint;\n    assertUniqueInferredType(args, outputType);\n\n    for (var i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n\n    var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    var result = null;\n\n    for (var i = args.length - 3; i >= 0; i -= 2) {\n      var condition = expressionToGlsl(context, args[i]);\n      var output = expressionToGlsl(context, args[i + 1], outputType);\n      result = \"(\" + condition + \" ? \" + output + \" : \" + (result || fallback) + \")\";\n    }\n\n    return result;\n  }\n};","map":{"version":3,"sources":["../src/style/expressions.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray, isStringColor } from '../color.js';\nimport { log2 } from '../math.js';\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)\n *     Note: those will be taken from the attributes provided to the renderer\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2]` multiplies `value1` by `value2`\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2]` adds `value1` and `value2`\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport var ValueTypes = {\n    NUMBER: 1,\n    STRING: 2,\n    COLOR: 4,\n    BOOLEAN: 8,\n    NUMBER_ARRAY: 16,\n    ANY: 31,\n    NONE: 0,\n};\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string\n * Note: takes in an optional type hint as 3rd parameter\n */\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport var Operators = {};\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n    if (typeof value === 'number') {\n        return ValueTypes.NUMBER;\n    }\n    if (typeof value === 'boolean') {\n        return ValueTypes.BOOLEAN;\n    }\n    if (typeof value === 'string') {\n        if (isStringColor(value)) {\n            return ValueTypes.COLOR | ValueTypes.STRING;\n        }\n        return ValueTypes.STRING;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(\"Unhandled value type: \" + JSON.stringify(value));\n    }\n    var valueArr = /** @type {Array<*>} */ (value);\n    var onlyNumbers = valueArr.every(function (v) {\n        return typeof v === 'number';\n    });\n    if (onlyNumbers) {\n        if (valueArr.length === 3 || valueArr.length === 4) {\n            return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n        }\n        return ValueTypes.NUMBER_ARRAY;\n    }\n    if (typeof valueArr[0] !== 'string') {\n        throw new Error(\"Expected an expression operator but received: \" + JSON.stringify(valueArr));\n    }\n    var operator = Operators[valueArr[0]];\n    if (operator === undefined) {\n        throw new Error(\"Unrecognized expression operator: \" + JSON.stringify(valueArr));\n    }\n    return operator.getReturnType(valueArr.slice(1));\n}\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n    return log2(valueType) % 1 === 0;\n}\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**\n * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**\n * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number\n * @property {number} [bandCount] Number of bands per pixel.\n */\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n    var s = v.toString();\n    return s.indexOf('.') === -1 ? s + '.0' : s;\n}\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n    if (array.length < 2 || array.length > 4) {\n        throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n    }\n    return \"vec\" + array.length + \"(\" + array.map(numberToGlsl).join(', ') + \")\";\n}\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n    var array = asArray(color).slice();\n    if (array.length < 4) {\n        array.push(1);\n    }\n    return arrayToGlsl(array.map(function (c, i) {\n        return i < 3 ? c / 255 : c;\n    }));\n}\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(context, string) {\n    if (context.stringLiteralsMap[string] === undefined) {\n        context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;\n    }\n    return context.stringLiteralsMap[string];\n}\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * @param {ParsingContext} context Parsing context\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(context, string) {\n    return numberToGlsl(getStringNumberEquivalent(context, string));\n}\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, typeHint) {\n    // operator\n    if (Array.isArray(value) && typeof value[0] === 'string') {\n        var operator = Operators[value[0]];\n        if (operator === undefined) {\n            throw new Error(\"Unrecognized expression operator: \" + JSON.stringify(value));\n        }\n        return operator.toGlsl(context, value.slice(1), typeHint);\n    }\n    var valueType = getValueType(value);\n    if ((valueType & ValueTypes.NUMBER) > 0) {\n        return numberToGlsl(/** @type {number} */ (value));\n    }\n    if ((valueType & ValueTypes.BOOLEAN) > 0) {\n        return value.toString();\n    }\n    if ((valueType & ValueTypes.STRING) > 0 &&\n        (typeHint === undefined || typeHint == ValueTypes.STRING)) {\n        return stringToGlsl(context, value.toString());\n    }\n    if ((valueType & ValueTypes.COLOR) > 0 &&\n        (typeHint === undefined || typeHint == ValueTypes.COLOR)) {\n        return colorToGlsl(/** @type {Array<number> | string} */ (value));\n    }\n    if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n        return arrayToGlsl(/** @type {Array<number>} */ (value));\n    }\n    throw new Error(\"Unexpected expression \" + value + \" (expected type \" + typeHint + \")\");\n}\nfunction assertNumber(value) {\n    if (!(getValueType(value) & ValueTypes.NUMBER)) {\n        throw new Error(\"A numeric value was expected, got \" + JSON.stringify(value) + \" instead\");\n    }\n}\nfunction assertNumbers(values) {\n    for (var i = 0; i < values.length; i++) {\n        assertNumber(values[i]);\n    }\n}\nfunction assertString(value) {\n    if (!(getValueType(value) & ValueTypes.STRING)) {\n        throw new Error(\"A string value was expected, got \" + JSON.stringify(value) + \" instead\");\n    }\n}\nfunction assertBoolean(value) {\n    if (!(getValueType(value) & ValueTypes.BOOLEAN)) {\n        throw new Error(\"A boolean value was expected, got \" + JSON.stringify(value) + \" instead\");\n    }\n}\nfunction assertArgsCount(args, count) {\n    if (args.length !== count) {\n        throw new Error(\"Exactly \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n    }\n}\nfunction assertArgsMinCount(args, count) {\n    if (args.length < count) {\n        throw new Error(\"At least \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n    }\n}\nfunction assertArgsMaxCount(args, count) {\n    if (args.length > count) {\n        throw new Error(\"At most \" + count + \" arguments were expected, got \" + args.length + \" instead\");\n    }\n}\nfunction assertArgsEven(args) {\n    if (args.length % 2 !== 0) {\n        throw new Error(\"An even amount of arguments was expected, got \" + args + \" instead\");\n    }\n}\nfunction assertArgsOdd(args) {\n    if (args.length % 2 === 0) {\n        throw new Error(\"An odd amount of arguments was expected, got \" + args + \" instead\");\n    }\n}\nfunction assertUniqueInferredType(args, types) {\n    if (!isTypeUnique(types)) {\n        throw new Error(\"Could not infer only one type from the following expression: \" + JSON.stringify(args));\n    }\n}\nOperators['get'] = {\n    getReturnType: function (args) {\n        return ValueTypes.ANY;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 1);\n        assertString(args[0]);\n        var value = args[0].toString();\n        if (context.attributes.indexOf(value) === -1) {\n            context.attributes.push(value);\n        }\n        var prefix = context.inFragmentShader ? 'v_' : 'a_';\n        return prefix + value;\n    },\n};\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n    return 'u_var_' + variableName;\n}\nOperators['var'] = {\n    getReturnType: function (args) {\n        return ValueTypes.ANY;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 1);\n        assertString(args[0]);\n        var value = args[0].toString();\n        if (context.variables.indexOf(value) === -1) {\n            context.variables.push(value);\n        }\n        return uniformNameForVariable(value);\n    },\n};\nOperators['band'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsMinCount(args, 1);\n        assertArgsMaxCount(args, 3);\n        var band = args[0];\n        if (typeof band !== 'number') {\n            throw new Error('Band index must be a number');\n        }\n        var zeroBasedBand = band - 1;\n        var colorIndex = Math.floor(zeroBasedBand / 4);\n        var bandIndex = zeroBasedBand % 4;\n        if (band === context.bandCount && bandIndex === 1) {\n            // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n            bandIndex = 3;\n        }\n        if (args.length === 1) {\n            return \"color\" + colorIndex + \"[\" + bandIndex + \"]\";\n        }\n        else {\n            var xOffset = args[1];\n            var yOffset = args[2] || 0;\n            assertNumber(xOffset);\n            assertNumber(yOffset);\n            var uniformName = Uniforms.TILE_TEXTURE_PREFIX + colorIndex;\n            return \"texture2D(\" + uniformName + \", v_textureCoord + vec2(\" + expressionToGlsl(context, xOffset) + \" / \" + Uniforms.TEXTURE_PIXEL_WIDTH + \", \" + expressionToGlsl(context, yOffset) + \" / \" + Uniforms.TEXTURE_PIXEL_HEIGHT + \"))[\" + bandIndex + \"]\";\n        }\n    },\n};\nOperators['time'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 0);\n        return 'u_time';\n    },\n};\nOperators['zoom'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 0);\n        return 'u_zoom';\n    },\n};\nOperators['resolution'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 0);\n        return 'u_resolution';\n    },\n};\nOperators['*'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"(\" + expressionToGlsl(context, args[0]) + \" * \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nOperators['/'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"(\" + expressionToGlsl(context, args[0]) + \" / \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nOperators['+'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"(\" + expressionToGlsl(context, args[0]) + \" + \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nOperators['-'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"(\" + expressionToGlsl(context, args[0]) + \" - \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nOperators['clamp'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 3);\n        assertNumbers(args);\n        var min = expressionToGlsl(context, args[1]);\n        var max = expressionToGlsl(context, args[2]);\n        return \"clamp(\" + expressionToGlsl(context, args[0]) + \", \" + min + \", \" + max + \")\";\n    },\n};\nOperators['%'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"mod(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nOperators['^'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"pow(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nOperators['abs'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 1);\n        assertNumbers(args);\n        return \"abs(\" + expressionToGlsl(context, args[0]) + \")\";\n    },\n};\nOperators['sin'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 1);\n        assertNumbers(args);\n        return \"sin(\" + expressionToGlsl(context, args[0]) + \")\";\n    },\n};\nOperators['cos'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 1);\n        assertNumbers(args);\n        return \"cos(\" + expressionToGlsl(context, args[0]) + \")\";\n    },\n};\nOperators['atan'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER;\n    },\n    toGlsl: function (context, args) {\n        assertArgsMinCount(args, 1);\n        assertArgsMaxCount(args, 2);\n        assertNumbers(args);\n        return args.length === 2\n            ? \"atan(\" + expressionToGlsl(context, args[0]) + \", \" + expressionToGlsl(context, args[1]) + \")\"\n            : \"atan(\" + expressionToGlsl(context, args[0]) + \")\";\n    },\n};\nOperators['>'] = {\n    getReturnType: function (args) {\n        return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"(\" + expressionToGlsl(context, args[0]) + \" > \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nOperators['>='] = {\n    getReturnType: function (args) {\n        return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"(\" + expressionToGlsl(context, args[0]) + \" >= \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nOperators['<'] = {\n    getReturnType: function (args) {\n        return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"(\" + expressionToGlsl(context, args[0]) + \" < \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nOperators['<='] = {\n    getReturnType: function (args) {\n        return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 2);\n        assertNumbers(args);\n        return \"(\" + expressionToGlsl(context, args[0]) + \" <= \" + expressionToGlsl(context, args[1]) + \")\";\n    },\n};\nfunction getEqualOperator(operator) {\n    return {\n        getReturnType: function (args) {\n            return ValueTypes.BOOLEAN;\n        },\n        toGlsl: function (context, args) {\n            assertArgsCount(args, 2);\n            // find common type\n            var type = ValueTypes.ANY;\n            for (var i = 0; i < args.length; i++) {\n                type &= getValueType(args[i]);\n            }\n            if (type === ValueTypes.NONE) {\n                throw new Error(\"All arguments should be of compatible type, got \" + JSON.stringify(args) + \" instead\");\n            }\n            // Since it's not possible to have color types here, we can leave it out\n            // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n            type &= ~ValueTypes.COLOR;\n            return \"(\" + expressionToGlsl(context, args[0], type) + \" \" + operator + \" \" + expressionToGlsl(context, args[1], type) + \")\";\n        },\n    };\n}\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\nOperators['!'] = {\n    getReturnType: function (args) {\n        return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 1);\n        assertBoolean(args[0]);\n        return \"(!\" + expressionToGlsl(context, args[0]) + \")\";\n    },\n};\nfunction getDecisionOperator(operator) {\n    return {\n        getReturnType: function (args) {\n            return ValueTypes.BOOLEAN;\n        },\n        toGlsl: function (context, args) {\n            assertArgsMinCount(args, 2);\n            for (var i = 0; i < args.length; i++) {\n                assertBoolean(args[i]);\n            }\n            var result = '';\n            result = args\n                .map(function (arg) { return expressionToGlsl(context, arg); })\n                .join(\" \" + operator + \" \");\n            result = \"(\" + result + \")\";\n            return result;\n        },\n    };\n}\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n    getReturnType: function (args) {\n        return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n        assertArgsCount(args, 3);\n        assertNumbers(args);\n        var min = expressionToGlsl(context, args[1]);\n        var max = expressionToGlsl(context, args[2]);\n        var value = expressionToGlsl(context, args[0]);\n        return \"(\" + value + \" >= \" + min + \" && \" + value + \" <= \" + max + \")\";\n    },\n};\nOperators['array'] = {\n    getReturnType: function (args) {\n        return ValueTypes.NUMBER_ARRAY;\n    },\n    toGlsl: function (context, args) {\n        assertArgsMinCount(args, 2);\n        assertArgsMaxCount(args, 4);\n        assertNumbers(args);\n        var parsedArgs = args.map(function (val) {\n            return expressionToGlsl(context, val, ValueTypes.NUMBER);\n        });\n        return \"vec\" + args.length + \"(\" + parsedArgs.join(', ') + \")\";\n    },\n};\nOperators['color'] = {\n    getReturnType: function (args) {\n        return ValueTypes.COLOR;\n    },\n    toGlsl: function (context, args) {\n        assertArgsMinCount(args, 3);\n        assertArgsMaxCount(args, 4);\n        assertNumbers(args);\n        var array = /** @type {Array<number>} */ (args);\n        if (args.length === 3) {\n            array.push(1);\n        }\n        var parsedArgs = args.map(function (val, i) {\n            return (expressionToGlsl(context, val, ValueTypes.NUMBER) +\n                (i < 3 ? ' / 255.0' : ''));\n        });\n        return \"vec\" + args.length + \"(\" + parsedArgs.join(', ') + \")\";\n    },\n};\nOperators['interpolate'] = {\n    getReturnType: function (args) {\n        var type = ValueTypes.COLOR | ValueTypes.NUMBER;\n        for (var i = 3; i < args.length; i += 2) {\n            type = type & getValueType(args[i]);\n        }\n        return type;\n    },\n    toGlsl: function (context, args, opt_typeHint) {\n        assertArgsEven(args);\n        assertArgsMinCount(args, 6);\n        // validate interpolation type\n        var type = args[0];\n        var interpolation;\n        switch (type[0]) {\n            case 'linear':\n                interpolation = 1;\n                break;\n            case 'exponential':\n                interpolation = type[1];\n                break;\n            default:\n                interpolation = null;\n        }\n        if (!interpolation) {\n            throw new Error(\"Invalid interpolation type for \\\"interpolate\\\" operator, received: \" + JSON.stringify(type));\n        }\n        // compute input/output types\n        var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n        var outputType = Operators['interpolate'].getReturnType(args) & typeHint;\n        assertUniqueInferredType(args, outputType);\n        var input = expressionToGlsl(context, args[1]);\n        var exponent = numberToGlsl(interpolation);\n        var result = '';\n        for (var i = 2; i < args.length - 2; i += 2) {\n            var stop1 = expressionToGlsl(context, args[i]);\n            var output1 = result || expressionToGlsl(context, args[i + 1], outputType);\n            var stop2 = expressionToGlsl(context, args[i + 2]);\n            var output2 = expressionToGlsl(context, args[i + 3], outputType);\n            result = \"mix(\" + output1 + \", \" + output2 + \", pow(clamp((\" + input + \" - \" + stop1 + \") / (\" + stop2 + \" - \" + stop1 + \"), 0.0, 1.0), \" + exponent + \"))\";\n        }\n        return result;\n    },\n};\nOperators['match'] = {\n    getReturnType: function (args) {\n        var type = ValueTypes.ANY;\n        for (var i = 2; i < args.length; i += 2) {\n            type = type & getValueType(args[i]);\n        }\n        type = type & getValueType(args[args.length - 1]);\n        return type;\n    },\n    toGlsl: function (context, args, opt_typeHint) {\n        assertArgsEven(args);\n        assertArgsMinCount(args, 4);\n        var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n        var outputType = Operators['match'].getReturnType(args) & typeHint;\n        assertUniqueInferredType(args, outputType);\n        var input = expressionToGlsl(context, args[0]);\n        var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n        var result = null;\n        for (var i = args.length - 3; i >= 1; i -= 2) {\n            var match = expressionToGlsl(context, args[i]);\n            var output = expressionToGlsl(context, args[i + 1], outputType);\n            result = \"(\" + input + \" == \" + match + \" ? \" + output + \" : \" + (result || fallback) + \")\";\n        }\n        return result;\n    },\n};\nOperators['case'] = {\n    getReturnType: function (args) {\n        var type = ValueTypes.ANY;\n        for (var i = 1; i < args.length; i += 2) {\n            type = type & getValueType(args[i]);\n        }\n        type = type & getValueType(args[args.length - 1]);\n        return type;\n    },\n    toGlsl: function (context, args, opt_typeHint) {\n        assertArgsOdd(args);\n        assertArgsMinCount(args, 3);\n        var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;\n        var outputType = Operators['case'].getReturnType(args) & typeHint;\n        assertUniqueInferredType(args, outputType);\n        for (var i = 0; i < args.length - 1; i += 2) {\n            assertBoolean(args[i]);\n        }\n        var fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n        var result = null;\n        for (var i = args.length - 3; i >= 0; i -= 2) {\n            var condition = expressionToGlsl(context, args[i]);\n            var output = expressionToGlsl(context, args[i + 1], outputType);\n            result = \"(\" + condition + \" ? \" + output + \" : \" + (result || fallback) + \")\";\n        }\n        return result;\n    },\n};\n//# sourceMappingURL=expressions.js.map"]},"metadata":{},"sourceType":"module"}
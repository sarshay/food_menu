{"ast":null,"code":"import _ol_ from '../index.js';\nimport _ol_Object_ from '../object.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_functions_ from '../functions.js';\nimport _ol_geom_flat_transform_ from '../geom/flat/transform.js';\nimport _ol_proj_ from '../proj.js';\nimport _ol_proj_Units_ from '../proj/units.js';\nimport _ol_transform_ from '../transform.js';\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @constructor\n * @abstract\n * @extends {ol.Object}\n * @api\n */\n\nvar _ol_geom_Geometry_ = function () {\n  _ol_Object_.call(this);\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n\n\n  this.extent_ = _ol_extent_.createEmpty();\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.extentRevision_ = -1;\n  /**\n   * @protected\n   * @type {Object.<string, ol.geom.Geometry>}\n   */\n\n  this.simplifiedGeometryCache = {};\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.simplifiedGeometryRevision = 0;\n  /**\n   * @private\n   * @type {ol.Transform}\n   */\n\n  this.tmpTransform_ = _ol_transform_.create();\n};\n\n_ol_.inherits(_ol_geom_Geometry_, _ol_Object_);\n/**\n * Make a complete copy of the geometry.\n * @abstract\n * @return {!ol.geom.Geometry} Clone.\n */\n\n\n_ol_geom_Geometry_.prototype.clone = function () {};\n/**\n * @abstract\n * @param {number} x X.\n * @param {number} y Y.\n * @param {ol.Coordinate} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @return {number} Minimum squared distance.\n */\n\n\n_ol_geom_Geometry_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {};\n/**\n * Return the closest point of the geometry to the passed point as\n * {@link ol.Coordinate coordinate}.\n * @param {ol.Coordinate} point Point.\n * @param {ol.Coordinate=} opt_closestPoint Closest point.\n * @return {ol.Coordinate} Closest point.\n * @api\n */\n\n\n_ol_geom_Geometry_.prototype.getClosestPoint = function (point, opt_closestPoint) {\n  var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n  this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n  return closestPoint;\n};\n/**\n * Returns true if this geometry includes the specified coordinate. If the\n * coordinate is on the boundary of the geometry, returns false.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @return {boolean} Contains coordinate.\n * @api\n */\n\n\n_ol_geom_Geometry_.prototype.intersectsCoordinate = function (coordinate) {\n  return this.containsXY(coordinate[0], coordinate[1]);\n};\n/**\n * @abstract\n * @param {ol.Extent} extent Extent.\n * @protected\n * @return {ol.Extent} extent Extent.\n */\n\n\n_ol_geom_Geometry_.prototype.computeExtent = function (extent) {};\n/**\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n\n\n_ol_geom_Geometry_.prototype.containsXY = _ol_functions_.FALSE;\n/**\n * Get the extent of the geometry.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} extent Extent.\n * @api\n */\n\n_ol_geom_Geometry_.prototype.getExtent = function (opt_extent) {\n  if (this.extentRevision_ != this.getRevision()) {\n    this.extent_ = this.computeExtent(this.extent_);\n    this.extentRevision_ = this.getRevision();\n  }\n\n  return _ol_extent_.returnOrUpdate(this.extent_, opt_extent);\n};\n/**\n * Rotate the geometry around a given coordinate. This modifies the geometry\n * coordinates in place.\n * @abstract\n * @param {number} angle Rotation angle in radians.\n * @param {ol.Coordinate} anchor The rotation center.\n * @api\n */\n\n\n_ol_geom_Geometry_.prototype.rotate = function (angle, anchor) {};\n/**\n * Scale the geometry (with an optional origin).  This modifies the geometry\n * coordinates in place.\n * @abstract\n * @param {number} sx The scaling factor in the x-direction.\n * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n *     sx).\n * @param {ol.Coordinate=} opt_anchor The scale origin (defaults to the center\n *     of the geometry extent).\n * @api\n */\n\n\n_ol_geom_Geometry_.prototype.scale = function (sx, opt_sy, opt_anchor) {};\n/**\n * Create a simplified version of this geometry.  For linestrings, this uses\n * the the {@link\n * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n * Douglas Peucker} algorithm.  For polygons, a quantization-based\n * simplification is used to preserve topology.\n * @function\n * @param {number} tolerance The tolerance distance for simplification.\n * @return {ol.geom.Geometry} A new, simplified version of the original\n *     geometry.\n * @api\n */\n\n\n_ol_geom_Geometry_.prototype.simplify = function (tolerance) {\n  return this.getSimplifiedGeometry(tolerance * tolerance);\n};\n/**\n * Create a simplified version of this geometry using the Douglas Peucker\n * algorithm.\n * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n * @abstract\n * @param {number} squaredTolerance Squared tolerance.\n * @return {ol.geom.Geometry} Simplified geometry.\n */\n\n\n_ol_geom_Geometry_.prototype.getSimplifiedGeometry = function (squaredTolerance) {};\n/**\n * Get the type of this geometry.\n * @abstract\n * @return {ol.geom.GeometryType} Geometry type.\n */\n\n\n_ol_geom_Geometry_.prototype.getType = function () {};\n/**\n * Apply a transform function to each coordinate of the geometry.\n * The geometry is modified in place.\n * If you do not want the geometry modified in place, first `clone()` it and\n * then use this function on the clone.\n * @abstract\n * @param {ol.TransformFunction} transformFn Transform.\n */\n\n\n_ol_geom_Geometry_.prototype.applyTransform = function (transformFn) {};\n/**\n * Test if the geometry and the passed extent intersect.\n * @abstract\n * @param {ol.Extent} extent Extent.\n * @return {boolean} `true` if the geometry and the extent intersect.\n */\n\n\n_ol_geom_Geometry_.prototype.intersectsExtent = function (extent) {};\n/**\n * Translate the geometry.  This modifies the geometry coordinates in place.  If\n * instead you want a new geometry, first `clone()` this geometry.\n * @abstract\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n */\n\n\n_ol_geom_Geometry_.prototype.translate = function (deltaX, deltaY) {};\n/**\n * Transform each coordinate of the geometry from one coordinate reference\n * system to another. The geometry is modified in place.\n * For example, a line will be transformed to a line and a circle to a circle.\n * If you do not want the geometry modified in place, first `clone()` it and\n * then use this function on the clone.\n *\n * @param {ol.ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link ol.proj.Projection} object.\n * @param {ol.ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link ol.proj.Projection} object.\n * @return {ol.geom.Geometry} This geometry.  Note that original geometry is\n *     modified in place.\n * @api\n */\n\n\n_ol_geom_Geometry_.prototype.transform = function (source, destination) {\n  var tmpTransform = this.tmpTransform_;\n  source = _ol_proj_.get(source);\n  var transformFn = source.getUnits() == _ol_proj_Units_.TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {\n    var pixelExtent = source.getExtent();\n    var projectedExtent = source.getWorldExtent();\n\n    var scale = _ol_extent_.getHeight(projectedExtent) / _ol_extent_.getHeight(pixelExtent);\n\n    _ol_transform_.compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n\n    _ol_geom_flat_transform_.transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n\n    return _ol_proj_.getTransform(source, destination)(inCoordinates, outCoordinates, stride);\n  } : _ol_proj_.getTransform(source, destination);\n  this.applyTransform(transformFn);\n  return this;\n};\n\nexport default _ol_geom_Geometry_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/geom/geometry.js"],"names":["_ol_","_ol_Object_","_ol_extent_","_ol_functions_","_ol_geom_flat_transform_","_ol_proj_","_ol_proj_Units_","_ol_transform_","_ol_geom_Geometry_","call","extent_","createEmpty","extentRevision_","simplifiedGeometryCache","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","tmpTransform_","create","inherits","prototype","clone","closestPointXY","x","y","closestPoint","minSquaredDistance","getClosestPoint","point","opt_closestPoint","NaN","Infinity","intersectsCoordinate","coordinate","containsXY","computeExtent","extent","FALSE","getExtent","opt_extent","getRevision","returnOrUpdate","rotate","angle","anchor","scale","sx","opt_sy","opt_anchor","simplify","tolerance","getSimplifiedGeometry","squaredTolerance","getType","applyTransform","transformFn","intersectsExtent","translate","deltaX","deltaY","transform","source","destination","tmpTransform","get","getUnits","TILE_PIXELS","inCoordinates","outCoordinates","stride","pixelExtent","projectedExtent","getWorldExtent","getHeight","compose","transform2D","length","getTransform"],"mappings":"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","sourcesContent":["import _ol_ from '../index.js';\nimport _ol_Object_ from '../object.js';\nimport _ol_extent_ from '../extent.js';\nimport _ol_functions_ from '../functions.js';\nimport _ol_geom_flat_transform_ from '../geom/flat/transform.js';\nimport _ol_proj_ from '../proj.js';\nimport _ol_proj_Units_ from '../proj/units.js';\nimport _ol_transform_ from '../transform.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @constructor\n * @abstract\n * @extends {ol.Object}\n * @api\n */\nvar _ol_geom_Geometry_ = function() {\n\n  _ol_Object_.call(this);\n\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n  this.extent_ = _ol_extent_.createEmpty();\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.extentRevision_ = -1;\n\n  /**\n   * @protected\n   * @type {Object.<string, ol.geom.Geometry>}\n   */\n  this.simplifiedGeometryCache = {};\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.simplifiedGeometryRevision = 0;\n\n  /**\n   * @private\n   * @type {ol.Transform}\n   */\n  this.tmpTransform_ = _ol_transform_.create();\n\n};\n\n_ol_.inherits(_ol_geom_Geometry_, _ol_Object_);\n\n\n/**\n * Make a complete copy of the geometry.\n * @abstract\n * @return {!ol.geom.Geometry} Clone.\n */\n_ol_geom_Geometry_.prototype.clone = function() {};\n\n\n/**\n * @abstract\n * @param {number} x X.\n * @param {number} y Y.\n * @param {ol.Coordinate} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @return {number} Minimum squared distance.\n */\n_ol_geom_Geometry_.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {};\n\n\n/**\n * Return the closest point of the geometry to the passed point as\n * {@link ol.Coordinate coordinate}.\n * @param {ol.Coordinate} point Point.\n * @param {ol.Coordinate=} opt_closestPoint Closest point.\n * @return {ol.Coordinate} Closest point.\n * @api\n */\n_ol_geom_Geometry_.prototype.getClosestPoint = function(point, opt_closestPoint) {\n  var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n  this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n  return closestPoint;\n};\n\n\n/**\n * Returns true if this geometry includes the specified coordinate. If the\n * coordinate is on the boundary of the geometry, returns false.\n * @param {ol.Coordinate} coordinate Coordinate.\n * @return {boolean} Contains coordinate.\n * @api\n */\n_ol_geom_Geometry_.prototype.intersectsCoordinate = function(coordinate) {\n  return this.containsXY(coordinate[0], coordinate[1]);\n};\n\n\n/**\n * @abstract\n * @param {ol.Extent} extent Extent.\n * @protected\n * @return {ol.Extent} extent Extent.\n */\n_ol_geom_Geometry_.prototype.computeExtent = function(extent) {};\n\n\n/**\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n_ol_geom_Geometry_.prototype.containsXY = _ol_functions_.FALSE;\n\n\n/**\n * Get the extent of the geometry.\n * @param {ol.Extent=} opt_extent Extent.\n * @return {ol.Extent} extent Extent.\n * @api\n */\n_ol_geom_Geometry_.prototype.getExtent = function(opt_extent) {\n  if (this.extentRevision_ != this.getRevision()) {\n    this.extent_ = this.computeExtent(this.extent_);\n    this.extentRevision_ = this.getRevision();\n  }\n  return _ol_extent_.returnOrUpdate(this.extent_, opt_extent);\n};\n\n\n/**\n * Rotate the geometry around a given coordinate. This modifies the geometry\n * coordinates in place.\n * @abstract\n * @param {number} angle Rotation angle in radians.\n * @param {ol.Coordinate} anchor The rotation center.\n * @api\n */\n_ol_geom_Geometry_.prototype.rotate = function(angle, anchor) {};\n\n\n/**\n * Scale the geometry (with an optional origin).  This modifies the geometry\n * coordinates in place.\n * @abstract\n * @param {number} sx The scaling factor in the x-direction.\n * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n *     sx).\n * @param {ol.Coordinate=} opt_anchor The scale origin (defaults to the center\n *     of the geometry extent).\n * @api\n */\n_ol_geom_Geometry_.prototype.scale = function(sx, opt_sy, opt_anchor) {};\n\n\n/**\n * Create a simplified version of this geometry.  For linestrings, this uses\n * the the {@link\n * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n * Douglas Peucker} algorithm.  For polygons, a quantization-based\n * simplification is used to preserve topology.\n * @function\n * @param {number} tolerance The tolerance distance for simplification.\n * @return {ol.geom.Geometry} A new, simplified version of the original\n *     geometry.\n * @api\n */\n_ol_geom_Geometry_.prototype.simplify = function(tolerance) {\n  return this.getSimplifiedGeometry(tolerance * tolerance);\n};\n\n\n/**\n * Create a simplified version of this geometry using the Douglas Peucker\n * algorithm.\n * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n * @abstract\n * @param {number} squaredTolerance Squared tolerance.\n * @return {ol.geom.Geometry} Simplified geometry.\n */\n_ol_geom_Geometry_.prototype.getSimplifiedGeometry = function(squaredTolerance) {};\n\n\n/**\n * Get the type of this geometry.\n * @abstract\n * @return {ol.geom.GeometryType} Geometry type.\n */\n_ol_geom_Geometry_.prototype.getType = function() {};\n\n\n/**\n * Apply a transform function to each coordinate of the geometry.\n * The geometry is modified in place.\n * If you do not want the geometry modified in place, first `clone()` it and\n * then use this function on the clone.\n * @abstract\n * @param {ol.TransformFunction} transformFn Transform.\n */\n_ol_geom_Geometry_.prototype.applyTransform = function(transformFn) {};\n\n\n/**\n * Test if the geometry and the passed extent intersect.\n * @abstract\n * @param {ol.Extent} extent Extent.\n * @return {boolean} `true` if the geometry and the extent intersect.\n */\n_ol_geom_Geometry_.prototype.intersectsExtent = function(extent) {};\n\n\n/**\n * Translate the geometry.  This modifies the geometry coordinates in place.  If\n * instead you want a new geometry, first `clone()` this geometry.\n * @abstract\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n */\n_ol_geom_Geometry_.prototype.translate = function(deltaX, deltaY) {};\n\n\n/**\n * Transform each coordinate of the geometry from one coordinate reference\n * system to another. The geometry is modified in place.\n * For example, a line will be transformed to a line and a circle to a circle.\n * If you do not want the geometry modified in place, first `clone()` it and\n * then use this function on the clone.\n *\n * @param {ol.ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link ol.proj.Projection} object.\n * @param {ol.ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link ol.proj.Projection} object.\n * @return {ol.geom.Geometry} This geometry.  Note that original geometry is\n *     modified in place.\n * @api\n */\n_ol_geom_Geometry_.prototype.transform = function(source, destination) {\n  var tmpTransform = this.tmpTransform_;\n  source = _ol_proj_.get(source);\n  var transformFn = source.getUnits() == _ol_proj_Units_.TILE_PIXELS ?\n    function(inCoordinates, outCoordinates, stride) {\n      var pixelExtent = source.getExtent();\n      var projectedExtent = source.getWorldExtent();\n      var scale = _ol_extent_.getHeight(projectedExtent) / _ol_extent_.getHeight(pixelExtent);\n      _ol_transform_.compose(tmpTransform,\n          projectedExtent[0], projectedExtent[3],\n          scale, -scale, 0,\n          0, 0);\n      _ol_geom_flat_transform_.transform2D(inCoordinates, 0, inCoordinates.length, stride,\n          tmpTransform, outCoordinates);\n      return _ol_proj_.getTransform(source, destination)(inCoordinates, outCoordinates, stride);\n    } :\n    _ol_proj_.getTransform(source, destination);\n  this.applyTransform(transformFn);\n  return this;\n};\nexport default _ol_geom_Geometry_;\n"]},"metadata":{},"sourceType":"module"}
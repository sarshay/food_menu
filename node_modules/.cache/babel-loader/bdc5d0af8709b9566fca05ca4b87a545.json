{"ast":null,"code":"import _ol_ from '../../index.js';\nimport _ol_LayerType_ from '../../layertype.js';\nimport _ol_TileRange_ from '../../tilerange.js';\nimport _ol_TileState_ from '../../tilestate.js';\nimport _ol_ViewHint_ from '../../viewhint.js';\nimport _ol_dom_ from '../../dom.js';\nimport _ol_extent_ from '../../extent.js';\nimport _ol_renderer_Type_ from '../type.js';\nimport _ol_renderer_canvas_IntermediateCanvas_ from '../canvas/intermediatecanvas.js';\nimport _ol_transform_ from '../../transform.js';\n/**\n * @constructor\n * @extends {ol.renderer.canvas.IntermediateCanvas}\n * @param {ol.layer.Tile|ol.layer.VectorTile} tileLayer Tile layer.\n * @api\n */\n\nvar _ol_renderer_canvas_TileLayer_ = function (tileLayer) {\n  _ol_renderer_canvas_IntermediateCanvas_.call(this, tileLayer);\n  /**\n   * @protected\n   * @type {CanvasRenderingContext2D}\n   */\n\n\n  this.context = this.context === null ? null : _ol_dom_.createCanvasContext2D();\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.oversampling_;\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n\n  this.renderedExtent_ = null;\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.renderedRevision;\n  /**\n   * @protected\n   * @type {!Array.<ol.Tile>}\n   */\n\n  this.renderedTiles = [];\n  /**\n   * @protected\n   * @type {ol.Extent}\n   */\n\n  this.tmpExtent = _ol_extent_.createEmpty();\n  /**\n   * @private\n   * @type {ol.TileRange}\n   */\n\n  this.tmpTileRange_ = new _ol_TileRange_(0, 0, 0, 0);\n  /**\n   * @private\n   * @type {ol.Transform}\n   */\n\n  this.imageTransform_ = _ol_transform_.create();\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.zDirection = 0;\n};\n\n_ol_.inherits(_ol_renderer_canvas_TileLayer_, _ol_renderer_canvas_IntermediateCanvas_);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {ol.renderer.Type} type The renderer type.\n * @param {ol.layer.Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\n_ol_renderer_canvas_TileLayer_['handles'] = function (type, layer) {\n  return type === _ol_renderer_Type_.CANVAS && layer.getType() === _ol_LayerType_.TILE;\n};\n/**\n * Create a layer renderer.\n * @param {ol.renderer.Map} mapRenderer The map renderer.\n * @param {ol.layer.Layer} layer The layer to be rendererd.\n * @return {ol.renderer.canvas.TileLayer} The layer renderer.\n */\n\n\n_ol_renderer_canvas_TileLayer_['create'] = function (mapRenderer, layer) {\n  return new _ol_renderer_canvas_TileLayer_(\n  /** @type {ol.layer.Tile} */\n  layer);\n};\n/**\n * @private\n * @param {ol.Tile} tile Tile.\n * @return {boolean} Tile is drawable.\n */\n\n\n_ol_renderer_canvas_TileLayer_.prototype.isDrawableTile_ = function (tile) {\n  var tileState = tile.getState();\n  var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();\n  return tileState == _ol_TileState_.LOADED || tileState == _ol_TileState_.EMPTY || tileState == _ol_TileState_.ERROR && !useInterimTilesOnError;\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_renderer_canvas_TileLayer_.prototype.prepareFrame = function (frameState, layerState) {\n  var pixelRatio = frameState.pixelRatio;\n  var size = frameState.size;\n  var viewState = frameState.viewState;\n  var projection = viewState.projection;\n  var viewResolution = viewState.resolution;\n  var viewCenter = viewState.center;\n  var tileLayer = this.getLayer();\n  var tileSource =\n  /** @type {ol.source.Tile} */\n  tileLayer.getSource();\n  var sourceRevision = tileSource.getRevision();\n  var tileGrid = tileSource.getTileGridForProjection(projection);\n  var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n  var tileResolution = tileGrid.getResolution(z);\n  var oversampling = Math.round(viewResolution / tileResolution) || 1;\n  var extent = frameState.extent;\n\n  if (layerState.extent !== undefined) {\n    extent = _ol_extent_.getIntersection(extent, layerState.extent);\n  }\n\n  if (_ol_extent_.isEmpty(extent)) {\n    // Return false to prevent the rendering of the layer.\n    return false;\n  }\n\n  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n  var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n  var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n  /**\n   * @type {Object.<number, Object.<string, ol.Tile>>}\n   */\n\n  var tilesToDrawByZ = {};\n  tilesToDrawByZ[z] = {};\n  var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n  var tmpExtent = this.tmpExtent;\n  var tmpTileRange = this.tmpTileRange_;\n  var newTiles = false;\n  var tile, x, y;\n\n  for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n      tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n      if (tile.getState() == _ol_TileState_.ERROR) {\n        if (!tileLayer.getUseInterimTilesOnError()) {\n          // When useInterimTilesOnError is false, we consider the error tile as loaded.\n          tile.setState(_ol_TileState_.LOADED);\n        } else if (tileLayer.getPreload() > 0) {\n          // Preloaded tiles for lower resolutions might have finished loading.\n          newTiles = true;\n        }\n      }\n\n      if (!this.isDrawableTile_(tile)) {\n        tile = tile.getInterimTile();\n      }\n\n      if (this.isDrawableTile_(tile)) {\n        var uid = _ol_.getUid(this);\n\n        if (tile.getState() == _ol_TileState_.LOADED) {\n          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n          var inTransition = tile.inTransition(uid);\n\n          if (!newTiles && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n            newTiles = true;\n          }\n        }\n\n        if (tile.getAlpha(uid, frameState.time) === 1) {\n          // don't look for alt tiles if alpha is 1\n          continue;\n        }\n      }\n\n      var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n      var covered = false;\n\n      if (childTileRange) {\n        covered = findLoadedTiles(z + 1, childTileRange);\n      }\n\n      if (!covered) {\n        tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n      }\n    }\n  }\n\n  var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n  var hints = frameState.viewHints;\n  var animatingOrInteracting = hints[_ol_ViewHint_.ANIMATING] || hints[_ol_ViewHint_.INTERACTING];\n\n  if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (newTiles || !(this.renderedExtent_ && _ol_extent_.containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {\n    var context = this.context;\n\n    if (context) {\n      var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n      var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n      var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n      var canvas = context.canvas;\n\n      if (canvas.width != width || canvas.height != height) {\n        this.oversampling_ = oversampling;\n        canvas.width = width;\n        canvas.height = height;\n      } else {\n        if (this.renderedExtent_ && !_ol_extent_.equals(imageExtent, this.renderedExtent_)) {\n          context.clearRect(0, 0, width, height);\n        }\n\n        oversampling = this.oversampling_;\n      }\n    }\n\n    this.renderedTiles.length = 0;\n    /** @type {Array.<number>} */\n\n    var zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(function (a, b) {\n      if (a === z) {\n        return 1;\n      } else if (b === z) {\n        return -1;\n      } else {\n        return a > b ? 1 : a < b ? -1 : 0;\n      }\n    });\n    var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n    var tileExtent, tileGutter, tilesToDraw, w, h;\n\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      currentZ = zs[i];\n      currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      currentResolution = tileGrid.getResolution(currentZ);\n      currentScale = currentResolution / tileResolution;\n      tileGutter = tilePixelRatio * tileSource.getGutter(projection);\n      tilesToDraw = tilesToDrawByZ[currentZ];\n\n      for (var tileCoordKey in tilesToDraw) {\n        tile = tilesToDraw[tileCoordKey];\n        tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n        x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n        y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n        w = currentTilePixelSize[0] * currentScale / oversampling;\n        h = currentTilePixelSize[1] * currentScale / oversampling;\n        this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n        this.renderedTiles.push(tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n    this.renderedExtent_ = imageExtent;\n  }\n\n  var scale = this.renderedResolution / viewResolution;\n\n  var transform = _ol_transform_.compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n\n  _ol_transform_.compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\n\n  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n  this.scheduleExpireCache(frameState, tileSource);\n  this.updateLogos(frameState, tileSource);\n  return this.renderedTiles.length > 0;\n};\n/**\n * @param {ol.Tile} tile Tile.\n * @param {olx.FrameState} frameState Frame state.\n * @param {ol.LayerState} layerState Layer state.\n * @param {number} x Left of the tile.\n * @param {number} y Top of the tile.\n * @param {number} w Width of the tile.\n * @param {number} h Height of the tile.\n * @param {number} gutter Tile gutter.\n * @param {boolean} transition Apply an alpha transition.\n */\n\n\n_ol_renderer_canvas_TileLayer_.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter, transition) {\n  var image = tile.getImage(this.getLayer());\n\n  if (!image) {\n    return;\n  }\n\n  var uid = _ol_.getUid(this);\n\n  var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n\n  if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {\n    this.context.clearRect(x, y, w, h);\n  }\n\n  var alphaChanged = alpha !== this.context.globalAlpha;\n\n  if (alphaChanged) {\n    this.context.save();\n    this.context.globalAlpha = alpha;\n  }\n\n  this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n  if (alphaChanged) {\n    this.context.restore();\n  }\n\n  if (alpha !== 1) {\n    frameState.animate = true;\n  } else if (transition) {\n    tile.endTransition(uid);\n  }\n};\n/**\n * @inheritDoc\n */\n\n\n_ol_renderer_canvas_TileLayer_.prototype.getImage = function () {\n  var context = this.context;\n  return context ? context.canvas : null;\n};\n/**\n * @function\n * @return {ol.layer.Tile|ol.layer.VectorTile}\n */\n\n\n_ol_renderer_canvas_TileLayer_.prototype.getLayer;\n/**\n * @inheritDoc\n */\n\n_ol_renderer_canvas_TileLayer_.prototype.getImageTransform = function () {\n  return this.imageTransform_;\n};\n\nexport default _ol_renderer_canvas_TileLayer_;","map":{"version":3,"sources":["C:/xampp/htdocs/food_menu/node_modules/ol/renderer/canvas/tilelayer.js"],"names":["_ol_","_ol_LayerType_","_ol_TileRange_","_ol_TileState_","_ol_ViewHint_","_ol_dom_","_ol_extent_","_ol_renderer_Type_","_ol_renderer_canvas_IntermediateCanvas_","_ol_transform_","_ol_renderer_canvas_TileLayer_","tileLayer","call","context","createCanvasContext2D","oversampling_","renderedExtent_","renderedRevision","renderedTiles","tmpExtent","createEmpty","tmpTileRange_","imageTransform_","create","zDirection","inherits","type","layer","CANVAS","getType","TILE","mapRenderer","prototype","isDrawableTile_","tile","tileState","getState","useInterimTilesOnError","getLayer","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","prepareFrame","frameState","layerState","pixelRatio","size","viewState","projection","viewResolution","resolution","viewCenter","center","tileSource","getSource","sourceRevision","getRevision","tileGrid","getTileGridForProjection","z","getZForResolution","tileResolution","getResolution","oversampling","Math","round","extent","undefined","getIntersection","isEmpty","tileRange","getTileRangeForExtentAndZ","imageExtent","getTileRangeExtent","tilePixelRatio","getTilePixelRatio","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","newTiles","x","y","minX","maxX","minY","maxY","getTile","setState","getPreload","getInterimTile","uid","getUid","tileCoord","toString","inTransition","indexOf","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","renderedResolution","hints","viewHints","animatingOrInteracting","ANIMATING","INTERACTING","Date","now","containsExtent","tilePixelSize","getTilePixelSize","width","getWidth","height","getHeight","canvas","equals","clearRect","length","zs","Object","keys","map","Number","sort","a","b","currentResolution","currentScale","currentTilePixelSize","currentZ","i","ii","tileExtent","tileGutter","tilesToDraw","w","h","getGutter","tileCoordKey","getTileCoordExtent","getTileCoord","drawTileImage","push","scale","transform","compose","coordinateToCanvasPixelTransform","updateUsedTiles","usedTiles","manageTilePyramid","scheduleExpireCache","updateLogos","gutter","transition","image","getImage","alpha","getOpaque","alphaChanged","globalAlpha","save","drawImage","restore","animate","endTransition","getImageTransform"],"mappings":"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","sourcesContent":["import _ol_ from '../../index.js';\nimport _ol_LayerType_ from '../../layertype.js';\nimport _ol_TileRange_ from '../../tilerange.js';\nimport _ol_TileState_ from '../../tilestate.js';\nimport _ol_ViewHint_ from '../../viewhint.js';\nimport _ol_dom_ from '../../dom.js';\nimport _ol_extent_ from '../../extent.js';\nimport _ol_renderer_Type_ from '../type.js';\nimport _ol_renderer_canvas_IntermediateCanvas_ from '../canvas/intermediatecanvas.js';\nimport _ol_transform_ from '../../transform.js';\n\n/**\n * @constructor\n * @extends {ol.renderer.canvas.IntermediateCanvas}\n * @param {ol.layer.Tile|ol.layer.VectorTile} tileLayer Tile layer.\n * @api\n */\nvar _ol_renderer_canvas_TileLayer_ = function(tileLayer) {\n\n  _ol_renderer_canvas_IntermediateCanvas_.call(this, tileLayer);\n\n  /**\n   * @protected\n   * @type {CanvasRenderingContext2D}\n   */\n  this.context = this.context === null ? null :  _ol_dom_.createCanvasContext2D();\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.oversampling_;\n\n  /**\n   * @private\n   * @type {ol.Extent}\n   */\n  this.renderedExtent_ = null;\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.renderedRevision;\n\n  /**\n   * @protected\n   * @type {!Array.<ol.Tile>}\n   */\n  this.renderedTiles = [];\n\n  /**\n   * @protected\n   * @type {ol.Extent}\n   */\n  this.tmpExtent = _ol_extent_.createEmpty();\n\n  /**\n   * @private\n   * @type {ol.TileRange}\n   */\n  this.tmpTileRange_ = new _ol_TileRange_(0, 0, 0, 0);\n\n  /**\n   * @private\n   * @type {ol.Transform}\n   */\n  this.imageTransform_ = _ol_transform_.create();\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.zDirection = 0;\n\n};\n\n_ol_.inherits(_ol_renderer_canvas_TileLayer_, _ol_renderer_canvas_IntermediateCanvas_);\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {ol.renderer.Type} type The renderer type.\n * @param {ol.layer.Layer} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n_ol_renderer_canvas_TileLayer_['handles'] = function(type, layer) {\n  return type === _ol_renderer_Type_.CANVAS && layer.getType() === _ol_LayerType_.TILE;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {ol.renderer.Map} mapRenderer The map renderer.\n * @param {ol.layer.Layer} layer The layer to be rendererd.\n * @return {ol.renderer.canvas.TileLayer} The layer renderer.\n */\n_ol_renderer_canvas_TileLayer_['create'] = function(mapRenderer, layer) {\n  return new _ol_renderer_canvas_TileLayer_(/** @type {ol.layer.Tile} */ (layer));\n};\n\n\n/**\n * @private\n * @param {ol.Tile} tile Tile.\n * @return {boolean} Tile is drawable.\n */\n_ol_renderer_canvas_TileLayer_.prototype.isDrawableTile_ = function(tile) {\n  var tileState = tile.getState();\n  var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();\n  return tileState == _ol_TileState_.LOADED ||\n      tileState == _ol_TileState_.EMPTY ||\n      tileState == _ol_TileState_.ERROR && !useInterimTilesOnError;\n};\n\n/**\n * @inheritDoc\n */\n_ol_renderer_canvas_TileLayer_.prototype.prepareFrame = function(frameState, layerState) {\n\n  var pixelRatio = frameState.pixelRatio;\n  var size = frameState.size;\n  var viewState = frameState.viewState;\n  var projection = viewState.projection;\n  var viewResolution = viewState.resolution;\n  var viewCenter = viewState.center;\n\n  var tileLayer = this.getLayer();\n  var tileSource = /** @type {ol.source.Tile} */ (tileLayer.getSource());\n  var sourceRevision = tileSource.getRevision();\n  var tileGrid = tileSource.getTileGridForProjection(projection);\n  var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n  var tileResolution = tileGrid.getResolution(z);\n  var oversampling = Math.round(viewResolution / tileResolution) || 1;\n  var extent = frameState.extent;\n\n  if (layerState.extent !== undefined) {\n    extent = _ol_extent_.getIntersection(extent, layerState.extent);\n  }\n  if (_ol_extent_.isEmpty(extent)) {\n    // Return false to prevent the rendering of the layer.\n    return false;\n  }\n\n  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n  var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n\n  var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n  /**\n   * @type {Object.<number, Object.<string, ol.Tile>>}\n   */\n  var tilesToDrawByZ = {};\n  tilesToDrawByZ[z] = {};\n\n  var findLoadedTiles = this.createLoadedTileFinder(\n      tileSource, projection, tilesToDrawByZ);\n\n  var tmpExtent = this.tmpExtent;\n  var tmpTileRange = this.tmpTileRange_;\n  var newTiles = false;\n  var tile, x, y;\n  for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n      tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n      if (tile.getState() == _ol_TileState_.ERROR) {\n        if (!tileLayer.getUseInterimTilesOnError()) {\n          // When useInterimTilesOnError is false, we consider the error tile as loaded.\n          tile.setState(_ol_TileState_.LOADED);\n        } else if (tileLayer.getPreload() > 0) {\n          // Preloaded tiles for lower resolutions might have finished loading.\n          newTiles = true;\n        }\n      }\n      if (!this.isDrawableTile_(tile)) {\n        tile = tile.getInterimTile();\n      }\n      if (this.isDrawableTile_(tile)) {\n        var uid = _ol_.getUid(this);\n        if (tile.getState() == _ol_TileState_.LOADED) {\n          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n          var inTransition = tile.inTransition(uid);\n          if (!newTiles && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n            newTiles = true;\n          }\n        }\n        if (tile.getAlpha(uid, frameState.time) === 1) {\n          // don't look for alt tiles if alpha is 1\n          continue;\n        }\n      }\n\n      var childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord, tmpTileRange, tmpExtent);\n      var covered = false;\n      if (childTileRange) {\n        covered = findLoadedTiles(z + 1, childTileRange);\n      }\n      if (!covered) {\n        tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n      }\n\n    }\n  }\n\n  var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n  var hints = frameState.viewHints;\n  var animatingOrInteracting = hints[_ol_ViewHint_.ANIMATING] || hints[_ol_ViewHint_.INTERACTING];\n  if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (\n    newTiles ||\n        !(this.renderedExtent_ && _ol_extent_.containsExtent(this.renderedExtent_, extent)) ||\n        this.renderedRevision != sourceRevision ||\n        oversampling != this.oversampling_ ||\n        !animatingOrInteracting && renderedResolution != this.renderedResolution\n  )) {\n\n    var context = this.context;\n    if (context) {\n      var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n      var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n      var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n      var canvas = context.canvas;\n      if (canvas.width != width || canvas.height != height) {\n        this.oversampling_ = oversampling;\n        canvas.width = width;\n        canvas.height = height;\n      } else {\n        if (this.renderedExtent_ && !_ol_extent_.equals(imageExtent, this.renderedExtent_)) {\n          context.clearRect(0, 0, width, height);\n        }\n        oversampling = this.oversampling_;\n      }\n    }\n\n    this.renderedTiles.length = 0;\n    /** @type {Array.<number>} */\n    var zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(function(a, b) {\n      if (a === z) {\n        return 1;\n      } else if (b === z) {\n        return -1;\n      } else {\n        return a > b ? 1 : a < b ? -1 : 0;\n      }\n    });\n    var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n    var tileExtent, tileGutter, tilesToDraw, w, h;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      currentZ = zs[i];\n      currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      currentResolution = tileGrid.getResolution(currentZ);\n      currentScale = currentResolution / tileResolution;\n      tileGutter = tilePixelRatio * tileSource.getGutter(projection);\n      tilesToDraw = tilesToDrawByZ[currentZ];\n      for (var tileCoordKey in tilesToDraw) {\n        tile = tilesToDraw[tileCoordKey];\n        tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n        x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n        y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n        w = currentTilePixelSize[0] * currentScale / oversampling;\n        h = currentTilePixelSize[1] * currentScale / oversampling;\n        this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n        this.renderedTiles.push(tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n    this.renderedExtent_ = imageExtent;\n  }\n\n  var scale = this.renderedResolution / viewResolution;\n  var transform = _ol_transform_.compose(this.imageTransform_,\n      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,\n      scale, scale,\n      0,\n      (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,\n      (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n  _ol_transform_.compose(this.coordinateToCanvasPixelTransform,\n      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],\n      pixelRatio / viewResolution, -pixelRatio / viewResolution,\n      0,\n      -viewCenter[0], -viewCenter[1]);\n\n\n  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,\n      projection, extent, z, tileLayer.getPreload());\n  this.scheduleExpireCache(frameState, tileSource);\n  this.updateLogos(frameState, tileSource);\n\n  return this.renderedTiles.length > 0;\n};\n\n\n/**\n * @param {ol.Tile} tile Tile.\n * @param {olx.FrameState} frameState Frame state.\n * @param {ol.LayerState} layerState Layer state.\n * @param {number} x Left of the tile.\n * @param {number} y Top of the tile.\n * @param {number} w Width of the tile.\n * @param {number} h Height of the tile.\n * @param {number} gutter Tile gutter.\n * @param {boolean} transition Apply an alpha transition.\n */\n_ol_renderer_canvas_TileLayer_.prototype.drawTileImage = function(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n  var image = tile.getImage(this.getLayer());\n  if (!image) {\n    return;\n  }\n  var uid = _ol_.getUid(this);\n  var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n  if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {\n    this.context.clearRect(x, y, w, h);\n  }\n  var alphaChanged = alpha !== this.context.globalAlpha;\n  if (alphaChanged) {\n    this.context.save();\n    this.context.globalAlpha = alpha;\n  }\n  this.context.drawImage(image, gutter, gutter,\n      image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n  if (alphaChanged) {\n    this.context.restore();\n  }\n  if (alpha !== 1) {\n    frameState.animate = true;\n  } else if (transition) {\n    tile.endTransition(uid);\n  }\n};\n\n\n/**\n * @inheritDoc\n */\n_ol_renderer_canvas_TileLayer_.prototype.getImage = function() {\n  var context = this.context;\n  return context ? context.canvas : null;\n};\n\n\n/**\n * @function\n * @return {ol.layer.Tile|ol.layer.VectorTile}\n */\n_ol_renderer_canvas_TileLayer_.prototype.getLayer;\n\n\n/**\n * @inheritDoc\n */\n_ol_renderer_canvas_TileLayer_.prototype.getImageTransform = function() {\n  return this.imageTransform_;\n};\nexport default _ol_renderer_canvas_TileLayer_;\n"]},"metadata":{},"sourceType":"module"}
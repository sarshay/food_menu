{"ast":null,"code":"/**\n * @module ol/webgl/PostProcessingPass\n */\nvar DEFAULT_VERTEX_SHADER = \"\\n  precision mediump float;\\n  \\n  attribute vec2 a_position;\\n  varying vec2 v_texCoord;\\n  varying vec2 v_screenCoord;\\n  \\n  uniform vec2 u_screenSize;\\n   \\n  void main() {\\n    v_texCoord = a_position * 0.5 + 0.5;\\n    v_screenCoord = v_texCoord * u_screenSize;\\n    gl_Position = vec4(a_position, 0.0, 1.0);\\n  }\\n\";\nvar DEFAULT_FRAGMENT_SHADER = \"\\n  precision mediump float;\\n   \\n  uniform sampler2D u_image;\\n   \\n  varying vec2 v_texCoord;\\n   \\n  void main() {\\n    gl_FragColor = texture2D(u_image, v_texCoord);\\n  }\\n\";\n/**\n * @typedef {Object} Options\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {import(\"./Helper\").UniformValue} value Value\n * @property {number} location Location\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @classdesc\n * This class is used to define Post Processing passes with custom shaders and uniforms.\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\n *\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\n *\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\n * premultiplied.\n *\n * Default shaders are shown hereafter:\n *\n * * Vertex shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   attribute vec2 a_position;\n *   varying vec2 v_texCoord;\n *   varying vec2 v_screenCoord;\n *\n *   uniform vec2 u_screenSize;\n *\n *   void main() {\n *     v_texCoord = a_position * 0.5 + 0.5;\n *     v_screenCoord = v_texCoord * u_screenSize;\n *     gl_Position = vec4(a_position, 0.0, 1.0);\n *   }\n *   ```\n *\n * * Fragment shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   uniform sampler2D u_image;\n *\n *   varying vec2 v_texCoord;\n *\n *   void main() {\n *     gl_FragColor = texture2D(u_image, v_texCoord);\n *   }\n *   ```\n *\n * @api\n */\n\nvar WebGLPostProcessingPass =\n/** @class */\nfunction () {\n  /**\n   * @param {Options} options Options.\n   */\n  function WebGLPostProcessingPass(options) {\n    this.gl_ = options.webGlContext;\n    var gl = this.gl_;\n    this.scaleRatio_ = options.scaleRatio || 1;\n    this.renderTargetTexture_ = gl.createTexture();\n    this.renderTargetTextureSize_ = null;\n    this.frameBuffer_ = gl.createFramebuffer(); // compile the program for the frame buffer\n    // TODO: make compilation errors show up\n\n    var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);\n    gl.compileShader(vertexShader);\n    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);\n    gl.compileShader(fragmentShader);\n    this.renderTargetProgram_ = gl.createProgram();\n    gl.attachShader(this.renderTargetProgram_, vertexShader);\n    gl.attachShader(this.renderTargetProgram_, fragmentShader);\n    gl.linkProgram(this.renderTargetProgram_); // bind the vertices buffer for the frame buffer\n\n    this.renderTargetVerticesBuffer_ = gl.createBuffer();\n    var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);\n    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');\n    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');\n    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');\n    /**\n     * Holds info about custom uniforms used in the post processing pass\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n\n    this.uniforms_ = [];\n    options.uniforms && Object.keys(options.uniforms).forEach(function (name) {\n      this.uniforms_.push({\n        value: options.uniforms[name],\n        location: gl.getUniformLocation(this.renderTargetProgram_, name)\n      });\n    }.bind(this));\n  }\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   * @api\n   */\n\n\n  WebGLPostProcessingPass.prototype.getGL = function () {\n    return this.gl_;\n  };\n  /**\n   * Initialize the render target texture of the post process, make sure it is at the\n   * right size and bind it as a render target for the next draw calls.\n   * The last step to be initialized will be the one where the primitives are rendered.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @api\n   */\n\n\n  WebGLPostProcessingPass.prototype.init = function (frameState) {\n    var gl = this.getGL();\n    var textureSize = [gl.drawingBufferWidth * this.scaleRatio_, gl.drawingBufferHeight * this.scaleRatio_]; // rendering goes to my buffer\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n    gl.viewport(0, 0, textureSize[0], textureSize[1]); // if size has changed: adjust canvas & render target texture\n\n    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {\n      this.renderTargetTextureSize_ = textureSize; // create a new texture\n\n      var level = 0;\n      var internalFormat = gl.RGBA;\n      var border = 0;\n      var format = gl.RGBA;\n      var type = gl.UNSIGNED_BYTE;\n      var data = null;\n      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // bind the texture to the framebuffer\n\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);\n    }\n  };\n  /**\n   * Render to the next postprocessing pass (or to the canvas if final pass).\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\n   * @api\n   */\n\n\n  WebGLPostProcessingPass.prototype.apply = function (frameState, nextPass) {\n    var gl = this.getGL();\n    var size = frameState.size;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_); // render the frame buffer to the canvas\n\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.useProgram(this.renderTargetProgram_);\n    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);\n    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n    gl.uniform1i(this.renderTargetTextureLocation_, 0);\n    this.applyUniforms(frameState);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  };\n  /**\n   * @return {WebGLFramebuffer} Frame buffer\n   * @api\n   */\n\n\n  WebGLPostProcessingPass.prototype.getFrameBuffer = function () {\n    return this.frameBuffer_;\n  };\n  /**\n   * Sets the custom uniforms based on what was given in the constructor.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  WebGLPostProcessingPass.prototype.applyUniforms = function (frameState) {\n    var gl = this.getGL();\n    var value;\n    var textureSlot = 1;\n    this.uniforms_.forEach(function (uniform) {\n      value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value; // apply value based on type\n\n      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n        // create a texture & put data\n        if (!uniform.texture) {\n          uniform.texture = gl.createTexture();\n        }\n\n        gl.activeTexture(gl[\"TEXTURE\" + textureSlot]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n        if (value instanceof ImageData) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));\n        } else {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n        } // fill texture slots\n\n\n        gl.uniform1i(uniform.location, textureSlot++);\n      } else if (Array.isArray(value)) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(uniform.location, value[0], value[1]);\n            return;\n\n          case 3:\n            gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n            return;\n\n          case 4:\n            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);\n            return;\n\n          default:\n            return;\n        }\n      } else if (typeof value === 'number') {\n        gl.uniform1f(uniform.location, value);\n      }\n    });\n  };\n\n  return WebGLPostProcessingPass;\n}();\n\nexport default WebGLPostProcessingPass;","map":{"version":3,"sources":["../src/webgl/PostProcessingPass.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/webgl/PostProcessingPass\n */\nvar DEFAULT_VERTEX_SHADER = \"\\n  precision mediump float;\\n  \\n  attribute vec2 a_position;\\n  varying vec2 v_texCoord;\\n  varying vec2 v_screenCoord;\\n  \\n  uniform vec2 u_screenSize;\\n   \\n  void main() {\\n    v_texCoord = a_position * 0.5 + 0.5;\\n    v_screenCoord = v_texCoord * u_screenSize;\\n    gl_Position = vec4(a_position, 0.0, 1.0);\\n  }\\n\";\nvar DEFAULT_FRAGMENT_SHADER = \"\\n  precision mediump float;\\n   \\n  uniform sampler2D u_image;\\n   \\n  varying vec2 v_texCoord;\\n   \\n  void main() {\\n    gl_FragColor = texture2D(u_image, v_texCoord);\\n  }\\n\";\n/**\n * @typedef {Object} Options\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {import(\"./Helper\").UniformValue} value Value\n * @property {number} location Location\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n/**\n * @classdesc\n * This class is used to define Post Processing passes with custom shaders and uniforms.\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\n *\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\n *\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\n * premultiplied.\n *\n * Default shaders are shown hereafter:\n *\n * * Vertex shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   attribute vec2 a_position;\n *   varying vec2 v_texCoord;\n *   varying vec2 v_screenCoord;\n *\n *   uniform vec2 u_screenSize;\n *\n *   void main() {\n *     v_texCoord = a_position * 0.5 + 0.5;\n *     v_screenCoord = v_texCoord * u_screenSize;\n *     gl_Position = vec4(a_position, 0.0, 1.0);\n *   }\n *   ```\n *\n * * Fragment shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   uniform sampler2D u_image;\n *\n *   varying vec2 v_texCoord;\n *\n *   void main() {\n *     gl_FragColor = texture2D(u_image, v_texCoord);\n *   }\n *   ```\n *\n * @api\n */\nvar WebGLPostProcessingPass = /** @class */ (function () {\n    /**\n     * @param {Options} options Options.\n     */\n    function WebGLPostProcessingPass(options) {\n        this.gl_ = options.webGlContext;\n        var gl = this.gl_;\n        this.scaleRatio_ = options.scaleRatio || 1;\n        this.renderTargetTexture_ = gl.createTexture();\n        this.renderTargetTextureSize_ = null;\n        this.frameBuffer_ = gl.createFramebuffer();\n        // compile the program for the frame buffer\n        // TODO: make compilation errors show up\n        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);\n        gl.compileShader(vertexShader);\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);\n        gl.compileShader(fragmentShader);\n        this.renderTargetProgram_ = gl.createProgram();\n        gl.attachShader(this.renderTargetProgram_, vertexShader);\n        gl.attachShader(this.renderTargetProgram_, fragmentShader);\n        gl.linkProgram(this.renderTargetProgram_);\n        // bind the vertices buffer for the frame buffer\n        this.renderTargetVerticesBuffer_ = gl.createBuffer();\n        var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);\n        this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');\n        this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');\n        this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');\n        /**\n         * Holds info about custom uniforms used in the post processing pass\n         * @type {Array<UniformInternalDescription>}\n         * @private\n         */\n        this.uniforms_ = [];\n        options.uniforms &&\n            Object.keys(options.uniforms).forEach(function (name) {\n                this.uniforms_.push({\n                    value: options.uniforms[name],\n                    location: gl.getUniformLocation(this.renderTargetProgram_, name),\n                });\n            }.bind(this));\n    }\n    /**\n     * Get the WebGL rendering context\n     * @return {WebGLRenderingContext} The rendering context.\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.getGL = function () {\n        return this.gl_;\n    };\n    /**\n     * Initialize the render target texture of the post process, make sure it is at the\n     * right size and bind it as a render target for the next draw calls.\n     * The last step to be initialized will be the one where the primitives are rendered.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.init = function (frameState) {\n        var gl = this.getGL();\n        var textureSize = [\n            gl.drawingBufferWidth * this.scaleRatio_,\n            gl.drawingBufferHeight * this.scaleRatio_,\n        ];\n        // rendering goes to my buffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n        gl.viewport(0, 0, textureSize[0], textureSize[1]);\n        // if size has changed: adjust canvas & render target texture\n        if (!this.renderTargetTextureSize_ ||\n            this.renderTargetTextureSize_[0] !== textureSize[0] ||\n            this.renderTargetTextureSize_[1] !== textureSize[1]) {\n            this.renderTargetTextureSize_ = textureSize;\n            // create a new texture\n            var level = 0;\n            var internalFormat = gl.RGBA;\n            var border = 0;\n            var format = gl.RGBA;\n            var type = gl.UNSIGNED_BYTE;\n            var data = null;\n            gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            // bind the texture to the framebuffer\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);\n        }\n    };\n    /**\n     * Render to the next postprocessing pass (or to the canvas if final pass).\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.apply = function (frameState, nextPass) {\n        var gl = this.getGL();\n        var size = frameState.size;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n        // render the frame buffer to the canvas\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n        gl.useProgram(this.renderTargetProgram_);\n        gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n        gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);\n        gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n        gl.uniform1i(this.renderTargetTextureLocation_, 0);\n        this.applyUniforms(frameState);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n    };\n    /**\n     * @return {WebGLFramebuffer} Frame buffer\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.getFrameBuffer = function () {\n        return this.frameBuffer_;\n    };\n    /**\n     * Sets the custom uniforms based on what was given in the constructor.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPostProcessingPass.prototype.applyUniforms = function (frameState) {\n        var gl = this.getGL();\n        var value;\n        var textureSlot = 1;\n        this.uniforms_.forEach(function (uniform) {\n            value =\n                typeof uniform.value === 'function'\n                    ? uniform.value(frameState)\n                    : uniform.value;\n            // apply value based on type\n            if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n                // create a texture & put data\n                if (!uniform.texture) {\n                    uniform.texture = gl.createTexture();\n                }\n                gl.activeTexture(gl[\"TEXTURE\" + textureSlot]);\n                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                if (value instanceof ImageData) {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));\n                }\n                else {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n                }\n                // fill texture slots\n                gl.uniform1i(uniform.location, textureSlot++);\n            }\n            else if (Array.isArray(value)) {\n                switch (value.length) {\n                    case 2:\n                        gl.uniform2f(uniform.location, value[0], value[1]);\n                        return;\n                    case 3:\n                        gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n                        return;\n                    case 4:\n                        gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);\n                        return;\n                    default:\n                        return;\n                }\n            }\n            else if (typeof value === 'number') {\n                gl.uniform1f(uniform.location, value);\n            }\n        });\n    };\n    return WebGLPostProcessingPass;\n}());\nexport default WebGLPostProcessingPass;\n//# sourceMappingURL=PostProcessingPass.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\n\n\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\n\nvar WebGLPointsLayerRenderer =\n/** @class */\nfunction (_super) {\n  __extends(WebGLPointsLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n\n\n  function WebGLPointsLayerRenderer(layer, options) {\n    var _this = this;\n\n    var uniforms = options.uniforms || {};\n    var projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n    _this = _super.call(this, layer, {\n      className: options.className,\n      uniforms: uniforms,\n      postProcesses: options.postProcesses\n    }) || this;\n    _this.sourceRevision_ = -1;\n    _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n    _this.program_ = _this.helper.getProgram(options.fragmentShader, options.vertexShader);\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    _this.hitDetectionEnabled_ = options.hitFragmentShader && options.hitVertexShader ? true : false;\n    _this.hitProgram_ = _this.hitDetectionEnabled_ && _this.helper.getProgram(options.hitFragmentShader, options.hitVertexShader);\n    var customAttributes = options.attributes ? options.attributes.map(function (attribute) {\n      return {\n        name: 'a_' + attribute.name,\n        size: 1,\n        type: AttributeType.FLOAT\n      };\n    }) : [];\n    /**\n     * A list of attributes used by the renderer. By default only the position and\n     * index of the vertex (0 to 3) are required.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n\n    _this.attributes = [{\n      name: 'a_position',\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_index',\n      size: 1,\n      type: AttributeType.FLOAT\n    }].concat(customAttributes);\n    /**\n     * A list of attributes used for hit detection.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     */\n\n    _this.hitDetectionAttributes = [{\n      name: 'a_position',\n      size: 2,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_index',\n      size: 1,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_hitColor',\n      size: 4,\n      type: AttributeType.FLOAT\n    }, {\n      name: 'a_featureUid',\n      size: 1,\n      type: AttributeType.FLOAT\n    }].concat(customAttributes);\n    _this.customAttributes = options.attributes ? options.attributes : [];\n    _this.previousExtent_ = createEmpty();\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n\n    _this.currentTransform_ = projectionMatrixTransform;\n    /**\n     * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n\n    _this.renderTransform_ = createTransform();\n    /**\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n\n    _this.invertRenderTransform_ = createTransform();\n    /**\n     * @type {Float32Array}\n     * @private\n     */\n\n    _this.renderInstructions_ = new Float32Array(0);\n    /**\n     * These instructions are used for hit detection\n     * @type {Float32Array}\n     * @private\n     */\n\n    _this.hitRenderInstructions_ = new Float32Array(0);\n    /**\n     * @type {WebGLRenderTarget}\n     * @private\n     */\n\n    _this.hitRenderTarget_ = _this.hitDetectionEnabled_ && new WebGLRenderTarget(_this.helper);\n    _this.worker_ = createWebGLWorker();\n\n    _this.worker_.addEventListener('message',\n    /**\n     * @param {*} event Event.\n     * @this {WebGLPointsLayerRenderer}\n     */\n    function (event) {\n      var received = event.data;\n\n      if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n        var projectionTransform = received.projectionTransform;\n\n        if (received.hitDetection) {\n          this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.hitVerticesBuffer_);\n        } else {\n          this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n          this.helper.flushBufferData(this.verticesBuffer_);\n        }\n\n        this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n        this.helper.flushBufferData(this.indicesBuffer_);\n        this.renderTransform_ = projectionTransform;\n        makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n\n        if (received.hitDetection) {\n          this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n        } else {\n          this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n        }\n\n        this.getLayer().changed();\n      }\n    }.bind(_this));\n    /**\n     * This object will be updated when the source changes. Key is uid.\n     * @type {Object<string, FeatureCacheItem>}\n     * @private\n     */\n\n\n    _this.featureCache_ = {};\n    /**\n     * Amount of features in the cache.\n     * @type {number}\n     * @private\n     */\n\n    _this.featureCount_ = 0;\n\n    var source = _this.getLayer().getSource();\n\n    _this.sourceListenKeys_ = [listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this), listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this), listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this), listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this)];\n    source.forEachFeature(function (feature) {\n      this.featureCache_[getUid(feature)] = {\n        feature: feature,\n        properties: feature.getProperties(),\n        geometry: feature.getGeometry()\n      };\n      this.featureCount_++;\n    }.bind(_this));\n    return _this;\n  }\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n    var feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry()\n    };\n    this.featureCount_++;\n  };\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n    var feature = event.feature;\n    this.featureCache_[getUid(feature)] = {\n      feature: feature,\n      properties: feature.getProperties(),\n      geometry: feature.getGeometry()\n    };\n  };\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n    var feature = event.feature;\n    delete this.featureCache_[getUid(feature)];\n    this.featureCount_--;\n  };\n  /**\n   * @private\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n    this.featureCache_ = {};\n    this.featureCount_ = 0;\n  };\n  /**\n   * Render the layer.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n    this.preRender(frameState);\n    var renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n    this.helper.finalizeDraw(frameState);\n    var canvas = this.helper.getCanvas();\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    var opacity = layerState.opacity;\n\n    if (opacity !== parseFloat(canvas.style.opacity)) {\n      canvas.style.opacity = String(opacity);\n    }\n\n    if (this.hitDetectionEnabled_) {\n      this.renderHitDetection(frameState);\n      this.hitRenderTarget_.clearCachedData();\n    }\n\n    this.postRender(frameState);\n    return canvas;\n  };\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layer = this.getLayer();\n    var vectorSource = layer.getSource();\n    var viewState = frameState.viewState;\n    var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING];\n    var extentChanged = !equals(this.previousExtent_, frameState.extent);\n    var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      var projection = viewState.projection;\n      var resolution = viewState.resolution;\n      var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      var extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n      this.rebuildBuffers_(frameState);\n      this.previousExtent_ = frameState.extent.slice();\n    } // apply the current projection transform with the invert of the one used to fill buffers\n\n\n    this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n    multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n    this.helper.useProgram(this.program_);\n    this.helper.prepareDraw(frameState); // write new data\n\n    this.helper.bindBuffer(this.verticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.attributes);\n    return true;\n  };\n  /**\n   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n    // saves the projection transform for the current frame state\n    var projectionTransform = createTransform();\n    this.helper.makeProjectionTransform(frameState, projectionTransform); // here we anticipate the amount of render instructions that we well generate\n    // this can be done since we know that for normal render we only have x, y as base instructions,\n    // and x, y, r, g, b, a and featureUid for hit render instructions\n    // and we also know the amount of custom attributes to append to these\n\n    var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n\n    if (!this.renderInstructions_ || this.renderInstructions_.length !== totalInstructionsCount) {\n      this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n    }\n\n    if (this.hitDetectionEnabled_) {\n      var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n\n      if (!this.hitRenderInstructions_ || this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n        this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n      }\n    } // loop on features to fill the buffer\n\n\n    var featureCache, geometry;\n    var tmpCoords = [];\n    var tmpColor = [];\n    var renderIndex = 0;\n    var hitIndex = 0;\n    var hitColor;\n\n    for (var featureUid in this.featureCache_) {\n      featureCache = this.featureCache_[featureUid];\n      geometry =\n      /** @type {import(\"../../geom\").Point} */\n      featureCache.geometry;\n\n      if (!geometry || geometry.getType() !== GeometryType.POINT) {\n        continue;\n      }\n\n      tmpCoords[0] = geometry.getFlatCoordinates()[0];\n      tmpCoords[1] = geometry.getFlatCoordinates()[1];\n      applyTransform(projectionTransform, tmpCoords);\n      hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n      this.renderInstructions_[renderIndex++] = tmpCoords[0];\n      this.renderInstructions_[renderIndex++] = tmpCoords[1]; // for hit detection, the feature uid is saved in the opacity value\n      // and the index of the opacity value is encoded in the color values\n\n      if (this.hitDetectionEnabled_) {\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n        this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n        this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n        this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n      } // pushing custom attributes\n\n\n      var value = void 0;\n\n      for (var j = 0; j < this.customAttributes.length; j++) {\n        value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n        this.renderInstructions_[renderIndex++] = value;\n\n        if (this.hitDetectionEnabled_) {\n          this.hitRenderInstructions_[hitIndex++] = value;\n        }\n      }\n    }\n    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n\n\n    var message = {\n      type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n      renderInstructions: this.renderInstructions_.buffer,\n      customAttributesCount: this.customAttributes.length\n    }; // additional properties will be sent back as-is by the worker\n\n    message['projectionTransform'] = projectionTransform;\n    this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n    this.renderInstructions_ = null;\n    /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n\n    if (this.hitDetectionEnabled_) {\n      var hitMessage = {\n        type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n        renderInstructions: this.hitRenderInstructions_.buffer,\n        customAttributesCount: 5 + this.customAttributes.length\n      };\n      hitMessage['projectionTransform'] = projectionTransform;\n      hitMessage['hitDetection'] = true;\n      this.worker_.postMessage(hitMessage, [this.hitRenderInstructions_.buffer]);\n      this.hitRenderInstructions_ = null;\n    }\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n    assert(this.hitDetectionEnabled_, 66);\n\n    if (!this.hitRenderInstructions_) {\n      return undefined;\n    }\n\n    var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n    var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n    var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n    var index = colorDecodeId(color);\n    var opacity = this.hitRenderInstructions_[index];\n    var uid = Math.floor(opacity).toString();\n    var source = this.getLayer().getSource();\n    var feature = source.getFeatureByUid(uid);\n\n    if (feature) {\n      return callback(feature, this.getLayer(), null);\n    }\n\n    return undefined;\n  };\n  /**\n   * Render the hit detection data to the corresponding render target\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n    // skip render entirely if vertex buffers not ready/generated yet\n    if (!this.hitVerticesBuffer_.getSize()) {\n      return;\n    }\n\n    this.hitRenderTarget_.setSize([Math.floor(frameState.size[0] / 2), Math.floor(frameState.size[1] / 2)]);\n    this.helper.useProgram(this.hitProgram_);\n    this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n    this.helper.bindBuffer(this.hitVerticesBuffer_);\n    this.helper.bindBuffer(this.indicesBuffer_);\n    this.helper.enableAttributes(this.hitDetectionAttributes);\n    var renderCount = this.indicesBuffer_.getSize();\n    this.helper.drawElements(0, renderCount);\n  };\n  /**\n   * Clean up.\n   */\n\n\n  WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n\n    _super.prototype.disposeInternal.call(this);\n  };\n\n  return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer);\n\nexport default WebGLPointsLayerRenderer;","map":{"version":3,"sources":["../../src/renderer/webgl/PointsLayer.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId, } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLPointsLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n     * @param {Options} options Options.\n     */\n    function WebGLPointsLayerRenderer(layer, options) {\n        var _this = this;\n        var uniforms = options.uniforms || {};\n        var projectionMatrixTransform = createTransform();\n        uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n        _this = _super.call(this, layer, {\n            className: options.className,\n            uniforms: uniforms,\n            postProcesses: options.postProcesses,\n        }) || this;\n        _this.sourceRevision_ = -1;\n        _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.program_ = _this.helper.getProgram(options.fragmentShader, options.vertexShader);\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.hitDetectionEnabled_ =\n            options.hitFragmentShader && options.hitVertexShader ? true : false;\n        _this.hitProgram_ =\n            _this.hitDetectionEnabled_ &&\n                _this.helper.getProgram(options.hitFragmentShader, options.hitVertexShader);\n        var customAttributes = options.attributes\n            ? options.attributes.map(function (attribute) {\n                return {\n                    name: 'a_' + attribute.name,\n                    size: 1,\n                    type: AttributeType.FLOAT,\n                };\n            })\n            : [];\n        /**\n         * A list of attributes used by the renderer. By default only the position and\n         * index of the vertex (0 to 3) are required.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.attributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        /**\n         * A list of attributes used for hit detection.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.hitDetectionAttributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_hitColor',\n                size: 4,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_featureUid',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        _this.customAttributes = options.attributes ? options.attributes : [];\n        _this.previousExtent_ = createEmpty();\n        /**\n         * This transform is updated on every frame and is the composition of:\n         * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n         * - current world->screen transform\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.currentTransform_ = projectionMatrixTransform;\n        /**\n         * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.renderTransform_ = createTransform();\n        /**\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.invertRenderTransform_ = createTransform();\n        /**\n         * @type {Float32Array}\n         * @private\n         */\n        _this.renderInstructions_ = new Float32Array(0);\n        /**\n         * These instructions are used for hit detection\n         * @type {Float32Array}\n         * @private\n         */\n        _this.hitRenderInstructions_ = new Float32Array(0);\n        /**\n         * @type {WebGLRenderTarget}\n         * @private\n         */\n        _this.hitRenderTarget_ =\n            _this.hitDetectionEnabled_ && new WebGLRenderTarget(_this.helper);\n        _this.worker_ = createWebGLWorker();\n        _this.worker_.addEventListener('message', \n        /**\n         * @param {*} event Event.\n         * @this {WebGLPointsLayerRenderer}\n         */\n        function (event) {\n            var received = event.data;\n            if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n                var projectionTransform = received.projectionTransform;\n                if (received.hitDetection) {\n                    this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.hitVerticesBuffer_);\n                }\n                else {\n                    this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.verticesBuffer_);\n                }\n                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n                this.helper.flushBufferData(this.indicesBuffer_);\n                this.renderTransform_ = projectionTransform;\n                makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n                if (received.hitDetection) {\n                    this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                else {\n                    this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                this.getLayer().changed();\n            }\n        }.bind(_this));\n        /**\n         * This object will be updated when the source changes. Key is uid.\n         * @type {Object<string, FeatureCacheItem>}\n         * @private\n         */\n        _this.featureCache_ = {};\n        /**\n         * Amount of features in the cache.\n         * @type {number}\n         * @private\n         */\n        _this.featureCount_ = 0;\n        var source = _this.getLayer().getSource();\n        _this.sourceListenKeys_ = [\n            listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n            listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n            listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n            listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this),\n        ];\n        source.forEachFeature(function (feature) {\n            this.featureCache_[getUid(feature)] = {\n                feature: feature,\n                properties: feature.getProperties(),\n                geometry: feature.getGeometry(),\n            };\n            this.featureCount_++;\n        }.bind(_this));\n        return _this;\n    }\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n        var feature = event.feature;\n        delete this.featureCache_[getUid(feature)];\n        this.featureCount_--;\n    };\n    /**\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n        this.featureCache_ = {};\n        this.featureCount_ = 0;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n        this.preRender(frameState);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n        this.helper.finalizeDraw(frameState);\n        var canvas = this.helper.getCanvas();\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var opacity = layerState.opacity;\n        if (opacity !== parseFloat(canvas.style.opacity)) {\n            canvas.style.opacity = String(opacity);\n        }\n        if (this.hitDetectionEnabled_) {\n            this.renderHitDetection(frameState);\n            this.hitRenderTarget_.clearCachedData();\n        }\n        this.postRender(frameState);\n        return canvas;\n    };\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLPointsLayerRenderer.prototype.prepareFrame = function (frameState) {\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        var viewState = frameState.viewState;\n        var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] &&\n            !frameState.viewHints[ViewHint.INTERACTING];\n        var extentChanged = !equals(this.previousExtent_, frameState.extent);\n        var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n        if (sourceChanged) {\n            this.sourceRevision_ = vectorSource.getRevision();\n        }\n        if (viewNotMoving && (extentChanged || sourceChanged)) {\n            var projection = viewState.projection;\n            var resolution = viewState.resolution;\n            var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n            var extent = buffer(frameState.extent, renderBuffer * resolution);\n            vectorSource.loadFeatures(extent, resolution, projection);\n            this.rebuildBuffers_(frameState);\n            this.previousExtent_ = frameState.extent.slice();\n        }\n        // apply the current projection transform with the invert of the one used to fill buffers\n        this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n        multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState);\n        // write new data\n        this.helper.bindBuffer(this.verticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.attributes);\n        return true;\n    };\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n        // saves the projection transform for the current frame state\n        var projectionTransform = createTransform();\n        this.helper.makeProjectionTransform(frameState, projectionTransform);\n        // here we anticipate the amount of render instructions that we well generate\n        // this can be done since we know that for normal render we only have x, y as base instructions,\n        // and x, y, r, g, b, a and featureUid for hit render instructions\n        // and we also know the amount of custom attributes to append to these\n        var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n        if (!this.renderInstructions_ ||\n            this.renderInstructions_.length !== totalInstructionsCount) {\n            this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n        }\n        if (this.hitDetectionEnabled_) {\n            var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n            if (!this.hitRenderInstructions_ ||\n                this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n            }\n        }\n        // loop on features to fill the buffer\n        var featureCache, geometry;\n        var tmpCoords = [];\n        var tmpColor = [];\n        var renderIndex = 0;\n        var hitIndex = 0;\n        var hitColor;\n        for (var featureUid in this.featureCache_) {\n            featureCache = this.featureCache_[featureUid];\n            geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n            if (!geometry || geometry.getType() !== GeometryType.POINT) {\n                continue;\n            }\n            tmpCoords[0] = geometry.getFlatCoordinates()[0];\n            tmpCoords[1] = geometry.getFlatCoordinates()[1];\n            applyTransform(projectionTransform, tmpCoords);\n            hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n            this.renderInstructions_[renderIndex++] = tmpCoords[0];\n            this.renderInstructions_[renderIndex++] = tmpCoords[1];\n            // for hit detection, the feature uid is saved in the opacity value\n            // and the index of the opacity value is encoded in the color values\n            if (this.hitDetectionEnabled_) {\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n            }\n            // pushing custom attributes\n            var value = void 0;\n            for (var j = 0; j < this.customAttributes.length; j++) {\n                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n                this.renderInstructions_[renderIndex++] = value;\n                if (this.hitDetectionEnabled_) {\n                    this.hitRenderInstructions_[hitIndex++] = value;\n                }\n            }\n        }\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        var message = {\n            type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n            renderInstructions: this.renderInstructions_.buffer,\n            customAttributesCount: this.customAttributes.length,\n        };\n        // additional properties will be sent back as-is by the worker\n        message['projectionTransform'] = projectionTransform;\n        this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n        this.renderInstructions_ = null;\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        if (this.hitDetectionEnabled_) {\n            var hitMessage = {\n                type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n                renderInstructions: this.hitRenderInstructions_.buffer,\n                customAttributesCount: 5 + this.customAttributes.length,\n            };\n            hitMessage['projectionTransform'] = projectionTransform;\n            hitMessage['hitDetection'] = true;\n            this.worker_.postMessage(hitMessage, [\n                this.hitRenderInstructions_.buffer,\n            ]);\n            this.hitRenderInstructions_ = null;\n        }\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        assert(this.hitDetectionEnabled_, 66);\n        if (!this.hitRenderInstructions_) {\n            return undefined;\n        }\n        var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n        var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n        var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n        var index = colorDecodeId(color);\n        var opacity = this.hitRenderInstructions_[index];\n        var uid = Math.floor(opacity).toString();\n        var source = this.getLayer().getSource();\n        var feature = source.getFeatureByUid(uid);\n        if (feature) {\n            return callback(feature, this.getLayer(), null);\n        }\n        return undefined;\n    };\n    /**\n     * Render the hit detection data to the corresponding render target\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n     */\n    WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n        // skip render entirely if vertex buffers not ready/generated yet\n        if (!this.hitVerticesBuffer_.getSize()) {\n            return;\n        }\n        this.hitRenderTarget_.setSize([\n            Math.floor(frameState.size[0] / 2),\n            Math.floor(frameState.size[1] / 2),\n        ]);\n        this.helper.useProgram(this.hitProgram_);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n        this.helper.bindBuffer(this.hitVerticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.hitDetectionAttributes);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n        this.worker_.terminate();\n        this.layer_ = null;\n        this.sourceListenKeys_.forEach(function (key) {\n            unlistenByKey(key);\n        });\n        this.sourceListenKeys_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLPointsLayerRenderer;\n//# sourceMappingURL=PointsLayer.js.map"]},"metadata":{},"sourceType":"module"}
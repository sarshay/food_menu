{"ast":null,"code":"/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport Circle from 'ol/style/Circle.js';\nimport Fill from 'ol/style/Fill.js';\nimport Icon from 'ol/style/Icon.js';\nimport RenderFeature from 'ol/render/Feature.js';\nimport Stroke from 'ol/style/Stroke.js';\nimport Style from 'ol/style/Style.js';\nimport Text from 'ol/style/Text.js';\nimport mb2css from 'mapbox-to-css-font';\nimport { Color, featureFilter as createFilter, derefLayers, expression, function as fn, latest as spec } from '@mapbox/mapbox-gl-style-spec';\nimport { applyLetterSpacing, createCanvas, defaultResolutions, deg2rad, getZoomForResolution, wrapText } from './util.js';\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\n\nvar isFunction = fn.isFunction;\nvar convertFunction = fn.convertFunction;\nvar isExpression = expression.isExpression;\nvar createPropertyExpression = expression.createPropertyExpression;\nvar types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\nvar anchor = {\n  'center': [0.5, 0.5],\n  'left': [0, 0.5],\n  'right': [1, 0.5],\n  'top': [0.5, 0],\n  'bottom': [0.5, 1],\n  'top-left': [0, 0],\n  'top-right': [1, 0],\n  'bottom-left': [0, 1],\n  'bottom-right': [1, 1]\n};\n\nvar expressionData = function (rawExpression, propertySpec) {\n  var compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n\n  if (compiledExpression.result === 'error') {\n    throw new Error(compiledExpression.value.map(function (err) {\n      return err.key + \": \" + err.message;\n    }).join(', '));\n  }\n\n  return compiledExpression.value;\n};\n\nvar emptyObj = {};\nvar zoomObj = {\n  zoom: 0\n};\n/** @private */\n\nvar functionCache = {};\nvar renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\n\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n  var layerId = layer.id;\n\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n\n  var functions = functionCache[layerId];\n\n  if (!functions[property]) {\n    var value_1 = (layer[layoutOrPaint] || emptyObj)[property];\n    var propertySpec = spec[layoutOrPaint + \"_\" + layer.type][property];\n\n    if (value_1 === undefined) {\n      value_1 = propertySpec.default;\n    }\n\n    var isExpr = isExpression(value_1);\n\n    if (!isExpr && isFunction(value_1)) {\n      value_1 = convertFunction(value_1, propertySpec);\n      isExpr = true;\n    }\n\n    if (isExpr) {\n      var compiledExpression = expressionData(value_1, propertySpec);\n      functions[property] = compiledExpression.evaluate.bind(compiledExpression);\n    } else {\n      if (propertySpec.type == 'color') {\n        value_1 = Color.parse(value_1);\n      }\n\n      functions[property] = function () {\n        return value_1;\n      };\n    }\n  }\n\n  zoomObj.zoom = zoom;\n  return functions[property](zoomObj, feature);\n}\n/** @private */\n\nvar filterCache = {};\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\n\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = createFilter(filter).filter;\n  }\n\n  zoomObj.zoom = zoom;\n  return filterCache[layerId](zoomObj, feature);\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\n\n\nfunction colorWithOpacity(color, opacity) {\n  if (color) {\n    if (color.a === 0 || opacity === 0) {\n      return undefined;\n    }\n\n    var a = color.a;\n    opacity = opacity === undefined ? 1 : opacity;\n    return 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';\n  }\n\n  return color;\n}\n\nvar templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\n\nfunction fromTemplate(text, properties) {\n  var parts;\n\n  do {\n    parts = text.match(templateRegEx);\n\n    if (parts) {\n      var value = properties[parts[2]] || '';\n      text = parts[1] + value + parts[3];\n    }\n  } while (parts);\n\n  return text;\n}\n\nvar recordLayer = false;\n/**\n * ```js\n * import {recordStyleLayer} from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Turns recording of the Mapbox Style's `layer` on and off. When turned on,\n * the layer that a rendered feature belongs to will be set as the feature's\n * `mapbox-layer` property.\n * @param {boolean} [record=false] Recording of the style layer is on.\n */\n\nexport function recordStyleLayer(record) {\n  recordLayer = record;\n}\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395, 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\n\nexport default function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts) {\n  if (resolutions === void 0) {\n    resolutions = defaultResolutions;\n  }\n\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n\n  var spriteImage, spriteImgSize;\n\n  if (spriteImageUrl) {\n    if (typeof Image !== 'undefined') {\n      var img_1 = new Image();\n      img_1.crossOrigin = 'anonymous';\n\n      img_1.onload = function () {\n        spriteImage = img_1;\n        spriteImgSize = [img_1.width, img_1.height];\n        olLayer.changed();\n        img_1.onload = null;\n      };\n\n      img_1.src = spriteImageUrl;\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n      //eslint-disable-line\n      var worker =\n      /** @type {*} */\n      self; // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n\n      worker.postMessage({\n        action: 'loadImage',\n        src: spriteImageUrl\n      });\n      worker.addEventListener('message', function handler(event) {\n        if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {\n          spriteImage = event.data.image;\n          spriteImgSize = [spriteImage.width, spriteImage.height];\n        }\n      });\n    }\n  }\n\n  var allLayers = derefLayers(glStyle.layers);\n  var layersBySourceLayer = {};\n  var mapboxLayers = [];\n  var mapboxSource;\n\n  for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n    var layer = allLayers[i];\n    var layerId = layer.id;\n\n    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {\n      var sourceLayer = layer['source-layer'];\n\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n        var source_1 = glStyle.sources[mapboxSource];\n\n        if (!source_1) {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not defined\");\n        }\n\n        var type = source_1.type;\n\n        if (type !== 'vector' && type !== 'geojson') {\n          throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not of type \\\"vector\\\" or \\\"geojson\\\", but \\\"\" + type + \"\\\"\");\n        }\n      }\n\n      var layers = layersBySourceLayer[sourceLayer];\n\n      if (!layers) {\n        layers = [];\n        layersBySourceLayer[sourceLayer] = layers;\n      }\n\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    } // TODO revisit when diffing gets added\n\n\n    delete functionCache[layerId];\n    delete filterCache[layerId];\n  }\n\n  var textHalo = new Stroke();\n  var textColor = new Fill();\n  var iconImageCache = {};\n  var patternCache = {};\n  var styles = [];\n\n  var styleFunction = function (feature, resolution) {\n    var properties = feature.getProperties();\n    var layers = layersBySourceLayer[properties.layer];\n\n    if (!layers) {\n      return;\n    }\n\n    var zoom = resolutions.indexOf(resolution);\n\n    if (zoom == -1) {\n      zoom = getZoomForResolution(resolution, resolutions);\n    }\n\n    var type = types[feature.getGeometry().getType()];\n    var f = {\n      properties: properties,\n      type: type\n    };\n    var stylesLength = -1;\n    var featureBelongsToLayer;\n\n    var _loop_1 = function (i, ii) {\n      var layerData = layers[i];\n      var layer = layerData.layer;\n      var layerId = layer.id;\n      var layout = layer.layout || emptyObj;\n      var paint = layer.paint || emptyObj;\n\n      if (layout.visibility === 'none' || 'minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {\n        return \"continue\";\n      }\n\n      var filter = layer.filter;\n\n      if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n        featureBelongsToLayer = layer;\n        var color = void 0,\n            opacity = void 0,\n            fill = void 0,\n            stroke = void 0,\n            strokeColor = void 0,\n            style = void 0;\n        var index = layerData.index;\n\n        if (type == 3 && (layer.type == 'fill' || layer.type == 'fill-extrusion')) {\n          opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f);\n\n          if (layer.type + '-pattern' in paint) {\n            var fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f);\n\n            if (fillIcon) {\n              var icon_1 = typeof fillIcon === 'string' ? fromTemplate(fillIcon, properties) : fillIcon.toString();\n\n              if (spriteImage && spriteData && spriteData[icon_1]) {\n                ++stylesLength;\n                style = styles[stylesLength];\n\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = new Style({\n                    fill: new Fill()\n                  });\n                  styles[stylesLength] = style;\n                }\n\n                fill = style.getFill();\n                style.setZIndex(index);\n                var icon_cache_key = icon_1 + '.' + opacity;\n                var pattern = patternCache[icon_cache_key];\n\n                if (!pattern) {\n                  var spriteImageData = spriteData[icon_1];\n                  var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                  var ctx =\n                  /** @type {CanvasRenderingContext2D} */\n                  canvas.getContext('2d');\n                  ctx.globalAlpha = opacity;\n                  ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                  pattern = ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon_cache_key] = pattern;\n                }\n\n                fill.setColor(pattern);\n              }\n            }\n          } else {\n            color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f), opacity);\n\n            if (color) {\n              if (layer.type + '-outline-color' in paint) {\n                strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f), opacity);\n              }\n\n              if (!strokeColor) {\n                strokeColor = color;\n              }\n\n              ++stylesLength;\n              style = styles[stylesLength];\n\n              if (!style || !(style.getFill() && style.getStroke()) || style.getText()) {\n                style = new Style({\n                  fill: new Fill(),\n                  stroke: new Stroke()\n                });\n                styles[stylesLength] = style;\n              }\n\n              fill = style.getFill();\n              fill.setColor(color);\n              stroke = style.getStroke();\n              stroke.setColor(strokeColor);\n              stroke.setWidth(1);\n              style.setZIndex(index);\n            }\n          }\n        }\n\n        if (type != 1 && layer.type == 'line') {\n          color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f)) : undefined;\n          var width_1 = getValue(layer, 'paint', 'line-width', zoom, f);\n\n          if (color && width_1 > 0) {\n            ++stylesLength;\n            style = styles[stylesLength];\n\n            if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n              style = new Style({\n                stroke: new Stroke()\n              });\n              styles[stylesLength] = style;\n            }\n\n            stroke = style.getStroke();\n            stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n            stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n            stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n            stroke.setColor(color);\n            stroke.setWidth(width_1);\n            stroke.setLineDash(paint['line-dasharray'] ? getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {\n              return x * width_1;\n            }) : null);\n            style.setZIndex(index);\n          }\n        }\n\n        var hasImage = false;\n        var text = null;\n        var placementAngle = 0;\n        var icon = void 0,\n            iconImg = void 0,\n            skipLabel = void 0;\n\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n\n          if (iconImage) {\n            icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();\n            var styleGeom = undefined;\n\n            if (spriteImage && spriteData && spriteData[icon]) {\n              var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n\n              if (type == 2) {\n                var geom = feature.getGeometry(); // ol package and ol-debug.js only\n\n                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                  var extent = geom.getExtent();\n                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    var midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();\n\n                    if (!renderFeature) {\n                      renderFeatureCoordinates = [NaN, NaN];\n                      renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                    }\n\n                    styleGeom = renderFeature;\n                    renderFeatureCoordinates[0] = midpoint[0];\n                    renderFeatureCoordinates[1] = midpoint[1];\n                    var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n\n                    if (placement === 'line' && iconRotationAlignment === 'map') {\n                      var stride = geom.getStride();\n                      var coordinates = geom.getFlatCoordinates();\n\n                      for (var i_1 = 0, ii_1 = coordinates.length - stride; i_1 < ii_1; i_1 += stride) {\n                        var x1 = coordinates[i_1];\n                        var y1 = coordinates[i_1 + 1];\n                        var x2 = coordinates[i_1 + stride];\n                        var y2 = coordinates[i_1 + stride + 1];\n                        var minX = Math.min(x1, x2);\n                        var minY = Math.min(y1, y2);\n                        var maxX = Math.max(x1, x2);\n                        var maxY = Math.max(y1, y2);\n\n                        if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {\n                          placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                          break;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n\n              if (type !== 2 || styleGeom) {\n                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                var iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f) : null;\n\n                if (!iconColor || iconColor.a !== 0) {\n                  var icon_cache_key = icon + '.' + iconSize;\n\n                  if (iconColor !== null) {\n                    icon_cache_key += '.' + iconColor;\n                  }\n\n                  iconImg = iconImageCache[icon_cache_key];\n\n                  if (!iconImg) {\n                    var spriteImageData = spriteData[icon];\n\n                    if (iconColor !== null) {\n                      // cut out the sprite and color it\n                      var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                      var ctx =\n                      /** @type {CanvasRenderingContext2D} */\n                      canvas.getContext('2d');\n                      ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                      var data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n                      for (var c = 0, cc = data.data.length; c < cc; c += 4) {\n                        var a = iconColor.a;\n\n                        if (a !== 0) {\n                          data.data[c] = iconColor.r * 255 / a;\n                          data.data[c + 1] = iconColor.g * 255 / a;\n                          data.data[c + 2] = iconColor.b * 255 / a;\n                        }\n\n                        data.data[c + 3] = a;\n                      }\n\n                      ctx.putImageData(data, 0, 0);\n                      iconImg = new Icon({\n                        img: canvas,\n                        imgSize: [canvas.width, canvas.height],\n                        scale: iconSize / spriteImageData.pixelRatio\n                      });\n                      iconImageCache[icon_cache_key] = iconImg;\n                    } else {\n                      iconImg = new Icon({\n                        img: spriteImage,\n                        imgSize: spriteImgSize,\n                        size: [spriteImageData.width, spriteImageData.height],\n                        offset: [spriteImageData.x, spriteImageData.y],\n                        rotateWithView: iconRotationAlignment === 'map',\n                        scale: iconSize / spriteImageData.pixelRatio\n                      });\n                      iconImageCache[icon_cache_key] = iconImg;\n                    }\n                  }\n                }\n\n                if (iconImg) {\n                  ++stylesLength;\n                  style = styles[stylesLength];\n\n                  if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                    style = new Style();\n                    styles[stylesLength] = style;\n                  }\n\n                  style.setGeometry(styleGeom);\n                  iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                  iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                  iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                  style.setImage(iconImg);\n                  text = style.getText();\n                  style.setText(undefined);\n                  style.setZIndex(index);\n                  hasImage = true;\n                  skipLabel = false;\n                }\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n\n        if (type == 1 && 'circle-radius' in paint) {\n          ++stylesLength;\n          style = styles[stylesLength];\n\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = new Style();\n            styles[stylesLength] = style;\n          }\n\n          var circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n          var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n          var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n          var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n\n          if (!iconImg) {\n            iconImg = new Circle({\n              radius: circleRadius,\n              stroke: circleStrokeColor && circleStrokeWidth > 0 ? new Stroke({\n                width: circleStrokeWidth,\n                color: circleStrokeColor\n              }) : undefined,\n              fill: circleColor ? new Fill({\n                color: circleColor\n              }) : undefined\n            });\n            iconImageCache[cache_key] = iconImg;\n          }\n\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(index);\n          hasImage = true;\n        }\n\n        var label = void 0;\n\n        if ('text-field' in layout) {\n          var textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n          label = fromTemplate(textField, properties).trim();\n          opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n        }\n\n        if (label && opacity && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            style = styles[stylesLength];\n\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = new Style();\n              styles[stylesLength] = style;\n            }\n\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n\n          if (!style.getText()) {\n            style.setText(text || new Text({\n              padding: [2, 2, 2, 2]\n            }));\n          }\n\n          text = style.getText();\n          var textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n          var fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n          var textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n          var font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n          var textTransform = layout['text-transform'];\n\n          if (textTransform == 'uppercase') {\n            label = label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = label.toLowerCase();\n          }\n\n          var maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n          var letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n          var wrappedLabel = type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n          var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n          var placement = hasImage || type == 1 ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n          text.setPlacement(placement);\n          var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n          var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n          var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f); // Text offset has to take halo width and line height into account\n\n          var vOffset = 0;\n          var hOffset = 0;\n\n          if (placement == 'point') {\n            var textAlign = 'center';\n\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n              hOffset = textHaloWidth;\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n              hOffset = -textHaloWidth;\n            }\n\n            text.setTextAlign(textAlign);\n            var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n            text.setRotateWithView(textRotationAlignment == 'map');\n          } else {\n            text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) * label.length / wrappedLabel.length);\n            text.setTextAlign();\n            text.setRotateWithView(false);\n          }\n\n          var textBaseline = 'middle';\n\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n            vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n            vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;\n          }\n\n          text.setTextBaseline(textBaseline);\n          text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n          textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n          text.setFill(textColor);\n          var haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n\n          if (haloColor) {\n            textHalo.setColor(haloColor); // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n            // Halo width must be doubled because it is applied around the center of the text outline\n\n            textHaloWidth *= 2; // 1/4 of text size (spec) x 2\n\n            var halfTextSize = 0.5 * textSize;\n            textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n\n          var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n          var padding = text.getPadding();\n\n          if (textPadding !== padding[0]) {\n            padding[0] = textPadding;\n            padding[1] = textPadding;\n            padding[2] = textPadding;\n            padding[3] = textPadding;\n          }\n\n          style.setZIndex(index);\n        }\n      }\n    };\n\n    for (var i = 0, ii = layers.length; i < ii; ++i) {\n      _loop_1(i, ii);\n    }\n\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n\n      if (recordLayer) {\n        if (typeof feature.set === 'function') {\n          // ol/Feature\n          feature.set('mapbox-layer', featureBelongsToLayer);\n        } else {\n          // ol/render/Feature\n          feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;\n        }\n      }\n\n      return styles;\n    }\n  };\n\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  return styleFunction;\n}\nexport { colorWithOpacity as _colorWithOpacity, filterCache as _filterCache, evaluateFilter as _evaluateFilter, fromTemplate as _fromTemplate, getValue as _getValue, functionCache as _functionCache };","map":{"version":3,"sources":["../src/stylefunction.js"],"names":[],"mappings":"AAAA;;;;AAIE;AAEF,OAAO,MAAP,MAAmB,oBAAnB;AACA,OAAO,IAAP,MAAiB,kBAAjB;AACA,OAAO,IAAP,MAAiB,kBAAjB;AACA,OAAO,aAAP,MAA0B,sBAA1B;AACA,OAAO,MAAP,MAAmB,oBAAnB;AACA,OAAO,KAAP,MAAkB,mBAAlB;AACA,OAAO,IAAP,MAAiB,kBAAjB;AAEA,OAAO,MAAP,MAAmB,oBAAnB;AACA,SACE,KADF,EAEE,aAAa,IAAI,YAFnB,EAGE,WAHF,EAIE,UAJF,EAKE,QAAQ,IAAI,EALd,EAME,MAAM,IAAI,IANZ,QAOO,8BAPP;AAQA,SACE,kBADF,EAEE,YAFF,EAGE,kBAHF,EAIE,OAJF,EAKE,oBALF,EAME,QANF,QAOO,WAPP;AASA;;;;AAIG;;AAEH,IAAM,UAAU,GAAG,EAAE,CAAC,UAAtB;AACA,IAAM,eAAe,GAAG,EAAE,CAAC,eAA3B;AACA,IAAM,YAAY,GAAG,UAAU,CAAC,YAAhC;AACA,IAAM,wBAAwB,GAAG,UAAU,CAAC,wBAA5C;AAEA,IAAM,KAAK,GAAG;AACZ,WAAS,CADG;AAEZ,gBAAc,CAFF;AAGZ,gBAAc,CAHF;AAIZ,qBAAmB,CAJP;AAKZ,aAAW,CALC;AAMZ,kBAAgB;AANJ,CAAd;AAQA,IAAM,MAAM,GAAG;AACb,YAAU,CAAC,GAAD,EAAM,GAAN,CADG;AAEb,UAAQ,CAAC,CAAD,EAAI,GAAJ,CAFK;AAGb,WAAS,CAAC,CAAD,EAAI,GAAJ,CAHI;AAIb,SAAO,CAAC,GAAD,EAAM,CAAN,CAJM;AAKb,YAAU,CAAC,GAAD,EAAM,CAAN,CALG;AAMb,cAAY,CAAC,CAAD,EAAI,CAAJ,CANC;AAOb,eAAa,CAAC,CAAD,EAAI,CAAJ,CAPA;AAQb,iBAAe,CAAC,CAAD,EAAI,CAAJ,CARF;AASb,kBAAgB,CAAC,CAAD,EAAI,CAAJ;AATH,CAAf;;AAYA,IAAM,cAAc,GAAG,UAAU,aAAV,EAAyB,YAAzB,EAAqC;AAC1D,MAAM,kBAAkB,GAAG,wBAAwB,CACjD,aADiD,EAEjD,YAFiD,CAAnD;;AAIA,MAAI,kBAAkB,CAAC,MAAnB,KAA8B,OAAlC,EAA2C;AACzC,UAAM,IAAI,KAAJ,CACJ,kBAAkB,CAAC,KAAnB,CACG,GADH,CACO,UAAC,GAAD,EAAI;AAAK,aAAG,GAAG,CAAC,GAAJ,GAAO,IAAP,GAAY,GAAG,CAAlB,OAAA;AAA4B,KAD5C,EAEG,IAFH,CAEQ,IAFR,CADI,CAAN;AAKD;;AACD,SAAO,kBAAkB,CAAC,KAA1B;AACD,CAbD;;AAeA,IAAM,QAAQ,GAAG,EAAjB;AACA,IAAM,OAAO,GAAG;AAAC,EAAA,IAAI,EAAE;AAAP,CAAhB;AACA;;AACA,IAAM,aAAa,GAAG,EAAtB;AACA,IAAI,wBAAJ,EAA8B,aAA9B;AAEA;;;;;;;;AAQG;;AACH,OAAM,SAAU,QAAV,CAAmB,KAAnB,EAA0B,aAA1B,EAAyC,QAAzC,EAAmD,IAAnD,EAAyD,OAAzD,EAAgE;AACpE,MAAM,OAAO,GAAG,KAAK,CAAC,EAAtB;;AACA,MAAI,CAAC,aAAa,CAAC,OAAD,CAAlB,EAA6B;AAC3B,IAAA,aAAa,CAAC,OAAD,CAAb,GAAyB,EAAzB;AACD;;AACD,MAAM,SAAS,GAAG,aAAa,CAAC,OAAD,CAA/B;;AACA,MAAI,CAAC,SAAS,CAAC,QAAD,CAAd,EAA0B;AACxB,QAAI,OAAK,GAAG,CAAC,KAAK,CAAC,aAAD,CAAL,IAAwB,QAAzB,EAAmC,QAAnC,CAAZ;AACA,QAAM,YAAY,GAAG,IAAI,CAAI,aAAa,GAAA,GAAb,GAAiB,KAAK,CAAC,IAA3B,CAAJ,CAAuC,QAAvC,CAArB;;AACA,QAAI,OAAK,KAAK,SAAd,EAAyB;AACvB,MAAA,OAAK,GAAG,YAAY,CAAC,OAArB;AACD;;AACD,QAAI,MAAM,GAAG,YAAY,CAAC,OAAD,CAAzB;;AACA,QAAI,CAAC,MAAD,IAAW,UAAU,CAAC,OAAD,CAAzB,EAAkC;AAChC,MAAA,OAAK,GAAG,eAAe,CAAC,OAAD,EAAQ,YAAR,CAAvB;AACA,MAAA,MAAM,GAAG,IAAT;AACD;;AACD,QAAI,MAAJ,EAAY;AACV,UAAM,kBAAkB,GAAG,cAAc,CAAC,OAAD,EAAQ,YAAR,CAAzC;AACA,MAAA,SAAS,CAAC,QAAD,CAAT,GACE,kBAAkB,CAAC,QAAnB,CAA4B,IAA5B,CAAiC,kBAAjC,CADF;AAED,KAJD,MAIO;AACL,UAAI,YAAY,CAAC,IAAb,IAAqB,OAAzB,EAAkC;AAChC,QAAA,OAAK,GAAG,KAAK,CAAC,KAAN,CAAY,OAAZ,CAAR;AACD;;AACD,MAAA,SAAS,CAAC,QAAD,CAAT,GAAsB,YAAA;AACpB,eAAO,OAAP;AACD,OAFD;AAGD;AACF;;AACD,EAAA,OAAO,CAAC,IAAR,GAAe,IAAf;AACA,SAAO,SAAS,CAAC,QAAD,CAAT,CAAoB,OAApB,EAA6B,OAA7B,CAAP;AACD;AAED;;AACA,IAAM,WAAW,GAAG,EAApB;AAEA;;;;;;;AAOG;;AACH,SAAS,cAAT,CAAwB,OAAxB,EAAiC,MAAjC,EAAyC,OAAzC,EAAkD,IAAlD,EAAsD;AACpD,MAAI,EAAE,OAAO,IAAI,WAAb,CAAJ,EAA+B;AAC7B,IAAA,WAAW,CAAC,OAAD,CAAX,GAAuB,YAAY,CAAC,MAAD,CAAZ,CAAqB,MAA5C;AACD;;AACD,EAAA,OAAO,CAAC,IAAR,GAAe,IAAf;AACA,SAAO,WAAW,CAAC,OAAD,CAAX,CAAqB,OAArB,EAA8B,OAA9B,CAAP;AACD;AAED;;;;;AAKG;;;AACH,SAAS,gBAAT,CAA0B,KAA1B,EAAiC,OAAjC,EAAwC;AACtC,MAAI,KAAJ,EAAW;AACT,QAAI,KAAK,CAAC,CAAN,KAAY,CAAZ,IAAiB,OAAO,KAAK,CAAjC,EAAoC;AAClC,aAAO,SAAP;AACD;;AACD,QAAM,CAAC,GAAG,KAAK,CAAC,CAAhB;AACA,IAAA,OAAO,GAAG,OAAO,KAAK,SAAZ,GAAwB,CAAxB,GAA4B,OAAtC;AACA,WACE,UACA,IAAI,CAAC,KAAL,CAAY,KAAK,CAAC,CAAN,GAAU,GAAX,GAAkB,CAA7B,CADA,GAEA,GAFA,GAGA,IAAI,CAAC,KAAL,CAAY,KAAK,CAAC,CAAN,GAAU,GAAX,GAAkB,CAA7B,CAHA,GAIA,GAJA,GAKA,IAAI,CAAC,KAAL,CAAY,KAAK,CAAC,CAAN,GAAU,GAAX,GAAkB,CAA7B,CALA,GAMA,GANA,GAOA,CAAC,GAAG,OAPJ,GAQA,GATF;AAWD;;AACD,SAAO,KAAP;AACD;;AAED,IAAM,aAAa,GAAG,wBAAtB;AAEA;;;;;AAKG;;AACH,SAAS,YAAT,CAAsB,IAAtB,EAA4B,UAA5B,EAAsC;AACpC,MAAI,KAAJ;;AACA,KAAG;AACD,IAAA,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,aAAX,CAAR;;AACA,QAAI,KAAJ,EAAW;AACT,UAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAD,CAAN,CAAV,IAAwB,EAAtC;AACA,MAAA,IAAI,GAAG,KAAK,CAAC,CAAD,CAAL,GAAW,KAAX,GAAmB,KAAK,CAAC,CAAD,CAA/B;AACD;AACF,GAND,QAMS,KANT;;AAOA,SAAO,IAAP;AACD;;AAED,IAAI,WAAW,GAAG,KAAlB;AAEA;;;;;;;;AAQG;;AACH,OAAM,SAAU,gBAAV,CAA2B,MAA3B,EAAiC;AACrC,EAAA,WAAW,GAAG,MAAd;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiEG;;AACH,eAAc,UACZ,OADY,EAEZ,OAFY,EAGZ,MAHY,EAIZ,WAJY,EAKZ,UALY,EAMZ,cANY,EAOZ,QAPY,EAOJ;AAHR,MAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,WAAA,GAAA,kBAAA;AAAgC;;AAKhC,MAAI,OAAO,OAAP,IAAkB,QAAtB,EAAgC;AAC9B,IAAA,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,OAAX,CAAV;AACD;;AACD,MAAI,OAAO,CAAC,OAAR,IAAmB,CAAvB,EAA0B;AACxB,UAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,MAAI,WAAJ,EAAiB,aAAjB;;AACA,MAAI,cAAJ,EAAoB;AAClB,QAAI,OAAO,KAAP,KAAiB,WAArB,EAAkC;AAChC,UAAM,KAAG,GAAG,IAAI,KAAJ,EAAZ;AACA,MAAA,KAAG,CAAC,WAAJ,GAAkB,WAAlB;;AACA,MAAA,KAAG,CAAC,MAAJ,GAAa,YAAA;AACX,QAAA,WAAW,GAAG,KAAd;AACA,QAAA,aAAa,GAAG,CAAC,KAAG,CAAC,KAAL,EAAY,KAAG,CAAC,MAAhB,CAAhB;AACA,QAAA,OAAO,CAAC,OAAR;AACA,QAAA,KAAG,CAAC,MAAJ,GAAa,IAAb;AACD,OALD;;AAMA,MAAA,KAAG,CAAC,GAAJ,GAAU,cAAV;AACD,KAVD,MAUO,IAAI,OAAO,iBAAP,KAA6B,WAA7B,IAA4C,IAAI,YAAY,iBAAhE,EAAmF;AAAE;AAC1F,UAAM,MAAM;AAAG;AAAkB,MAAA,IAAjC,CADwF,CAExF;;AACA,MAAA,MAAM,CAAC,WAAP,CAAmB;AACjB,QAAA,MAAM,EAAE,WADS;AAEjB,QAAA,GAAG,EAAE;AAFY,OAAnB;AAIA,MAAA,MAAM,CAAC,gBAAP,CAAwB,SAAxB,EAAmC,SAAS,OAAT,CAAiB,KAAjB,EAAsB;AACvD,YACE,KAAK,CAAC,IAAN,CAAW,MAAX,KAAsB,aAAtB,IACA,KAAK,CAAC,IAAN,CAAW,GAAX,KAAmB,cAFrB,EAGE;AACA,UAAA,WAAW,GAAG,KAAK,CAAC,IAAN,CAAW,KAAzB;AACA,UAAA,aAAa,GAAG,CAAC,WAAW,CAAC,KAAb,EAAoB,WAAW,CAAC,MAAhC,CAAhB;AACD;AACF,OARD;AASD;AACF;;AAED,MAAM,SAAS,GAAG,WAAW,CAAC,OAAO,CAAC,MAAT,CAA7B;AAEA,MAAM,mBAAmB,GAAG,EAA5B;AACA,MAAM,YAAY,GAAG,EAArB;AACA,MAAI,YAAJ;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,SAAS,CAAC,MAA/B,EAAuC,CAAC,GAAG,EAA3C,EAA+C,EAAE,CAAjD,EAAoD;AAClD,QAAM,KAAK,GAAG,SAAS,CAAC,CAAD,CAAvB;AACA,QAAM,OAAO,GAAG,KAAK,CAAC,EAAtB;;AACA,QACG,OAAO,MAAP,IAAiB,QAAjB,IAA6B,KAAK,CAAC,MAAN,IAAgB,MAA9C,IACA,MAAM,CAAC,OAAP,CAAe,OAAf,MAA4B,CAAC,CAF/B,EAGE;AACA,UAAM,WAAW,GAAG,KAAK,CAAC,cAAD,CAAzB;;AACA,UAAI,CAAC,YAAL,EAAmB;AACjB,QAAA,YAAY,GAAG,KAAK,CAAC,MAArB;AACA,YAAM,QAAM,GAAG,OAAO,CAAC,OAAR,CAAgB,YAAhB,CAAf;;AACA,YAAI,CAAC,QAAL,EAAa;AACX,gBAAM,IAAI,KAAJ,CAAU,cAAW,YAAX,GAAuB,mBAAjC,CAAN;AACD;;AACD,YAAM,IAAI,GAAG,QAAM,CAAC,IAApB;;AACA,YAAI,IAAI,KAAK,QAAT,IAAqB,IAAI,KAAK,SAAlC,EAA6C;AAC3C,gBAAM,IAAI,KAAJ,CACJ,cAAW,YAAX,GAAuB,qDAAvB,GAAuE,IAAvE,GAA2E,IADvE,CAAN;AAGD;AACF;;AACD,UAAI,MAAM,GAAG,mBAAmB,CAAC,WAAD,CAAhC;;AACA,UAAI,CAAC,MAAL,EAAa;AACX,QAAA,MAAM,GAAG,EAAT;AACA,QAAA,mBAAmB,CAAC,WAAD,CAAnB,GAAmC,MAAnC;AACD;;AACD,MAAA,MAAM,CAAC,IAAP,CAAY;AACV,QAAA,KAAK,EAAE,KADG;AAEV,QAAA,KAAK,EAAE;AAFG,OAAZ;AAIA,MAAA,YAAY,CAAC,IAAb,CAAkB,OAAlB;AACD,KA/BiD,CAgClD;;;AACA,WAAO,aAAa,CAAC,OAAD,CAApB;AACA,WAAO,WAAW,CAAC,OAAD,CAAlB;AACD;;AAED,MAAM,QAAQ,GAAG,IAAI,MAAJ,EAAjB;AACA,MAAM,SAAS,GAAG,IAAI,IAAJ,EAAlB;AAEA,MAAM,cAAc,GAAG,EAAvB;AACA,MAAM,YAAY,GAAG,EAArB;AACA,MAAM,MAAM,GAAG,EAAf;;AAEA,MAAM,aAAa,GAAG,UAAU,OAAV,EAAmB,UAAnB,EAA6B;AACjD,QAAM,UAAU,GAAG,OAAO,CAAC,aAAR,EAAnB;AACA,QAAM,MAAM,GAAG,mBAAmB,CAAC,UAAU,CAAC,KAAZ,CAAlC;;AACA,QAAI,CAAC,MAAL,EAAa;AACX;AACD;;AACD,QAAI,IAAI,GAAG,WAAW,CAAC,OAAZ,CAAoB,UAApB,CAAX;;AACA,QAAI,IAAI,IAAI,CAAC,CAAb,EAAgB;AACd,MAAA,IAAI,GAAG,oBAAoB,CAAC,UAAD,EAAa,WAAb,CAA3B;AACD;;AACD,QAAM,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,WAAR,GAAsB,OAAtB,EAAD,CAAlB;AACA,QAAM,CAAC,GAAG;AACR,MAAA,UAAU,EAAE,UADJ;AAER,MAAA,IAAI,EAAE;AAFE,KAAV;AAIA,QAAI,YAAY,GAAG,CAAC,CAApB;AACA,QAAI,qBAAJ;;4BACS,C,EAAO,E,EAAE;AAChB,UAAM,SAAS,GAAG,MAAM,CAAC,CAAD,CAAxB;AACA,UAAM,KAAK,GAAG,SAAS,CAAC,KAAxB;AACA,UAAM,OAAO,GAAG,KAAK,CAAC,EAAtB;AAEA,UAAM,MAAM,GAAG,KAAK,CAAC,MAAN,IAAgB,QAA/B;AACA,UAAM,KAAK,GAAG,KAAK,CAAC,KAAN,IAAe,QAA7B;;AACA,UACE,MAAM,CAAC,UAAP,KAAsB,MAAtB,IACC,aAAa,KAAb,IAAsB,IAAI,GAAG,KAAK,CAAC,OADpC,IAEC,aAAa,KAAb,IAAsB,IAAI,IAAI,KAAK,CAAC,OAHvC,EAIE;;AAED;;AACD,UAAM,MAAM,GAAG,KAAK,CAAC,MAArB;;AACA,UAAI,CAAC,MAAD,IAAW,cAAc,CAAC,OAAD,EAAU,MAAV,EAAkB,CAAlB,EAAqB,IAArB,CAA7B,EAAyD;AACvD,QAAA,qBAAqB,GAAG,KAAxB;AACA,YAAI,KAAK,GAAA,KAAA,CAAT;AAAA,YAAW,OAAO,GAAA,KAAA,CAAlB;AAAA,YAAoB,IAAI,GAAA,KAAA,CAAxB;AAAA,YAA0B,MAAM,GAAA,KAAA,CAAhC;AAAA,YAAkC,WAAW,GAAA,KAAA,CAA7C;AAAA,YAA+C,KAAK,GAAA,KAAA,CAApD;AACA,YAAM,KAAK,GAAG,SAAS,CAAC,KAAxB;;AACA,YACE,IAAI,IAAI,CAAR,KACC,KAAK,CAAC,IAAN,IAAc,MAAd,IAAwB,KAAK,CAAC,IAAN,IAAc,gBADvC,CADF,EAGE;AACA,UAAA,OAAO,GAAG,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,KAAK,CAAC,IAAN,GAAa,UAA9B,EAA0C,IAA1C,EAAgD,CAAhD,CAAlB;;AACA,cAAI,KAAK,CAAC,IAAN,GAAa,UAAb,IAA2B,KAA/B,EAAsC;AACpC,gBAAM,QAAQ,GAAG,QAAQ,CACvB,KADuB,EAEvB,OAFuB,EAGvB,KAAK,CAAC,IAAN,GAAa,UAHU,EAIvB,IAJuB,EAKvB,CALuB,CAAzB;;AAOA,gBAAI,QAAJ,EAAc;AACZ,kBAAM,MAAI,GACR,OAAO,QAAP,KAAoB,QAApB,GACI,YAAY,CAAC,QAAD,EAAW,UAAX,CADhB,GAEI,QAAQ,CAAC,QAAT,EAHN;;AAIA,kBAAI,WAAW,IAAI,UAAf,IAA6B,UAAU,CAAC,MAAD,CAA3C,EAAmD;AACjD,kBAAE,YAAF;AACA,gBAAA,KAAK,GAAG,MAAM,CAAC,YAAD,CAAd;;AACA,oBACE,CAAC,KAAD,IACA,CAAC,KAAK,CAAC,OAAN,EADD,IAEA,KAAK,CAAC,SAAN,EAFA,IAGA,KAAK,CAAC,OAAN,EAJF,EAKE;AACA,kBAAA,KAAK,GAAG,IAAI,KAAJ,CAAU;AAChB,oBAAA,IAAI,EAAE,IAAI,IAAJ;AADU,mBAAV,CAAR;AAGA,kBAAA,MAAM,CAAC,YAAD,CAAN,GAAuB,KAAvB;AACD;;AACD,gBAAA,IAAI,GAAG,KAAK,CAAC,OAAN,EAAP;AACA,gBAAA,KAAK,CAAC,SAAN,CAAgB,KAAhB;AACA,oBAAM,cAAc,GAAG,MAAI,GAAG,GAAP,GAAa,OAApC;AACA,oBAAI,OAAO,GAAG,YAAY,CAAC,cAAD,CAA1B;;AACA,oBAAI,CAAC,OAAL,EAAc;AACZ,sBAAM,eAAe,GAAG,UAAU,CAAC,MAAD,CAAlC;AACA,sBAAM,MAAM,GAAG,YAAY,CACzB,eAAe,CAAC,KADS,EAEzB,eAAe,CAAC,MAFS,CAA3B;AAIA,sBAAM,GAAG;AAAG;AACV,kBAAA,MAAM,CAAC,UAAP,CAAkB,IAAlB,CADF;AAGA,kBAAA,GAAG,CAAC,WAAJ,GAAkB,OAAlB;AACA,kBAAA,GAAG,CAAC,SAAJ,CACE,WADF,EAEE,eAAe,CAAC,CAFlB,EAGE,eAAe,CAAC,CAHlB,EAIE,eAAe,CAAC,KAJlB,EAKE,eAAe,CAAC,MALlB,EAME,CANF,EAOE,CAPF,EAQE,eAAe,CAAC,KARlB,EASE,eAAe,CAAC,MATlB;AAWA,kBAAA,OAAO,GAAG,GAAG,CAAC,aAAJ,CAAkB,MAAlB,EAA0B,QAA1B,CAAV;AACA,kBAAA,YAAY,CAAC,cAAD,CAAZ,GAA+B,OAA/B;AACD;;AACD,gBAAA,IAAI,CAAC,QAAL,CAAc,OAAd;AACD;AACF;AACF,WA1DD,MA0DO;AACL,YAAA,KAAK,GAAG,gBAAgB,CACtB,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,KAAK,CAAC,IAAN,GAAa,QAA9B,EAAwC,IAAxC,EAA8C,CAA9C,CADc,EAEtB,OAFsB,CAAxB;;AAIA,gBAAI,KAAJ,EAAW;AACT,kBAAI,KAAK,CAAC,IAAN,GAAa,gBAAb,IAAiC,KAArC,EAA4C;AAC1C,gBAAA,WAAW,GAAG,gBAAgB,CAC5B,QAAQ,CACN,KADM,EAEN,OAFM,EAGN,KAAK,CAAC,IAAN,GAAa,gBAHP,EAIN,IAJM,EAKN,CALM,CADoB,EAQ5B,OAR4B,CAA9B;AAUD;;AACD,kBAAI,CAAC,WAAL,EAAkB;AAChB,gBAAA,WAAW,GAAG,KAAd;AACD;;AACD,gBAAE,YAAF;AACA,cAAA,KAAK,GAAG,MAAM,CAAC,YAAD,CAAd;;AACA,kBACE,CAAC,KAAD,IACA,EAAE,KAAK,CAAC,OAAN,MAAmB,KAAK,CAAC,SAAN,EAArB,CADA,IAEA,KAAK,CAAC,OAAN,EAHF,EAIE;AACA,gBAAA,KAAK,GAAG,IAAI,KAAJ,CAAU;AAChB,kBAAA,IAAI,EAAE,IAAI,IAAJ,EADU;AAEhB,kBAAA,MAAM,EAAE,IAAI,MAAJ;AAFQ,iBAAV,CAAR;AAIA,gBAAA,MAAM,CAAC,YAAD,CAAN,GAAuB,KAAvB;AACD;;AACD,cAAA,IAAI,GAAG,KAAK,CAAC,OAAN,EAAP;AACA,cAAA,IAAI,CAAC,QAAL,CAAc,KAAd;AACA,cAAA,MAAM,GAAG,KAAK,CAAC,SAAN,EAAT;AACA,cAAA,MAAM,CAAC,QAAP,CAAgB,WAAhB;AACA,cAAA,MAAM,CAAC,QAAP,CAAgB,CAAhB;AACA,cAAA,KAAK,CAAC,SAAN,CAAgB,KAAhB;AACD;AACF;AACF;;AACD,YAAI,IAAI,IAAI,CAAR,IAAa,KAAK,CAAC,IAAN,IAAc,MAA/B,EAAuC;AACrC,UAAA,KAAK,GACH,EAAE,kBAAkB,KAApB,KAA8B,gBAAgB,KAA9C,GACI,gBAAgB,CACd,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,YAAjB,EAA+B,IAA/B,EAAqC,CAArC,CADM,EAEd,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,cAAjB,EAAiC,IAAjC,EAAuC,CAAvC,CAFM,CADpB,GAKI,SANN;AAOA,cAAM,OAAK,GAAG,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,YAAjB,EAA+B,IAA/B,EAAqC,CAArC,CAAtB;;AACA,cAAI,KAAK,IAAI,OAAK,GAAG,CAArB,EAAwB;AACtB,cAAE,YAAF;AACA,YAAA,KAAK,GAAG,MAAM,CAAC,YAAD,CAAd;;AACA,gBACE,CAAC,KAAD,IACA,CAAC,KAAK,CAAC,SAAN,EADD,IAEA,KAAK,CAAC,OAAN,EAFA,IAGA,KAAK,CAAC,OAAN,EAJF,EAKE;AACA,cAAA,KAAK,GAAG,IAAI,KAAJ,CAAU;AAChB,gBAAA,MAAM,EAAE,IAAI,MAAJ;AADQ,eAAV,CAAR;AAGA,cAAA,MAAM,CAAC,YAAD,CAAN,GAAuB,KAAvB;AACD;;AACD,YAAA,MAAM,GAAG,KAAK,CAAC,SAAN,EAAT;AACA,YAAA,MAAM,CAAC,UAAP,CAAkB,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,UAAlB,EAA8B,IAA9B,EAAoC,CAApC,CAA1B;AACA,YAAA,MAAM,CAAC,WAAP,CAAmB,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,EAA+B,IAA/B,EAAqC,CAArC,CAA3B;AACA,YAAA,MAAM,CAAC,aAAP,CACE,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,kBAAlB,EAAsC,IAAtC,EAA4C,CAA5C,CADV;AAGA,YAAA,MAAM,CAAC,QAAP,CAAgB,KAAhB;AACA,YAAA,MAAM,CAAC,QAAP,CAAgB,OAAhB;AACA,YAAA,MAAM,CAAC,WAAP,CACE,KAAK,CAAC,gBAAD,CAAL,GACI,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,gBAAjB,EAAmC,IAAnC,EAAyC,CAAzC,CAAR,CAAoD,GAApD,CACE,UAAU,CAAV,EAAW;AACT,qBAAO,CAAC,GAAG,OAAX;AACD,aAHH,CADJ,GAMI,IAPN;AASA,YAAA,KAAK,CAAC,SAAN,CAAgB,KAAhB;AACD;AACF;;AAED,YAAI,QAAQ,GAAG,KAAf;AACA,YAAI,IAAI,GAAG,IAAX;AACA,YAAI,cAAc,GAAG,CAArB;AACA,YAAI,IAAI,GAAA,KAAA,CAAR;AAAA,YAAU,OAAO,GAAA,KAAA,CAAjB;AAAA,YAAmB,SAAS,GAAA,KAAA,CAA5B;;AACA,YAAI,CAAC,IAAI,IAAI,CAAR,IAAa,IAAI,IAAI,CAAtB,KAA4B,gBAAgB,MAAhD,EAAwD;AACtD,cAAM,SAAS,GAAG,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,YAAlB,EAAgC,IAAhC,EAAsC,CAAtC,CAA1B;;AACA,cAAI,SAAJ,EAAe;AACb,YAAA,IAAI,GACF,OAAO,SAAP,KAAqB,QAArB,GACI,YAAY,CAAC,SAAD,EAAY,UAAZ,CADhB,GAEI,SAAS,CAAC,QAAV,EAHN;AAIA,gBAAI,SAAS,GAAG,SAAhB;;AACA,gBAAI,WAAW,IAAI,UAAf,IAA6B,UAAU,CAAC,IAAD,CAA3C,EAAmD;AACjD,kBAAM,qBAAqB,GAAG,QAAQ,CACpC,KADoC,EAEpC,QAFoC,EAGpC,yBAHoC,EAIpC,IAJoC,EAKpC,CALoC,CAAtC;;AAOA,kBAAI,IAAI,IAAI,CAAZ,EAAe;AACb,oBAAM,IAAI,GAAG,OAAO,CAAC,WAAR,EAAb,CADa,CAEb;;AACA,oBAAI,IAAI,CAAC,eAAL,IAAwB,IAAI,CAAC,gBAAjC,EAAmD;AACjD,sBAAM,MAAM,GAAG,IAAI,CAAC,SAAL,EAAf;AACA,sBAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CACX,IAAI,CAAC,GAAL,CACE,IAAI,CAAC,GAAL,CAAS,CAAC,MAAM,CAAC,CAAD,CAAN,GAAY,MAAM,CAAC,CAAD,CAAnB,IAA0B,UAAnC,EAA+C,CAA/C,CADF,EAEE,IAAI,CAAC,GAAL,CAAS,CAAC,MAAM,CAAC,CAAD,CAAN,GAAY,MAAM,CAAC,CAAD,CAAnB,IAA0B,UAAnC,EAA+C,CAA/C,CAFF,CADW,CAAb;;AAMA,sBAAI,IAAI,GAAG,GAAX,EAAgB;AACd;AACA,wBAAM,QAAQ,GACZ,IAAI,CAAC,OAAL,OAAmB,iBAAnB,GACI,IAAI,CAAC,gBAAL,EADJ,GAEI,IAAI,CAAC,eAAL,EAHN;;AAIA,wBAAI,CAAC,aAAL,EAAoB;AAClB,sBAAA,wBAAwB,GAAG,CAAC,GAAD,EAAM,GAAN,CAA3B;AACA,sBAAA,aAAa,GAAG,IAAI,aAAJ,CACd,OADc,EAEd,wBAFc,EAGd,EAHc,EAId,EAJc,EAKd,IALc,CAAhB;AAOD;;AACD,oBAAA,SAAS,GAAG,aAAZ;AACA,oBAAA,wBAAwB,CAAC,CAAD,CAAxB,GAA8B,QAAQ,CAAC,CAAD,CAAtC;AACA,oBAAA,wBAAwB,CAAC,CAAD,CAAxB,GAA8B,QAAQ,CAAC,CAAD,CAAtC;AACA,wBAAM,SAAS,GAAG,QAAQ,CACxB,KADwB,EAExB,QAFwB,EAGxB,kBAHwB,EAIxB,IAJwB,EAKxB,CALwB,CAA1B;;AAOA,wBACE,SAAS,KAAK,MAAd,IACA,qBAAqB,KAAK,KAF5B,EAGE;AACA,0BAAM,MAAM,GAAG,IAAI,CAAC,SAAL,EAAf;AACA,0BAAM,WAAW,GAAG,IAAI,CAAC,kBAAL,EAApB;;AACA,2BACE,IAAI,GAAC,GAAG,CAAR,EAAW,IAAE,GAAG,WAAW,CAAC,MAAZ,GAAqB,MADvC,EAEE,GAAC,GAAG,IAFN,EAGE,GAAC,IAAI,MAHP,EAIE;AACA,4BAAM,EAAE,GAAG,WAAW,CAAC,GAAD,CAAtB;AACA,4BAAM,EAAE,GAAG,WAAW,CAAC,GAAC,GAAG,CAAL,CAAtB;AACA,4BAAM,EAAE,GAAG,WAAW,CAAC,GAAC,GAAG,MAAL,CAAtB;AACA,4BAAM,EAAE,GAAG,WAAW,CAAC,GAAC,GAAG,MAAJ,GAAa,CAAd,CAAtB;AACA,4BAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,EAAb,CAAb;AACA,4BAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,EAAb,CAAb;AACA,4BAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,EAAb,CAAb;AACA,4BAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,EAAb,CAAb;;AACA,4BACE,QAAQ,CAAC,CAAD,CAAR,IAAe,IAAf,IACA,QAAQ,CAAC,CAAD,CAAR,IAAe,IADf,IAEA,QAAQ,CAAC,CAAD,CAAR,IAAe,IAFf,IAGA,QAAQ,CAAC,CAAD,CAAR,IAAe,IAJjB,EAKE;AACA,0BAAA,cAAc,GAAG,IAAI,CAAC,KAAL,CAAW,EAAE,GAAG,EAAhB,EAAoB,EAAE,GAAG,EAAzB,CAAjB;AACA;AACD;AACF;AACF;AACF;AACF;AACF;;AACD,kBAAI,IAAI,KAAK,CAAT,IAAc,SAAlB,EAA6B;AAC3B,oBAAM,QAAQ,GAAG,QAAQ,CACvB,KADuB,EAEvB,QAFuB,EAGvB,WAHuB,EAIvB,IAJuB,EAKvB,CALuB,CAAzB;AAOA,oBAAM,SAAS,GACb,KAAK,CAAC,YAAD,CAAL,KAAwB,SAAxB,GACI,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,YAAjB,EAA+B,IAA/B,EAAqC,CAArC,CADZ,GAEI,IAHN;;AAIA,oBAAI,CAAC,SAAD,IAAc,SAAS,CAAC,CAAV,KAAgB,CAAlC,EAAqC;AACnC,sBAAI,cAAc,GAAG,IAAI,GAAG,GAAP,GAAa,QAAlC;;AACA,sBAAI,SAAS,KAAK,IAAlB,EAAwB;AACtB,oBAAA,cAAc,IAAI,MAAM,SAAxB;AACD;;AACD,kBAAA,OAAO,GAAG,cAAc,CAAC,cAAD,CAAxB;;AACA,sBAAI,CAAC,OAAL,EAAc;AACZ,wBAAM,eAAe,GAAG,UAAU,CAAC,IAAD,CAAlC;;AACA,wBAAI,SAAS,KAAK,IAAlB,EAAwB;AACtB;AACA,0BAAM,MAAM,GAAG,YAAY,CACzB,eAAe,CAAC,KADS,EAEzB,eAAe,CAAC,MAFS,CAA3B;AAIA,0BAAM,GAAG;AAAG;AACV,sBAAA,MAAM,CAAC,UAAP,CAAkB,IAAlB,CADF;AAGA,sBAAA,GAAG,CAAC,SAAJ,CACE,WADF,EAEE,eAAe,CAAC,CAFlB,EAGE,eAAe,CAAC,CAHlB,EAIE,eAAe,CAAC,KAJlB,EAKE,eAAe,CAAC,MALlB,EAME,CANF,EAOE,CAPF,EAQE,eAAe,CAAC,KARlB,EASE,eAAe,CAAC,MATlB;AAWA,0BAAM,IAAI,GAAG,GAAG,CAAC,YAAJ,CACX,CADW,EAEX,CAFW,EAGX,MAAM,CAAC,KAHI,EAIX,MAAM,CAAC,MAJI,CAAb;;AAMA,2BAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,IAAI,CAAC,IAAL,CAAU,MAA/B,EAAuC,CAAC,GAAG,EAA3C,EAA+C,CAAC,IAAI,CAApD,EAAuD;AACrD,4BAAM,CAAC,GAAG,SAAS,CAAC,CAApB;;AACA,4BAAI,CAAC,KAAK,CAAV,EAAa;AACX,0BAAA,IAAI,CAAC,IAAL,CAAU,CAAV,IAAgB,SAAS,CAAC,CAAV,GAAc,GAAf,GAAsB,CAArC;AACA,0BAAA,IAAI,CAAC,IAAL,CAAU,CAAC,GAAG,CAAd,IAAoB,SAAS,CAAC,CAAV,GAAc,GAAf,GAAsB,CAAzC;AACA,0BAAA,IAAI,CAAC,IAAL,CAAU,CAAC,GAAG,CAAd,IAAoB,SAAS,CAAC,CAAV,GAAc,GAAf,GAAsB,CAAzC;AACD;;AACD,wBAAA,IAAI,CAAC,IAAL,CAAU,CAAC,GAAG,CAAd,IAAmB,CAAnB;AACD;;AACD,sBAAA,GAAG,CAAC,YAAJ,CAAiB,IAAjB,EAAuB,CAAvB,EAA0B,CAA1B;AACA,sBAAA,OAAO,GAAG,IAAI,IAAJ,CAAS;AACjB,wBAAA,GAAG,EAAE,MADY;AAEjB,wBAAA,OAAO,EAAE,CAAC,MAAM,CAAC,KAAR,EAAe,MAAM,CAAC,MAAtB,CAFQ;AAGjB,wBAAA,KAAK,EAAE,QAAQ,GAAG,eAAe,CAAC;AAHjB,uBAAT,CAAV;AAKA,sBAAA,cAAc,CAAC,cAAD,CAAd,GAAiC,OAAjC;AACD,qBA1CD,MA0CO;AACL,sBAAA,OAAO,GAAG,IAAI,IAAJ,CAAS;AACjB,wBAAA,GAAG,EAAE,WADY;AAEjB,wBAAA,OAAO,EAAE,aAFQ;AAGjB,wBAAA,IAAI,EAAE,CAAC,eAAe,CAAC,KAAjB,EAAwB,eAAe,CAAC,MAAxC,CAHW;AAIjB,wBAAA,MAAM,EAAE,CAAC,eAAe,CAAC,CAAjB,EAAoB,eAAe,CAAC,CAApC,CAJS;AAKjB,wBAAA,cAAc,EAAE,qBAAqB,KAAK,KALzB;AAMjB,wBAAA,KAAK,EAAE,QAAQ,GAAG,eAAe,CAAC;AANjB,uBAAT,CAAV;AAQA,sBAAA,cAAc,CAAC,cAAD,CAAd,GAAiC,OAAjC;AACD;AACF;AACF;;AACD,oBAAI,OAAJ,EAAa;AACX,oBAAE,YAAF;AACA,kBAAA,KAAK,GAAG,MAAM,CAAC,YAAD,CAAd;;AACA,sBACE,CAAC,KAAD,IACA,CAAC,KAAK,CAAC,QAAN,EADD,IAEA,KAAK,CAAC,OAAN,EAFA,IAGA,KAAK,CAAC,SAAN,EAJF,EAKE;AACA,oBAAA,KAAK,GAAG,IAAI,KAAJ,EAAR;AACA,oBAAA,MAAM,CAAC,YAAD,CAAN,GAAuB,KAAvB;AACD;;AACD,kBAAA,KAAK,CAAC,WAAN,CAAkB,SAAlB;AACA,kBAAA,OAAO,CAAC,WAAR,CACE,cAAc,GACZ,OAAO,CAAC,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiC,IAAjC,EAAuC,CAAvC,CAAT,CAFX;AAIA,kBAAA,OAAO,CAAC,UAAR,CACE,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,cAAjB,EAAiC,IAAjC,EAAuC,CAAvC,CADV;AAGA,kBAAA,OAAO,CAAC,SAAR,CACE,MAAM,CAAC,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiC,IAAjC,EAAuC,CAAvC,CAAT,CADR;AAGA,kBAAA,KAAK,CAAC,QAAN,CAAe,OAAf;AACA,kBAAA,IAAI,GAAG,KAAK,CAAC,OAAN,EAAP;AACA,kBAAA,KAAK,CAAC,OAAN,CAAc,SAAd;AACA,kBAAA,KAAK,CAAC,SAAN,CAAgB,KAAhB;AACA,kBAAA,QAAQ,GAAG,IAAX;AACA,kBAAA,SAAS,GAAG,KAAZ;AACD;AACF,eAzGD,MAyGO;AACL,gBAAA,SAAS,GAAG,IAAZ;AACD;AACF;AACF;AACF;;AAED,YAAI,IAAI,IAAI,CAAR,IAAa,mBAAmB,KAApC,EAA2C;AACzC,YAAE,YAAF;AACA,UAAA,KAAK,GAAG,MAAM,CAAC,YAAD,CAAd;;AACA,cACE,CAAC,KAAD,IACA,CAAC,KAAK,CAAC,QAAN,EADD,IAEA,KAAK,CAAC,OAAN,EAFA,IAGA,KAAK,CAAC,SAAN,EAJF,EAKE;AACA,YAAA,KAAK,GAAG,IAAI,KAAJ,EAAR;AACA,YAAA,MAAM,CAAC,YAAD,CAAN,GAAuB,KAAvB;AACD;;AACD,cAAM,YAAY,GAAG,QAAQ,CAC3B,KAD2B,EAE3B,OAF2B,EAG3B,eAH2B,EAI3B,IAJ2B,EAK3B,CAL2B,CAA7B;AAOA,cAAM,iBAAiB,GAAG,gBAAgB,CACxC,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,qBAAjB,EAAwC,IAAxC,EAA8C,CAA9C,CADgC,EAExC,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,uBAAjB,EAA0C,IAA1C,EAAgD,CAAhD,CAFgC,CAA1C;AAIA,cAAM,WAAW,GAAG,gBAAgB,CAClC,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,cAAjB,EAAiC,IAAjC,EAAuC,CAAvC,CAD0B,EAElC,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,gBAAjB,EAAmC,IAAnC,EAAyC,CAAzC,CAF0B,CAApC;AAIA,cAAM,iBAAiB,GAAG,QAAQ,CAChC,KADgC,EAEhC,OAFgC,EAGhC,qBAHgC,EAIhC,IAJgC,EAKhC,CALgC,CAAlC;AAOA,cAAM,SAAS,GACb,YAAY,GACZ,GADA,GAEA,iBAFA,GAGA,GAHA,GAIA,WAJA,GAKA,GALA,GAMA,iBAPF;AAQA,UAAA,OAAO,GAAG,cAAc,CAAC,SAAD,CAAxB;;AACA,cAAI,CAAC,OAAL,EAAc;AACZ,YAAA,OAAO,GAAG,IAAI,MAAJ,CAAW;AACnB,cAAA,MAAM,EAAE,YADW;AAEnB,cAAA,MAAM,EACJ,iBAAiB,IAAI,iBAAiB,GAAG,CAAzC,GACI,IAAI,MAAJ,CAAW;AACT,gBAAA,KAAK,EAAE,iBADE;AAET,gBAAA,KAAK,EAAE;AAFE,eAAX,CADJ,GAKI,SARa;AASnB,cAAA,IAAI,EAAE,WAAW,GACb,IAAI,IAAJ,CAAS;AACP,gBAAA,KAAK,EAAE;AADA,eAAT,CADa,GAIb;AAbe,aAAX,CAAV;AAeA,YAAA,cAAc,CAAC,SAAD,CAAd,GAA4B,OAA5B;AACD;;AACD,UAAA,KAAK,CAAC,QAAN,CAAe,OAAf;AACA,UAAA,IAAI,GAAG,KAAK,CAAC,OAAN,EAAP;AACA,UAAA,KAAK,CAAC,OAAN,CAAc,SAAd;AACA,UAAA,KAAK,CAAC,WAAN,CAAkB,SAAlB;AACA,UAAA,KAAK,CAAC,SAAN,CAAgB,KAAhB;AACA,UAAA,QAAQ,GAAG,IAAX;AACD;;AAED,YAAI,KAAK,GAAA,KAAA,CAAT;;AACA,YAAI,gBAAgB,MAApB,EAA4B;AAC1B,cAAM,SAAS,GAAG,QAAQ,CACxB,KADwB,EAExB,QAFwB,EAGxB,YAHwB,EAIxB,IAJwB,EAKxB,CALwB,CAAR,CAMhB,QANgB,EAAlB;AAOA,UAAA,KAAK,GAAG,YAAY,CAAC,SAAD,EAAY,UAAZ,CAAZ,CAAoC,IAApC,EAAR;AACA,UAAA,OAAO,GAAG,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,cAAjB,EAAiC,IAAjC,EAAuC,CAAvC,CAAlB;AACD;;AACD,YAAI,KAAK,IAAI,OAAT,IAAoB,CAAC,SAAzB,EAAoC;AAClC,cAAI,CAAC,QAAL,EAAe;AACb,cAAE,YAAF;AACA,YAAA,KAAK,GAAG,MAAM,CAAC,YAAD,CAAd;;AACA,gBACE,CAAC,KAAD,IACA,CAAC,KAAK,CAAC,OAAN,EADD,IAEA,KAAK,CAAC,OAAN,EAFA,IAGA,KAAK,CAAC,SAAN,EAJF,EAKE;AACA,cAAA,KAAK,GAAG,IAAI,KAAJ,EAAR;AACA,cAAA,MAAM,CAAC,YAAD,CAAN,GAAuB,KAAvB;AACD;;AACD,YAAA,KAAK,CAAC,QAAN,CAAe,SAAf;AACA,YAAA,KAAK,CAAC,WAAN,CAAkB,SAAlB;AACD;;AACD,cAAI,CAAC,KAAK,CAAC,OAAN,EAAL,EAAsB;AACpB,YAAA,KAAK,CAAC,OAAN,CACE,IAAI,IACF,IAAI,IAAJ,CAAS;AACP,cAAA,OAAO,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV;AADF,aAAT,CAFJ;AAMD;;AACD,UAAA,IAAI,GAAG,KAAK,CAAC,OAAN,EAAP;AACA,cAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CACf,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,EAA+B,IAA/B,EAAqC,CAArC,CADO,CAAjB;AAGA,cAAM,SAAS,GAAG,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,WAAlB,EAA+B,IAA/B,EAAqC,CAArC,CAA1B;AACA,cAAM,cAAc,GAAG,QAAQ,CAC7B,KAD6B,EAE7B,QAF6B,EAG7B,kBAH6B,EAI7B,IAJ6B,EAK7B,CAL6B,CAA/B;AAOA,cAAM,IAAI,GAAG,MAAM,CACjB,QAAQ,GAAG,QAAQ,CAAC,SAAD,CAAX,GAAyB,SADhB,EAEjB,QAFiB,EAGjB,cAHiB,CAAnB;AAKA,cAAM,aAAa,GAAG,MAAM,CAAC,gBAAD,CAA5B;;AACA,cAAI,aAAa,IAAI,WAArB,EAAkC;AAChC,YAAA,KAAK,GAAG,KAAK,CAAC,WAAN,EAAR;AACD,WAFD,MAEO,IAAI,aAAa,IAAI,WAArB,EAAkC;AACvC,YAAA,KAAK,GAAG,KAAK,CAAC,WAAN,EAAR;AACD;;AACD,cAAM,YAAY,GAAG,QAAQ,CAC3B,KAD2B,EAE3B,QAF2B,EAG3B,gBAH2B,EAI3B,IAJ2B,EAK3B,CAL2B,CAA7B;AAOA,cAAM,aAAa,GAAG,QAAQ,CAC5B,KAD4B,EAE5B,QAF4B,EAG5B,qBAH4B,EAI5B,IAJ4B,EAK5B,CAL4B,CAA9B;AAOA,cAAM,YAAY,GAChB,IAAI,IAAI,CAAR,GACI,kBAAkB,CAAC,KAAD,EAAQ,aAAR,CADtB,GAEI,QAAQ,CAAC,KAAD,EAAQ,IAAR,EAAc,YAAd,EAA4B,aAA5B,CAHd;AAIA,UAAA,IAAI,CAAC,OAAL,CAAa,YAAb;AACA,UAAA,IAAI,CAAC,OAAL,CAAa,IAAb;AACA,UAAA,IAAI,CAAC,WAAL,CACE,OAAO,CAAC,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiC,IAAjC,EAAuC,CAAvC,CAAT,CADT;AAGA,cAAM,UAAU,GAAG,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiC,IAAjC,EAAuC,CAAvC,CAA3B;AACA,cAAM,SAAS,GACb,QAAQ,IAAI,IAAI,IAAI,CAApB,GACI,OADJ,GAEI,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,kBAAlB,EAAsC,IAAtC,EAA4C,CAA5C,CAHd;AAIA,UAAA,IAAI,CAAC,YAAL,CAAkB,SAAlB;AACA,cAAI,aAAa,GAAG,QAAQ,CAC1B,KAD0B,EAE1B,OAF0B,EAG1B,iBAH0B,EAI1B,IAJ0B,EAK1B,CAL0B,CAA5B;AAOA,cAAM,UAAU,GAAG,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,aAAlB,EAAiC,IAAjC,EAAuC,CAAvC,CAA3B;AACA,cAAM,aAAa,GAAG,QAAQ,CAC5B,KAD4B,EAE5B,OAF4B,EAG5B,gBAH4B,EAI5B,IAJ4B,EAK5B,CAL4B,CAA9B,CApFkC,CA2FlC;;AACA,cAAI,OAAO,GAAG,CAAd;AACA,cAAI,OAAO,GAAG,CAAd;;AACA,cAAI,SAAS,IAAI,OAAjB,EAA0B;AACxB,gBAAI,SAAS,GAAG,QAAhB;;AACA,gBAAI,UAAU,CAAC,OAAX,CAAmB,MAAnB,MAA+B,CAAC,CAApC,EAAuC;AACrC,cAAA,SAAS,GAAG,MAAZ;AACA,cAAA,OAAO,GAAG,aAAV;AACD,aAHD,MAGO,IAAI,UAAU,CAAC,OAAX,CAAmB,OAAnB,MAAgC,CAAC,CAArC,EAAwC;AAC7C,cAAA,SAAS,GAAG,OAAZ;AACA,cAAA,OAAO,GAAG,CAAC,aAAX;AACD;;AACD,YAAA,IAAI,CAAC,YAAL,CAAkB,SAAlB;AACA,gBAAM,qBAAqB,GAAG,QAAQ,CACpC,KADoC,EAEpC,QAFoC,EAGpC,yBAHoC,EAIpC,IAJoC,EAKpC,CALoC,CAAtC;AAOA,YAAA,IAAI,CAAC,iBAAL,CAAuB,qBAAqB,IAAI,KAAhD;AACD,WAlBD,MAkBO;AACL,YAAA,IAAI,CAAC,WAAL,CACG,OAAO,CAAC,QAAQ,CAAC,KAAD,EAAQ,QAAR,EAAkB,gBAAlB,EAAoC,IAApC,EAA0C,CAA1C,CAAT,CAAP,GACC,KAAK,CAAC,MADR,GAEE,YAAY,CAAC,MAHjB;AAKA,YAAA,IAAI,CAAC,YAAL;AACA,YAAA,IAAI,CAAC,iBAAL,CAAuB,KAAvB;AACD;;AACD,cAAI,YAAY,GAAG,QAAnB;;AACA,cAAI,UAAU,CAAC,OAAX,CAAmB,QAAnB,KAAgC,CAApC,EAAuC;AACrC,YAAA,YAAY,GAAG,QAAf;AACA,YAAA,OAAO,GAAG,CAAC,aAAD,GAAiB,OAAO,cAAc,GAAG,CAAxB,IAA6B,QAAxD;AACD,WAHD,MAGO,IAAI,UAAU,CAAC,OAAX,CAAmB,KAAnB,KAA6B,CAAjC,EAAoC;AACzC,YAAA,YAAY,GAAG,KAAf;AACA,YAAA,OAAO,GAAG,aAAa,GAAG,OAAO,cAAc,GAAG,CAAxB,IAA6B,QAAvD;AACD;;AACD,UAAA,IAAI,CAAC,eAAL,CAAqB,YAArB;AACA,UAAA,IAAI,CAAC,UAAL,CACE,UAAU,CAAC,CAAD,CAAV,GAAgB,QAAhB,GAA2B,OAA3B,GAAqC,aAAa,CAAC,CAAD,CADpD;AAGA,UAAA,IAAI,CAAC,UAAL,CACE,UAAU,CAAC,CAAD,CAAV,GAAgB,QAAhB,GAA2B,OAA3B,GAAqC,aAAa,CAAC,CAAD,CADpD;AAGA,UAAA,SAAS,CAAC,QAAV,CACE,gBAAgB,CACd,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,YAAjB,EAA+B,IAA/B,EAAqC,CAArC,CADM,EAEd,OAFc,CADlB;AAMA,UAAA,IAAI,CAAC,OAAL,CAAa,SAAb;AACA,cAAM,SAAS,GAAG,gBAAgB,CAChC,QAAQ,CAAC,KAAD,EAAQ,OAAR,EAAiB,iBAAjB,EAAoC,IAApC,EAA0C,CAA1C,CADwB,EAEhC,OAFgC,CAAlC;;AAIA,cAAI,SAAJ,EAAe;AACb,YAAA,QAAQ,CAAC,QAAT,CAAkB,SAAlB,EADa,CAEb;AACA;;AACA,YAAA,aAAa,IAAI,CAAjB,CAJa,CAKb;;AACA,gBAAM,YAAY,GAAG,MAAM,QAA3B;AACA,YAAA,QAAQ,CAAC,QAAT,CACE,aAAa,IAAI,YAAjB,GAAgC,aAAhC,GAAgD,YADlD;AAGA,YAAA,IAAI,CAAC,SAAL,CAAe,QAAf;AACD,WAXD,MAWO;AACL,YAAA,IAAI,CAAC,SAAL,CAAe,SAAf;AACD;;AACD,cAAM,WAAW,GAAG,QAAQ,CAC1B,KAD0B,EAE1B,QAF0B,EAG1B,cAH0B,EAI1B,IAJ0B,EAK1B,CAL0B,CAA5B;AAOA,cAAM,OAAO,GAAG,IAAI,CAAC,UAAL,EAAhB;;AACA,cAAI,WAAW,KAAK,OAAO,CAAC,CAAD,CAA3B,EAAgC;AAC9B,YAAA,OAAO,CAAC,CAAD,CAAP,GAAa,WAAb;AACA,YAAA,OAAO,CAAC,CAAD,CAAP,GAAa,WAAb;AACA,YAAA,OAAO,CAAC,CAAD,CAAP,GAAa,WAAb;AACA,YAAA,OAAO,CAAC,CAAD,CAAP,GAAa,WAAb;AACD;;AACD,UAAA,KAAK,CAAC,SAAN,CAAgB,KAAhB;AACD;AACF;;;AArnBH,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,MAAM,CAAC,MAA5B,EAAoC,CAAC,GAAG,EAAxC,EAA4C,EAAE,CAA9C,EAA+C;cAAtC,C,EAAO,E;AAsnBf;;AAED,QAAI,YAAY,GAAG,CAAC,CAApB,EAAuB;AACrB,MAAA,MAAM,CAAC,MAAP,GAAgB,YAAY,GAAG,CAA/B;;AACA,UAAI,WAAJ,EAAiB;AACf,YAAI,OAAO,OAAO,CAAC,GAAf,KAAuB,UAA3B,EAAuC;AACrC;AACA,UAAA,OAAO,CAAC,GAAR,CAAY,cAAZ,EAA4B,qBAA5B;AACD,SAHD,MAGO;AACL;AACA,UAAA,OAAO,CAAC,aAAR,GAAwB,cAAxB,IAA0C,qBAA1C;AACD;AACF;;AACD,aAAO,MAAP;AACD;AACF,GAtpBD;;AAwpBA,EAAA,OAAO,CAAC,QAAR,CAAiB,aAAjB;AACA,EAAA,OAAO,CAAC,GAAR,CAAY,eAAZ,EAA6B,YAA7B;AACA,EAAA,OAAO,CAAC,GAAR,CAAY,eAAZ,EAA6B,YAA7B;AACA,SAAO,aAAP;AACD;AAED,SACE,gBAAgB,IAAI,iBADtB,EAEE,WAAW,IAAI,YAFjB,EAGE,cAAc,IAAI,eAHpB,EAIE,YAAY,IAAI,aAJlB,EAKE,QAAQ,IAAI,SALd,EAME,aAAa,IAAI,cANnB","sourceRoot":"","sourcesContent":["/*\nol-mapbox-style - Use Mapbox Style objects with OpenLayers\nCopyright 2016-present ol-mapbox-style contributors\nLicense: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE\n*/\nimport Circle from 'ol/style/Circle.js';\nimport Fill from 'ol/style/Fill.js';\nimport Icon from 'ol/style/Icon.js';\nimport RenderFeature from 'ol/render/Feature.js';\nimport Stroke from 'ol/style/Stroke.js';\nimport Style from 'ol/style/Style.js';\nimport Text from 'ol/style/Text.js';\nimport mb2css from 'mapbox-to-css-font';\nimport { Color, featureFilter as createFilter, derefLayers, expression, function as fn, latest as spec, } from '@mapbox/mapbox-gl-style-spec';\nimport { applyLetterSpacing, createCanvas, defaultResolutions, deg2rad, getZoomForResolution, wrapText, } from './util.js';\n/**\n * @typedef {import(\"ol/layer/Vector\").default} VectorLayer\n * @typedef {import(\"ol/layer/VectorTile\").default} VectorTileLayer\n * @typedef {import(\"ol/style/Style\").StyleFunction} StyleFunction\n */\nvar isFunction = fn.isFunction;\nvar convertFunction = fn.convertFunction;\nvar isExpression = expression.isExpression;\nvar createPropertyExpression = expression.createPropertyExpression;\nvar types = {\n    'Point': 1,\n    'MultiPoint': 1,\n    'LineString': 2,\n    'MultiLineString': 2,\n    'Polygon': 3,\n    'MultiPolygon': 3,\n};\nvar anchor = {\n    'center': [0.5, 0.5],\n    'left': [0, 0.5],\n    'right': [1, 0.5],\n    'top': [0.5, 0],\n    'bottom': [0.5, 1],\n    'top-left': [0, 0],\n    'top-right': [1, 0],\n    'bottom-left': [0, 1],\n    'bottom-right': [1, 1],\n};\nvar expressionData = function (rawExpression, propertySpec) {\n    var compiledExpression = createPropertyExpression(rawExpression, propertySpec);\n    if (compiledExpression.result === 'error') {\n        throw new Error(compiledExpression.value\n            .map(function (err) { return err.key + \": \" + err.message; })\n            .join(', '));\n    }\n    return compiledExpression.value;\n};\nvar emptyObj = {};\nvar zoomObj = { zoom: 0 };\n/** @private */\nvar functionCache = {};\nvar renderFeatureCoordinates, renderFeature;\n/**\n * @private\n * @param {Object} layer Gl object layer.\n * @param {string} layoutOrPaint 'layout' or 'paint'.\n * @param {string} property Feature property.\n * @param {number} zoom Zoom.\n * @param {Object} feature Gl feature.\n * @return {?} Value.\n */\nexport function getValue(layer, layoutOrPaint, property, zoom, feature) {\n    var layerId = layer.id;\n    if (!functionCache[layerId]) {\n        functionCache[layerId] = {};\n    }\n    var functions = functionCache[layerId];\n    if (!functions[property]) {\n        var value_1 = (layer[layoutOrPaint] || emptyObj)[property];\n        var propertySpec = spec[layoutOrPaint + \"_\" + layer.type][property];\n        if (value_1 === undefined) {\n            value_1 = propertySpec.default;\n        }\n        var isExpr = isExpression(value_1);\n        if (!isExpr && isFunction(value_1)) {\n            value_1 = convertFunction(value_1, propertySpec);\n            isExpr = true;\n        }\n        if (isExpr) {\n            var compiledExpression = expressionData(value_1, propertySpec);\n            functions[property] =\n                compiledExpression.evaluate.bind(compiledExpression);\n        }\n        else {\n            if (propertySpec.type == 'color') {\n                value_1 = Color.parse(value_1);\n            }\n            functions[property] = function () {\n                return value_1;\n            };\n        }\n    }\n    zoomObj.zoom = zoom;\n    return functions[property](zoomObj, feature);\n}\n/** @private */\nvar filterCache = {};\n/**\n * @private\n * @param {string} layerId Layer id.\n * @param {?} filter Filter.\n * @param {Object} feature Feature.\n * @param {number} zoom Zoom.\n * @return {boolean} Filter result.\n */\nfunction evaluateFilter(layerId, filter, feature, zoom) {\n    if (!(layerId in filterCache)) {\n        filterCache[layerId] = createFilter(filter).filter;\n    }\n    zoomObj.zoom = zoom;\n    return filterCache[layerId](zoomObj, feature);\n}\n/**\n * @private\n * @param {?} color Color.\n * @param {number} opacity Opacity.\n * @return {string} Color.\n */\nfunction colorWithOpacity(color, opacity) {\n    if (color) {\n        if (color.a === 0 || opacity === 0) {\n            return undefined;\n        }\n        var a = color.a;\n        opacity = opacity === undefined ? 1 : opacity;\n        return ('rgba(' +\n            Math.round((color.r * 255) / a) +\n            ',' +\n            Math.round((color.g * 255) / a) +\n            ',' +\n            Math.round((color.b * 255) / a) +\n            ',' +\n            a * opacity +\n            ')');\n    }\n    return color;\n}\nvar templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n/**\n * @private\n * @param {string} text Text.\n * @param {Object} properties Properties.\n * @return {string} Text.\n */\nfunction fromTemplate(text, properties) {\n    var parts;\n    do {\n        parts = text.match(templateRegEx);\n        if (parts) {\n            var value = properties[parts[2]] || '';\n            text = parts[1] + value + parts[3];\n        }\n    } while (parts);\n    return text;\n}\nvar recordLayer = false;\n/**\n * ```js\n * import {recordStyleLayer} from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Turns recording of the Mapbox Style's `layer` on and off. When turned on,\n * the layer that a rendered feature belongs to will be set as the feature's\n * `mapbox-layer` property.\n * @param {boolean} [record=false] Recording of the style layer is on.\n */\nexport function recordStyleLayer(record) {\n    recordLayer = record;\n}\n/**\n * ```js\n * import stylefunction from 'ol-mapbox-style/dist/stylefunction';\n * ```\n * Creates a style function from the `glStyle` object for all layers that use\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\n *\n * Two additional properties will be set on the provided layer:\n *\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\n *    OpenLayers layer was created from. Usually `apply()` creates one\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\n *    layers from different sources in between.\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\n *    included in the OpenLayers layer.\n *\n * This function also works in a web worker. In worker mode, the main thread needs\n * to listen to messages from the worker and respond with another message to make\n * sure that sprite image loading works:\n *\n * ```js\n *  worker.addEventListener('message', event => {\n *   if (event.data.action === 'loadImage') {\n *     const image = new Image();\n *     image.crossOrigin = 'anonymous';\n *     image.addEventListener('load', function() {\n *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {\n *         worker.postMessage({\n *           action: 'imageLoaded',\n *           image: imageBitmap,\n *           src: event.data.src\n *         }, [imageBitmap]);\n *       });\n *     });\n *     image.src = event.data.src;\n *   }\n * });\n * ```\n *\n * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to\n * apply the style to. In addition to the style, the layer will get two\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\n * `glStyle`'s layers.\n * @param {string|Object} glStyle Mapbox Style object.\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\n * from the Mapbox Style object. When a `source` key is provided, all layers for\n * the specified source will be included in the style function. When layer `id`s\n * are provided, they must be from layers that use the same source.\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395, 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\n * Resolutions for mapping resolution to zoom level.\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\n * property is specified in the Mapbox Style object.\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\n * specified in the Mapbox Style object's `sprite` property. Only required if a\n * `sprite` property is specified in the Mapbox Style object.\n * @param {function(Array<string>):Array<string>} [getFonts=undefined] Function that\n * receives a font stack as arguments, and returns a (modified) font stack that\n * is available. Font names are the names used in the Mapbox Style object. If\n * not provided, the font stack will be used as-is. This function can also be\n * used for loading web fonts.\n * @return {StyleFunction} Style function for use in\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\n */\nexport default function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, getFonts) {\n    if (resolutions === void 0) { resolutions = defaultResolutions; }\n    if (typeof glStyle == 'string') {\n        glStyle = JSON.parse(glStyle);\n    }\n    if (glStyle.version != 8) {\n        throw new Error('glStyle version 8 required.');\n    }\n    var spriteImage, spriteImgSize;\n    if (spriteImageUrl) {\n        if (typeof Image !== 'undefined') {\n            var img_1 = new Image();\n            img_1.crossOrigin = 'anonymous';\n            img_1.onload = function () {\n                spriteImage = img_1;\n                spriteImgSize = [img_1.width, img_1.height];\n                olLayer.changed();\n                img_1.onload = null;\n            };\n            img_1.src = spriteImageUrl;\n        }\n        else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) { //eslint-disable-line\n            var worker = /** @type {*} */ (self);\n            // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'\n            worker.postMessage({\n                action: 'loadImage',\n                src: spriteImageUrl,\n            });\n            worker.addEventListener('message', function handler(event) {\n                if (event.data.action === 'imageLoaded' &&\n                    event.data.src === spriteImageUrl) {\n                    spriteImage = event.data.image;\n                    spriteImgSize = [spriteImage.width, spriteImage.height];\n                }\n            });\n        }\n    }\n    var allLayers = derefLayers(glStyle.layers);\n    var layersBySourceLayer = {};\n    var mapboxLayers = [];\n    var mapboxSource;\n    for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n        var layer = allLayers[i];\n        var layerId = layer.id;\n        if ((typeof source == 'string' && layer.source == source) ||\n            source.indexOf(layerId) !== -1) {\n            var sourceLayer = layer['source-layer'];\n            if (!mapboxSource) {\n                mapboxSource = layer.source;\n                var source_1 = glStyle.sources[mapboxSource];\n                if (!source_1) {\n                    throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not defined\");\n                }\n                var type = source_1.type;\n                if (type !== 'vector' && type !== 'geojson') {\n                    throw new Error(\"Source \\\"\" + mapboxSource + \"\\\" is not of type \\\"vector\\\" or \\\"geojson\\\", but \\\"\" + type + \"\\\"\");\n                }\n            }\n            var layers = layersBySourceLayer[sourceLayer];\n            if (!layers) {\n                layers = [];\n                layersBySourceLayer[sourceLayer] = layers;\n            }\n            layers.push({\n                layer: layer,\n                index: i,\n            });\n            mapboxLayers.push(layerId);\n        }\n        // TODO revisit when diffing gets added\n        delete functionCache[layerId];\n        delete filterCache[layerId];\n    }\n    var textHalo = new Stroke();\n    var textColor = new Fill();\n    var iconImageCache = {};\n    var patternCache = {};\n    var styles = [];\n    var styleFunction = function (feature, resolution) {\n        var properties = feature.getProperties();\n        var layers = layersBySourceLayer[properties.layer];\n        if (!layers) {\n            return;\n        }\n        var zoom = resolutions.indexOf(resolution);\n        if (zoom == -1) {\n            zoom = getZoomForResolution(resolution, resolutions);\n        }\n        var type = types[feature.getGeometry().getType()];\n        var f = {\n            properties: properties,\n            type: type,\n        };\n        var stylesLength = -1;\n        var featureBelongsToLayer;\n        var _loop_1 = function (i, ii) {\n            var layerData = layers[i];\n            var layer = layerData.layer;\n            var layerId = layer.id;\n            var layout = layer.layout || emptyObj;\n            var paint = layer.paint || emptyObj;\n            if (layout.visibility === 'none' ||\n                ('minzoom' in layer && zoom < layer.minzoom) ||\n                ('maxzoom' in layer && zoom >= layer.maxzoom)) {\n                return \"continue\";\n            }\n            var filter = layer.filter;\n            if (!filter || evaluateFilter(layerId, filter, f, zoom)) {\n                featureBelongsToLayer = layer;\n                var color = void 0, opacity = void 0, fill = void 0, stroke = void 0, strokeColor = void 0, style = void 0;\n                var index = layerData.index;\n                if (type == 3 &&\n                    (layer.type == 'fill' || layer.type == 'fill-extrusion')) {\n                    opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f);\n                    if (layer.type + '-pattern' in paint) {\n                        var fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f);\n                        if (fillIcon) {\n                            var icon_1 = typeof fillIcon === 'string'\n                                ? fromTemplate(fillIcon, properties)\n                                : fillIcon.toString();\n                            if (spriteImage && spriteData && spriteData[icon_1]) {\n                                ++stylesLength;\n                                style = styles[stylesLength];\n                                if (!style ||\n                                    !style.getFill() ||\n                                    style.getStroke() ||\n                                    style.getText()) {\n                                    style = new Style({\n                                        fill: new Fill(),\n                                    });\n                                    styles[stylesLength] = style;\n                                }\n                                fill = style.getFill();\n                                style.setZIndex(index);\n                                var icon_cache_key = icon_1 + '.' + opacity;\n                                var pattern = patternCache[icon_cache_key];\n                                if (!pattern) {\n                                    var spriteImageData = spriteData[icon_1];\n                                    var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                                    var ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n                                    ctx.globalAlpha = opacity;\n                                    ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                                    pattern = ctx.createPattern(canvas, 'repeat');\n                                    patternCache[icon_cache_key] = pattern;\n                                }\n                                fill.setColor(pattern);\n                            }\n                        }\n                    }\n                    else {\n                        color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f), opacity);\n                        if (color) {\n                            if (layer.type + '-outline-color' in paint) {\n                                strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f), opacity);\n                            }\n                            if (!strokeColor) {\n                                strokeColor = color;\n                            }\n                            ++stylesLength;\n                            style = styles[stylesLength];\n                            if (!style ||\n                                !(style.getFill() && style.getStroke()) ||\n                                style.getText()) {\n                                style = new Style({\n                                    fill: new Fill(),\n                                    stroke: new Stroke(),\n                                });\n                                styles[stylesLength] = style;\n                            }\n                            fill = style.getFill();\n                            fill.setColor(color);\n                            stroke = style.getStroke();\n                            stroke.setColor(strokeColor);\n                            stroke.setWidth(1);\n                            style.setZIndex(index);\n                        }\n                    }\n                }\n                if (type != 1 && layer.type == 'line') {\n                    color =\n                        !('line-pattern' in paint) && 'line-color' in paint\n                            ? colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f), getValue(layer, 'paint', 'line-opacity', zoom, f))\n                            : undefined;\n                    var width_1 = getValue(layer, 'paint', 'line-width', zoom, f);\n                    if (color && width_1 > 0) {\n                        ++stylesLength;\n                        style = styles[stylesLength];\n                        if (!style ||\n                            !style.getStroke() ||\n                            style.getFill() ||\n                            style.getText()) {\n                            style = new Style({\n                                stroke: new Stroke(),\n                            });\n                            styles[stylesLength] = style;\n                        }\n                        stroke = style.getStroke();\n                        stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f));\n                        stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f));\n                        stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f));\n                        stroke.setColor(color);\n                        stroke.setWidth(width_1);\n                        stroke.setLineDash(paint['line-dasharray']\n                            ? getValue(layer, 'paint', 'line-dasharray', zoom, f).map(function (x) {\n                                return x * width_1;\n                            })\n                            : null);\n                        style.setZIndex(index);\n                    }\n                }\n                var hasImage = false;\n                var text = null;\n                var placementAngle = 0;\n                var icon = void 0, iconImg = void 0, skipLabel = void 0;\n                if ((type == 1 || type == 2) && 'icon-image' in layout) {\n                    var iconImage = getValue(layer, 'layout', 'icon-image', zoom, f);\n                    if (iconImage) {\n                        icon =\n                            typeof iconImage === 'string'\n                                ? fromTemplate(iconImage, properties)\n                                : iconImage.toString();\n                        var styleGeom = undefined;\n                        if (spriteImage && spriteData && spriteData[icon]) {\n                            var iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f);\n                            if (type == 2) {\n                                var geom = feature.getGeometry();\n                                // ol package and ol-debug.js only\n                                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {\n                                    var extent = geom.getExtent();\n                                    var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n                                    if (size > 150) {\n                                        //FIXME Do not hard-code a size of 150\n                                        var midpoint = geom.getType() === 'MultiLineString'\n                                            ? geom.getFlatMidpoints()\n                                            : geom.getFlatMidpoint();\n                                        if (!renderFeature) {\n                                            renderFeatureCoordinates = [NaN, NaN];\n                                            renderFeature = new RenderFeature('Point', renderFeatureCoordinates, [], {}, null);\n                                        }\n                                        styleGeom = renderFeature;\n                                        renderFeatureCoordinates[0] = midpoint[0];\n                                        renderFeatureCoordinates[1] = midpoint[1];\n                                        var placement = getValue(layer, 'layout', 'symbol-placement', zoom, f);\n                                        if (placement === 'line' &&\n                                            iconRotationAlignment === 'map') {\n                                            var stride = geom.getStride();\n                                            var coordinates = geom.getFlatCoordinates();\n                                            for (var i_1 = 0, ii_1 = coordinates.length - stride; i_1 < ii_1; i_1 += stride) {\n                                                var x1 = coordinates[i_1];\n                                                var y1 = coordinates[i_1 + 1];\n                                                var x2 = coordinates[i_1 + stride];\n                                                var y2 = coordinates[i_1 + stride + 1];\n                                                var minX = Math.min(x1, x2);\n                                                var minY = Math.min(y1, y2);\n                                                var maxX = Math.max(x1, x2);\n                                                var maxY = Math.max(y1, y2);\n                                                if (midpoint[0] >= minX &&\n                                                    midpoint[0] <= maxX &&\n                                                    midpoint[1] >= minY &&\n                                                    midpoint[1] <= maxY) {\n                                                    placementAngle = Math.atan2(y1 - y2, x2 - x1);\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            if (type !== 2 || styleGeom) {\n                                var iconSize = getValue(layer, 'layout', 'icon-size', zoom, f);\n                                var iconColor = paint['icon-color'] !== undefined\n                                    ? getValue(layer, 'paint', 'icon-color', zoom, f)\n                                    : null;\n                                if (!iconColor || iconColor.a !== 0) {\n                                    var icon_cache_key = icon + '.' + iconSize;\n                                    if (iconColor !== null) {\n                                        icon_cache_key += '.' + iconColor;\n                                    }\n                                    iconImg = iconImageCache[icon_cache_key];\n                                    if (!iconImg) {\n                                        var spriteImageData = spriteData[icon];\n                                        if (iconColor !== null) {\n                                            // cut out the sprite and color it\n                                            var canvas = createCanvas(spriteImageData.width, spriteImageData.height);\n                                            var ctx = /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n                                            ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                                            var data = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                                            for (var c = 0, cc = data.data.length; c < cc; c += 4) {\n                                                var a = iconColor.a;\n                                                if (a !== 0) {\n                                                    data.data[c] = (iconColor.r * 255) / a;\n                                                    data.data[c + 1] = (iconColor.g * 255) / a;\n                                                    data.data[c + 2] = (iconColor.b * 255) / a;\n                                                }\n                                                data.data[c + 3] = a;\n                                            }\n                                            ctx.putImageData(data, 0, 0);\n                                            iconImg = new Icon({\n                                                img: canvas,\n                                                imgSize: [canvas.width, canvas.height],\n                                                scale: iconSize / spriteImageData.pixelRatio,\n                                            });\n                                            iconImageCache[icon_cache_key] = iconImg;\n                                        }\n                                        else {\n                                            iconImg = new Icon({\n                                                img: spriteImage,\n                                                imgSize: spriteImgSize,\n                                                size: [spriteImageData.width, spriteImageData.height],\n                                                offset: [spriteImageData.x, spriteImageData.y],\n                                                rotateWithView: iconRotationAlignment === 'map',\n                                                scale: iconSize / spriteImageData.pixelRatio,\n                                            });\n                                            iconImageCache[icon_cache_key] = iconImg;\n                                        }\n                                    }\n                                }\n                                if (iconImg) {\n                                    ++stylesLength;\n                                    style = styles[stylesLength];\n                                    if (!style ||\n                                        !style.getImage() ||\n                                        style.getFill() ||\n                                        style.getStroke()) {\n                                        style = new Style();\n                                        styles[stylesLength] = style;\n                                    }\n                                    style.setGeometry(styleGeom);\n                                    iconImg.setRotation(placementAngle +\n                                        deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f)));\n                                    iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f));\n                                    iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f)]);\n                                    style.setImage(iconImg);\n                                    text = style.getText();\n                                    style.setText(undefined);\n                                    style.setZIndex(index);\n                                    hasImage = true;\n                                    skipLabel = false;\n                                }\n                            }\n                            else {\n                                skipLabel = true;\n                            }\n                        }\n                    }\n                }\n                if (type == 1 && 'circle-radius' in paint) {\n                    ++stylesLength;\n                    style = styles[stylesLength];\n                    if (!style ||\n                        !style.getImage() ||\n                        style.getFill() ||\n                        style.getStroke()) {\n                        style = new Style();\n                        styles[stylesLength] = style;\n                    }\n                    var circleRadius = getValue(layer, 'paint', 'circle-radius', zoom, f);\n                    var circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f));\n                    var circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f), getValue(layer, 'paint', 'circle-opacity', zoom, f));\n                    var circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f);\n                    var cache_key = circleRadius +\n                        '.' +\n                        circleStrokeColor +\n                        '.' +\n                        circleColor +\n                        '.' +\n                        circleStrokeWidth;\n                    iconImg = iconImageCache[cache_key];\n                    if (!iconImg) {\n                        iconImg = new Circle({\n                            radius: circleRadius,\n                            stroke: circleStrokeColor && circleStrokeWidth > 0\n                                ? new Stroke({\n                                    width: circleStrokeWidth,\n                                    color: circleStrokeColor,\n                                })\n                                : undefined,\n                            fill: circleColor\n                                ? new Fill({\n                                    color: circleColor,\n                                })\n                                : undefined,\n                        });\n                        iconImageCache[cache_key] = iconImg;\n                    }\n                    style.setImage(iconImg);\n                    text = style.getText();\n                    style.setText(undefined);\n                    style.setGeometry(undefined);\n                    style.setZIndex(index);\n                    hasImage = true;\n                }\n                var label = void 0;\n                if ('text-field' in layout) {\n                    var textField = getValue(layer, 'layout', 'text-field', zoom, f).toString();\n                    label = fromTemplate(textField, properties).trim();\n                    opacity = getValue(layer, 'paint', 'text-opacity', zoom, f);\n                }\n                if (label && opacity && !skipLabel) {\n                    if (!hasImage) {\n                        ++stylesLength;\n                        style = styles[stylesLength];\n                        if (!style ||\n                            !style.getText() ||\n                            style.getFill() ||\n                            style.getStroke()) {\n                            style = new Style();\n                            styles[stylesLength] = style;\n                        }\n                        style.setImage(undefined);\n                        style.setGeometry(undefined);\n                    }\n                    if (!style.getText()) {\n                        style.setText(text ||\n                            new Text({\n                                padding: [2, 2, 2, 2],\n                            }));\n                    }\n                    text = style.getText();\n                    var textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f));\n                    var fontArray = getValue(layer, 'layout', 'text-font', zoom, f);\n                    var textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f);\n                    var font = mb2css(getFonts ? getFonts(fontArray) : fontArray, textSize, textLineHeight);\n                    var textTransform = layout['text-transform'];\n                    if (textTransform == 'uppercase') {\n                        label = label.toUpperCase();\n                    }\n                    else if (textTransform == 'lowercase') {\n                        label = label.toLowerCase();\n                    }\n                    var maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f);\n                    var letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f);\n                    var wrappedLabel = type == 2\n                        ? applyLetterSpacing(label, letterSpacing)\n                        : wrapText(label, font, maxTextWidth, letterSpacing);\n                    text.setText(wrappedLabel);\n                    text.setFont(font);\n                    text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f)));\n                    var textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f);\n                    var placement = hasImage || type == 1\n                        ? 'point'\n                        : getValue(layer, 'layout', 'symbol-placement', zoom, f);\n                    text.setPlacement(placement);\n                    var textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f);\n                    var textOffset = getValue(layer, 'layout', 'text-offset', zoom, f);\n                    var textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f);\n                    // Text offset has to take halo width and line height into account\n                    var vOffset = 0;\n                    var hOffset = 0;\n                    if (placement == 'point') {\n                        var textAlign = 'center';\n                        if (textAnchor.indexOf('left') !== -1) {\n                            textAlign = 'left';\n                            hOffset = textHaloWidth;\n                        }\n                        else if (textAnchor.indexOf('right') !== -1) {\n                            textAlign = 'right';\n                            hOffset = -textHaloWidth;\n                        }\n                        text.setTextAlign(textAlign);\n                        var textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f);\n                        text.setRotateWithView(textRotationAlignment == 'map');\n                    }\n                    else {\n                        text.setMaxAngle((deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f)) *\n                            label.length) /\n                            wrappedLabel.length);\n                        text.setTextAlign();\n                        text.setRotateWithView(false);\n                    }\n                    var textBaseline = 'middle';\n                    if (textAnchor.indexOf('bottom') == 0) {\n                        textBaseline = 'bottom';\n                        vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;\n                    }\n                    else if (textAnchor.indexOf('top') == 0) {\n                        textBaseline = 'top';\n                        vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;\n                    }\n                    text.setTextBaseline(textBaseline);\n                    text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);\n                    text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);\n                    textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f), opacity));\n                    text.setFill(textColor);\n                    var haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f), opacity);\n                    if (haloColor) {\n                        textHalo.setColor(haloColor);\n                        // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width\n                        // Halo width must be doubled because it is applied around the center of the text outline\n                        textHaloWidth *= 2;\n                        // 1/4 of text size (spec) x 2\n                        var halfTextSize = 0.5 * textSize;\n                        textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);\n                        text.setStroke(textHalo);\n                    }\n                    else {\n                        text.setStroke(undefined);\n                    }\n                    var textPadding = getValue(layer, 'layout', 'text-padding', zoom, f);\n                    var padding = text.getPadding();\n                    if (textPadding !== padding[0]) {\n                        padding[0] = textPadding;\n                        padding[1] = textPadding;\n                        padding[2] = textPadding;\n                        padding[3] = textPadding;\n                    }\n                    style.setZIndex(index);\n                }\n            }\n        };\n        for (var i = 0, ii = layers.length; i < ii; ++i) {\n            _loop_1(i, ii);\n        }\n        if (stylesLength > -1) {\n            styles.length = stylesLength + 1;\n            if (recordLayer) {\n                if (typeof feature.set === 'function') {\n                    // ol/Feature\n                    feature.set('mapbox-layer', featureBelongsToLayer);\n                }\n                else {\n                    // ol/render/Feature\n                    feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;\n                }\n            }\n            return styles;\n        }\n    };\n    olLayer.setStyle(styleFunction);\n    olLayer.set('mapbox-source', mapboxSource);\n    olLayer.set('mapbox-layers', mapboxLayers);\n    return styleFunction;\n}\nexport { colorWithOpacity as _colorWithOpacity, filterCache as _filterCache, evaluateFilter as _evaluateFilter, fromTemplate as _fromTemplate, getValue as _getValue, functionCache as _functionCache, };\n//# sourceMappingURL=stylefunction.js.map"]},"metadata":{},"sourceType":"module"}